Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle b/app/build.gradle
--- a/app/build.gradle	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/app/build.gradle	(date 1726419809535)
@@ -54,10 +54,11 @@
 dependencies {
     implementation fileTree(include: ['*.jar'], dir: 'libs')
 
-    implementation project (':cardstackview')
-    implementation project (':iosdialog')
-    implementation project (':overscroll-bouncy')
-    implementation project (':signseekbar')
+//    implementation project (':cardstackview')
+//    implementation project (':iosdialog')
+//    implementation project (':overscroll-bouncy')
+
+    implementation 'io.michaelrocks:libphonenumber-android:8.12.44'
 
     //noinspection GradleCompatible
     implementation 'androidx.appcompat:appcompat:1.3.1'
@@ -80,11 +81,13 @@
     implementation 'com.google.android.material:material:1.4.0'
     implementation 'androidx.cardview:cardview:1.0.0'
     implementation 'androidx.percentlayout:percentlayout:1.0.0'
-    implementation 'com.mindorks.android:prdownloader:0.6.0'
+//    implementation 'com.mindorks.android:prdownloader:0.6.0'
+    implementation 'com.github.amitshekhariitbhu:PRDownloader:1.0.1'
 //    implementation 'com.chauthai.overscroll:overscroll-bouncy:0.1.1'
     implementation 'pl.bclogic:pulsator4droid:1.0.3'
-    implementation 'me.everything:overscroll-decor-android:1.0.4'
-    implementation 'com.labo.kaji:fragmentanimations:0.1.1'
+//    implementation 'me.everything:overscroll-decor-android:1.0.4'
+    implementation 'io.github.everythingme:overscroll-decor-android:1.1.1'
+//    implementation 'com.labo.kaji:fragmentanimations:0.1.1'
     implementation 'com.mcxiaoke.volley:library-aar:1.0.0'
     implementation 'com.facebook.android:facebook-login:15.1.0'
 //    implementation 'com.gmail.samehadar:iosdialog:1.0'
@@ -101,8 +104,8 @@
 //    implementation 'com.zhouyou:signseekbar:1.0.6'
 
     implementation 'net.the4thdimension:audio-wife:1.0.3'
-    implementation 'com.github.aakira:expandable-layout:1.6.0@aar'
-    implementation 'com.appyvet:materialrangebar:1.4.8'
+//    implementation 'com.github.aakira:expandable-layout:1.6.0@aar'
+//    implementation 'com.appyvet:materialrangebar:1.4.8'
 
     // fresco image display library
     implementation 'com.facebook.fresco:fresco:2.3.0'
@@ -110,7 +113,7 @@
 
     implementation 'com.mikhaellopez:circularprogressbar:3.1.0'
 
-    implementation 'com.theartofdev.edmodo:android-image-cropper:2.8.0'
+//    implementation 'com.theartofdev.edmodo:android-image-cropper:2.8.0'
 
     //twillio
     implementation "com.twilio:video-android:7.0.3"
@@ -136,8 +139,9 @@
     implementation 'cat.ereza:customactivityoncrash:2.3.0'
 
     implementation 'com.github.joielechong:countrycodepicker:2.4.2'
-    implementation 'com.chaos.view:pinview:1.4.4'
-    implementation 'com.ycuwq.widgets:datepicker:1.3.1'
+//    implementation 'com.chaos.view:pinview:1.4.4'
+//    implementation 'com.ycuwq.widgets:datepicker:1.3.1'
+    implementation 'com.github.ycuwq:DatePicker:1.3.4'
 
     implementation 'com.fasterxml.jackson.core:jackson-databind:2.8.5'
     implementation 'com.fasterxml.jackson.core:jackson-core:2.8.5'
Index: app/src/main/java/com/labo/kaji/fragmentanimations/PushPullAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/labo/kaji/fragmentanimations/PushPullAnimation.java b/app/src/main/java/com/labo/kaji/fragmentanimations/PushPullAnimation.java
new file mode 100644
--- /dev/null	(date 1726417925626)
+++ b/app/src/main/java/com/labo/kaji/fragmentanimations/PushPullAnimation.java	(date 1726417925626)
@@ -0,0 +1,106 @@
+package com.labo.kaji.fragmentanimations;
+
+import android.view.animation.Transformation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+/**
+ * 3D Push/Pull Animation
+ * @author kakajika
+ * @since 2015/11/28
+ */
+public class PushPullAnimation extends ViewPropertyAnimation {
+
+    @IntDef ({UP, DOWN, LEFT, RIGHT})
+    @Retention(RetentionPolicy.SOURCE)
+    @interface Direction {}
+    public static final int UP    = 1;
+    public static final int DOWN  = 2;
+    public static final int LEFT  = 3;
+    public static final int RIGHT = 4;
+
+    protected final @Direction int mDirection;
+    protected final boolean mEnter;
+
+    /**
+     * Create new Animation.
+     * @param direction Direction of animation
+     * @param enter true for Enter / false for Exit
+     * @param duration Duration of Animation
+     * @return
+     */
+    public static @NonNull PushPullAnimation create(@Direction int direction, boolean enter, long duration) {
+        switch (direction) {
+            case UP:
+            case DOWN:
+                return new VerticalPushPullAnimation(direction, enter, duration);
+            case LEFT:
+            case RIGHT:
+            default:
+                return new HorizontalPushPullAnimation(direction, enter, duration);
+        }
+    }
+
+    private PushPullAnimation(@Direction int direction, boolean enter, long duration) {
+        mDirection = direction;
+        mEnter = enter;
+        setDuration(duration);
+    }
+
+    private static class VerticalPushPullAnimation extends PushPullAnimation {
+
+        private VerticalPushPullAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = width * 0.5f;
+            mPivotY = (mEnter == (mDirection == DOWN)) ? 0.0f : height;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == UP) value *= -1.0f;
+            mRotationX = value * 90.0f;
+            mAlpha = mEnter ? interpolatedTime : (1.0f - interpolatedTime);
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+    private static class HorizontalPushPullAnimation extends PushPullAnimation {
+
+        private HorizontalPushPullAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = (mEnter == (mDirection == RIGHT)) ? 0.0f : width;
+            mPivotY = height * 0.5f;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == LEFT) value *= -1.0f;
+            mRotationY = -value * 90.0f;
+            mAlpha = mEnter ? interpolatedTime : (1.0f - interpolatedTime);
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+}
Index: app/src/main/java/com/labo/kaji/fragmentanimations/SidesAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/labo/kaji/fragmentanimations/SidesAnimation.java b/app/src/main/java/com/labo/kaji/fragmentanimations/SidesAnimation.java
new file mode 100644
--- /dev/null	(date 1726417925676)
+++ b/app/src/main/java/com/labo/kaji/fragmentanimations/SidesAnimation.java	(date 1726417925676)
@@ -0,0 +1,110 @@
+package com.labo.kaji.fragmentanimations;
+
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.Transformation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+/**
+ * 3D Cube Animation
+ * @author kakajika
+ * @since 2015/11/28
+ */
+public class SidesAnimation extends ViewPropertyAnimation {
+
+    @IntDef ({UP, DOWN, LEFT, RIGHT})
+    @Retention(RetentionPolicy.SOURCE)
+    @interface Direction {}
+    public static final int UP    = 1;
+    public static final int DOWN  = 2;
+    public static final int LEFT  = 3;
+    public static final int RIGHT = 4;
+
+    protected final @Direction int mDirection;
+    protected final boolean mEnter;
+
+    /**
+     * Create new Animation.
+     * @param direction Direction of animation
+     * @param enter true for Enter / false for Exit
+     * @param duration Duration of Animation
+     * @return
+     */
+    public static @NonNull SidesAnimation create(@Direction int direction, boolean enter, long duration) {
+        switch (direction) {
+            case UP:
+            case DOWN:
+                return new VerticalCubeAnimation(direction, enter, duration);
+            case LEFT:
+            case RIGHT:
+            default:
+                return new HorizontalCubeAnimation(direction, enter, duration);
+        }
+    }
+
+    private SidesAnimation(@Direction int direction, boolean enter, long duration) {
+        mDirection = direction;
+        mEnter = enter;
+        setDuration(duration);
+        setInterpolator(new AccelerateDecelerateInterpolator());
+    }
+
+    private static class VerticalCubeAnimation extends SidesAnimation {
+
+        private VerticalCubeAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = width * 0.5f;
+            mPivotY = (mEnter == (mDirection == DOWN)) ? 0.0f : height;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == UP) value *= -1.0f;
+            mRotationX = value * 90.0f;
+            mAlpha = mEnter ? interpolatedTime : (1.0f - interpolatedTime);
+            mTranslationZ = (1.0f - mAlpha) * mWidth;
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+    private static class HorizontalCubeAnimation extends SidesAnimation {
+
+        private HorizontalCubeAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = (mEnter == (mDirection == RIGHT)) ? 0.0f : width;
+            mPivotY = height * 0.5f;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == LEFT) value *= -1.0f;
+            mRotationY = -value * 90.0f;
+            mAlpha = mEnter ? interpolatedTime : (1.0f - interpolatedTime);
+            mTranslationZ = (1.0f - mAlpha) * mHeight;
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+}
Index: app/src/main/java/com/labo/kaji/fragmentanimations/ViewPropertyAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/labo/kaji/fragmentanimations/ViewPropertyAnimation.java b/app/src/main/java/com/labo/kaji/fragmentanimations/ViewPropertyAnimation.java
new file mode 100644
--- /dev/null	(date 1726417925637)
+++ b/app/src/main/java/com/labo/kaji/fragmentanimations/ViewPropertyAnimation.java	(date 1726417925637)
@@ -0,0 +1,101 @@
+package com.labo.kaji.fragmentanimations;
+
+import android.graphics.Camera;
+import android.graphics.Matrix;
+import android.os.Build;
+import android.view.animation.Animation;
+import android.view.animation.Transformation;
+
+import androidx.annotation.FloatRange;
+
+/**
+ * @author kakajika
+ * @since 2015/11/27
+ */
+public class ViewPropertyAnimation extends Animation {
+
+    private final Camera mCamera = new Camera();
+    protected int mWidth  = 0;
+    protected int mHeight = 0;
+    protected float mAlpha = 1.0f;
+    protected float mPivotX = 0.0f;
+    protected float mPivotY = 0.0f;
+    protected float mScaleX = 1.0f;
+    protected float mScaleY = 1.0f;
+    protected float mRotationX = 0.0f;
+    protected float mRotationY = 0.0f;
+    protected float mRotationZ = 0.0f;
+    protected float mTranslationX = 0.0f;
+    protected float mTranslationY = 0.0f;
+    protected float mTranslationZ = 0.0f;
+    protected float mCameraX = 0.0f;
+    protected float mCameraY = 0.0f;
+    protected float mCameraZ = -8.0f;
+
+    private float mFromAlpha = -1.0f;
+    private float mToAlpha   = -1.0f;
+
+    public ViewPropertyAnimation fading(@FloatRange (from=0.0f,to=1.0f) float fromAlpha, @FloatRange(from=0.0f,to=1.0f) float toAlpha) {
+        mFromAlpha = fromAlpha;
+        mToAlpha = toAlpha;
+        return this;
+    }
+
+    @Override
+    public void initialize(int width, int height, int parentWidth, int parentHeight) {
+        super.initialize(width, height, parentWidth, parentHeight);
+        mWidth = width;
+        mHeight = height;
+    }
+
+    @Override
+    protected void applyTransformation(float interpolatedTime, Transformation t) {
+        super.applyTransformation(interpolatedTime, t);
+        if (mFromAlpha >= 0 && mToAlpha >= 0) {
+            mAlpha = mFromAlpha + (mToAlpha - mFromAlpha) * interpolatedTime;
+        }
+    }
+
+    protected void applyTransformation(Transformation t) {
+        final Matrix m = t.getMatrix();
+        final float w = mWidth;
+        final float h = mHeight;
+        final float pX = mPivotX;
+        final float pY = mPivotY;
+
+        final float rX = mRotationX;
+        final float rY = mRotationY;
+        final float rZ = mRotationZ;
+        if ((rX != 0) || (rY != 0) || (rZ != 0)) {
+            final Camera camera = mCamera;
+            camera.save();
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
+                camera.setLocation(mCameraX, mCameraY, mCameraZ);
+            }
+            if (mTranslationZ != 0) {
+                camera.translate(0, 0, mTranslationZ);
+            }
+            camera.rotateX(rX);
+            camera.rotateY(rY);
+            camera.rotateZ(-rZ);
+            camera.getMatrix(m);
+            camera.restore();
+            m.preTranslate(-pX, -pY);
+            m.postTranslate(pX, pY);
+        }
+
+        final float sX = mScaleX;
+        final float sY = mScaleY;
+        if ((sX != 1.0f) || (sY != 1.0f)) {
+            m.postScale(sX, sY);
+            final float sPX = -(pX / w) * ((sX * w) - w);
+            final float sPY = -(pY / h) * ((sY * h) - h);
+            m.postTranslate(sPX, sPY);
+        }
+
+        m.postTranslate(mTranslationX, mTranslationY);
+
+        t.setAlpha(mAlpha);
+    }
+
+}
Index: app/src/main/java/com/labo/kaji/fragmentanimations/CubeAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/labo/kaji/fragmentanimations/CubeAnimation.java b/app/src/main/java/com/labo/kaji/fragmentanimations/CubeAnimation.java
new file mode 100644
--- /dev/null	(date 1726417925647)
+++ b/app/src/main/java/com/labo/kaji/fragmentanimations/CubeAnimation.java	(date 1726417925647)
@@ -0,0 +1,108 @@
+package com.labo.kaji.fragmentanimations;
+
+import android.view.animation.Transformation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+/**
+ * 3D Cube Animation
+ * @author kakajika
+ * @since 2015/11/28
+ */
+public class CubeAnimation extends ViewPropertyAnimation {
+
+    @IntDef ({UP, DOWN, LEFT, RIGHT})
+    @Retention(RetentionPolicy.SOURCE)
+    @interface Direction {}
+    public static final int UP    = 1;
+    public static final int DOWN  = 2;
+    public static final int LEFT  = 3;
+    public static final int RIGHT = 4;
+
+    protected final @Direction int mDirection;
+    protected final boolean mEnter;
+
+    /**
+     * Create new Animation.
+     * @param direction Direction of animation
+     * @param enter true for Enter / false for Exit
+     * @param duration Duration of Animation
+     * @return
+     */
+    public static @NonNull CubeAnimation create(@Direction int direction, boolean enter, long duration) {
+        switch (direction) {
+            case UP:
+            case DOWN:
+                return new VerticalCubeAnimation(direction, enter, duration);
+            case LEFT:
+            case RIGHT:
+            default:
+                return new HorizontalCubeAnimation(direction, enter, duration);
+        }
+    }
+
+    private CubeAnimation(@Direction int direction, boolean enter, long duration) {
+        mDirection = direction;
+        mEnter = enter;
+        setDuration(duration);
+    }
+
+    private static class VerticalCubeAnimation extends CubeAnimation {
+
+        private VerticalCubeAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = width * 0.5f;
+            mPivotY = (mEnter == (mDirection == UP)) ? 0.0f : height;
+            mCameraZ = -height * 0.015f;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == DOWN) value *= -1.0f;
+            mRotationX = value * 90.0f;
+            mTranslationY = -value * mHeight;
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+    private static class HorizontalCubeAnimation extends CubeAnimation {
+
+        private HorizontalCubeAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = (mEnter == (mDirection == LEFT)) ? 0.0f : width;
+            mPivotY = height * 0.5f;
+            mCameraZ = -width * 0.015f;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == RIGHT) value *= -1.0f;
+            mRotationY = -value * 90.0f;
+            mTranslationX = -value * mWidth;
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+}
Index: app/src/main/java/com/labo/kaji/fragmentanimations/MoveAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/labo/kaji/fragmentanimations/MoveAnimation.java b/app/src/main/java/com/labo/kaji/fragmentanimations/MoveAnimation.java
new file mode 100644
--- /dev/null	(date 1726417925660)
+++ b/app/src/main/java/com/labo/kaji/fragmentanimations/MoveAnimation.java	(date 1726417925660)
@@ -0,0 +1,90 @@
+package com.labo.kaji.fragmentanimations;
+
+import android.view.animation.Transformation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+/**
+ * Move Animation
+ * @author kakajika
+ * @since 2015/11/28
+ */
+public class MoveAnimation extends ViewPropertyAnimation {
+
+    @IntDef ({UP, DOWN, LEFT, RIGHT})
+    @Retention(RetentionPolicy.SOURCE)
+    @interface Direction {}
+    public static final int UP    = 1;
+    public static final int DOWN  = 2;
+    public static final int LEFT  = 3;
+    public static final int RIGHT = 4;
+
+    protected final @Direction int mDirection;
+    protected final boolean mEnter;
+
+    /**
+     * Create new Animation.
+     * @param direction Direction of animation
+     * @param enter true for Enter / false for Exit
+     * @param duration Duration of Animation
+     * @return
+     */
+    public static @NonNull MoveAnimation create(@Direction int direction, boolean enter, long duration) {
+        switch (direction) {
+            case UP:
+            case DOWN:
+                return new VerticalMoveAnimation(direction, enter, duration);
+            case LEFT:
+            case RIGHT:
+            default:
+                return new HorizontalMoveAnimation(direction, enter, duration);
+        }
+    }
+
+    private MoveAnimation(@Direction int direction, boolean enter, long duration) {
+        mDirection = direction;
+        mEnter = enter;
+        setDuration(duration);
+    }
+
+    private static class VerticalMoveAnimation extends MoveAnimation {
+
+        private VerticalMoveAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == DOWN) value *= -1.0f;
+            mTranslationY = -value * mHeight;
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+    private static class HorizontalMoveAnimation extends MoveAnimation {
+
+        private HorizontalMoveAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == RIGHT) value *= -1.0f;
+            mTranslationX = -value * mWidth;
+
+            super.applyTransformation(interpolatedTime, t);
+            applyTransformation(t);
+        }
+
+    }
+
+}
Index: app/src/main/java/com/labo/kaji/fragmentanimations/FlipAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/labo/kaji/fragmentanimations/FlipAnimation.java b/app/src/main/java/com/labo/kaji/fragmentanimations/FlipAnimation.java
new file mode 100644
--- /dev/null	(date 1726417925611)
+++ b/app/src/main/java/com/labo/kaji/fragmentanimations/FlipAnimation.java	(date 1726417925611)
@@ -0,0 +1,124 @@
+package com.labo.kaji.fragmentanimations;
+
+import android.view.animation.Transformation;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+/**
+ * 3D Flip Animation
+ * @author kakajika
+ * @since 2015/11/28
+ */
+public class FlipAnimation extends ViewPropertyAnimation {
+
+    @IntDef ({UP, DOWN, LEFT, RIGHT})
+    @Retention(RetentionPolicy.SOURCE)
+    @interface Direction {}
+    public static final int UP    = 1;
+    public static final int DOWN  = 2;
+    public static final int LEFT  = 3;
+    public static final int RIGHT = 4;
+
+    protected final @Direction int mDirection;
+    protected final boolean mEnter;
+
+    /**
+     * Create new Animation.
+     * @param direction Direction of animation
+     * @param enter true for Enter / false for Exit
+     * @param duration Duration of Animation
+     * @return
+     */
+    public static @NonNull FlipAnimation create(@Direction int direction, boolean enter, long duration) {
+        switch (direction) {
+            case UP:
+            case DOWN:
+                return new VerticalFlipAnimation(direction, enter, duration);
+            case LEFT:
+            case RIGHT:
+            default:
+                return new HorizontalFlipAnimation(direction, enter, duration);
+        }
+    }
+
+    private FlipAnimation(@Direction int direction, boolean enter, long duration) {
+        mDirection = direction;
+        mEnter = enter;
+        setDuration(duration);
+    }
+
+    private static class VerticalFlipAnimation extends FlipAnimation {
+
+        public VerticalFlipAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = width * 0.5f;
+            mPivotY = (mEnter == (mDirection == UP)) ? 0.0f : height;
+            mCameraZ = -height * 0.015f;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == DOWN) value *= -1.0f;
+            mRotationX = value * 180.0f;
+            mTranslationY = -value * mHeight;
+
+            super.applyTransformation(interpolatedTime, t);
+
+            // Hide entering/exiting view before/after half point.
+            if (mEnter) {
+                mAlpha = interpolatedTime <= 0.5f ? 0.0f : 1.0f;
+            } else {
+                mAlpha = interpolatedTime <= 0.5f ? 1.0f : 0.0f;
+            }
+
+            applyTransformation(t);
+        }
+
+    }
+
+    private static class HorizontalFlipAnimation extends FlipAnimation {
+
+        public HorizontalFlipAnimation(@Direction int direction, boolean enter, long duration) {
+            super(direction, enter, duration);
+        }
+
+        @Override
+        public void initialize(int width, int height, int parentWidth, int parentHeight) {
+            super.initialize(width, height, parentWidth, parentHeight);
+            mPivotX = (mEnter == (mDirection == LEFT)) ? 0.0f : width;
+            mPivotY = height * 0.5f;
+            mCameraZ = -width * 0.015f;
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            float value = mEnter ? (interpolatedTime - 1.0f) : interpolatedTime;
+            if (mDirection == RIGHT) value *= -1.0f;
+            mRotationY = -value * 180.0f;
+            mTranslationX = -value * mWidth;
+
+            super.applyTransformation(interpolatedTime, t);
+
+            // Hide entering/exiting view before/after half point.
+            if (mEnter) {
+                mAlpha = interpolatedTime <= 0.5f ? 0.0f : 1.0f;
+            } else {
+                mAlpha = interpolatedTime <= 0.5f ? 1.0f : 0.0f;
+            }
+
+            applyTransformation(t);
+        }
+
+    }
+
+}
Index: app/src/main/res/values/attr.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/attr.xml b/app/src/main/res/values/attr.xml
new file mode 100644
--- /dev/null	(date 1726419628996)
+++ b/app/src/main/res/values/attr.xml	(date 1726419628996)
@@ -0,0 +1,190 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="SignSeekBar">
+        <attr name="ssb_min" format="float|reference"/> <!--min < max, default: 0.0f-->
+        <attr name="ssb_max" format="float|reference"/> <!--min < max, default: 100.0f-->
+        <attr name="ssb_progress" format="float|reference"/> <!--real time progress value, default: min-->
+        <attr name="ssb_is_float_type" format="boolean"/> <!--support for float type-->
+        <attr name="ssb_track_size" format="dimension|reference"/> <!--height of right-track(on the right of thumb), default: 2dp-->
+        <!--height of left-track(on the left of thumb), default: 2dp higher than right-track's height-->
+        <attr name="ssb_second_track_size" format="dimension|reference"/>
+        <attr name="ssb_thumb_radius" format="dimension|reference"/> <!--radius of thumb, default: 2dp higher than left-track's height-->
+        <!--radius of thumb when be dragging, default: 2 times of left-track's height-->
+        <attr name="ssb_thumb_radius_on_dragging" format="dimension|reference"/>
+        <attr name="ssb_track_color" format="color|reference"/> <!--color of right-track, default: R.color.colorPrimary-->
+        <attr name="ssb_second_track_color" format="color|reference"/> <!--color of left-track, default: R.color.colorAccent-->
+        <attr name="ssb_thumb_color" format="color|reference"/> <!--color of thumb, default: same as left-track's color-->
+        <attr name="ssb_section_count" format="integer|reference"/> <!--shares of whole progress(max - min), default: 10-->
+        <attr name="ssb_show_section_mark" format="boolean"/> <!--show demarcation points or not, default: false-->
+        <attr name="ssb_auto_adjust_section_mark" format="boolean"/> <!--auto scroll to the nearest section_mark or not, default: false-->
+        <attr name="ssb_show_section_text" format="boolean"/> <!--show section-text or not, default: false-->
+        <attr name="ssb_section_text_size" format="dimension|reference"/> <!--text size of section-text, default: 14sp-->
+        <attr name="ssb_section_text_color" format="color|reference"/> <!--text color of section-text, default: same as right-track's color-->
+        <!--text position of section-text relative to track, sides, bottom_sides, below_section_mark, default: sides-->
+        <attr name="ssb_section_text_position">
+            <enum name="sides" value="0"/>
+            <enum name="bottom_sides" value="1"/>
+            <enum name="below_section_mark" value="2"/>
+        </attr>
+        <attr name="ssb_section_text_interval" format="integer"/> <!--the interval of two section-text, default: 1-->
+        <attr name="ssb_show_thumb_text" format="boolean"/> <!--show real time progress-text under thumb or not, default: false-->
+        <attr name="ssb_thumb_text_size" format="dimension|reference"/> <!--text size of progress-text, default: 14sp-->
+        <attr name="ssb_thumb_text_color" format="color|reference"/> <!--text color of progress-text, default: same as left-track's color-->
+        <attr name="ssb_show_progress_in_float" format="boolean"/> <!--show Sign-progress in float or not, default: false-->
+        <attr name="ssb_touch_to_seek" format="boolean"/> <!--touch anywhere on track to quickly seek, default: false-->
+        <attr name="ssb_seek_by_section" format="boolean"/> <!--seek by section, the progress may not be linear, default: false-->
+        <attr name="ssb_sign_color" format="color|reference"/> <!--color of sign, default: same as left-track's color-->
+        <attr name="ssb_sign_border_color" format="color|reference"/> <!--color of sign, border-->
+        <attr name="ssb_sign_show_border" format="boolean"/> <!--color of sign, default: same as left-track's color-->
+        <attr name="ssb_sign_text_size" format="dimension|reference"/> <!--text size of sign-progress, default: 14sp-->
+        <attr name="ssb_sign_border_size" format="dimension|reference"/> <!--border size, default: 1dp-->
+        <attr name="ssb_sign_text_color" format="color|reference"/> <!--text color of sign-progress, default: #ffffffff-->
+        <attr name="ssb_anim_duration" format="integer"/> <!--duration of animation, default: 200ms-->
+        <attr name="ssb_show_sign" format="boolean"/> <!--hide sign, default: false-->
+        <attr name="ssb_text_space" format="dimension|reference"/><!--default:2dp-->
+        <attr name="ssb_sides_labels" format="reference"/><!--default:null-->
+        <attr name="ssb_thumb_bg_alpha" format="float|reference"/> <!--0.0f-1.0f, default: 0.2f-->
+        <attr name="ssb_thumb_ratio" format="float|reference"/> <!--0.0f-1.0f, default: 0.7f-->
+        <attr name="ssb_show_thumb_shadow" format="boolean"/> <!--0.0f-1.0f, default: false-->
+        <attr name="ssb_sign_arrow_autofloat" format="boolean"/> <!--sign arrow auto float, default: true-->
+        <attr name="ssb_sign_height" format="dimension|reference"/> <!--sign height,default:22dp-->
+        <attr name="ssb_sign_width" format="dimension|reference"/> <!--sign_width ,default:72dp-->
+        <attr name="ssb_sign_arrow_height" format="dimension|reference"/> <!--sign arrow height ,default:3dp-->
+        <attr name="ssb_sign_arrow_width" format="dimension|reference"/> <!--sign arrow width, default:5dp-->
+        <attr name="ssb_sign_round" format="dimension|reference"/> <!--sign round, default:3dp-->
+        <attr name="ssb_unusable_color" format="color|reference"/> <!--unusable text color, default:Color.GRAY-->
+    </declare-styleable>
+
+    <declare-styleable name="PinViewTheme">
+        <attr name="pinViewStyle" format="reference" />
+    </declare-styleable>
+
+    <declare-styleable name="PinView">
+        <attr name="itemCount" format="integer" />
+        <attr name="itemWidth" format="dimension" />
+        <attr name="itemHeight" format="dimension" />
+        <attr name="itemRadius" format="dimension" />
+        <attr name="itemSpacing" format="dimension" />
+        <attr name="lineWidth" format="dimension" />
+        <attr name="lineColor" format="reference|color" />
+        <attr name="viewType" format="enum">
+            <enum name="rectangle" value="0" />
+            <enum name="line" value="1" />
+            <enum name="none" value="2" />
+        </attr>
+        <attr name="android:cursorVisible" />
+        <attr name="cursorWidth" format="dimension" />
+        <attr name="cursorColor" format="reference|color" />
+        <attr name="android:itemBackground" />
+        <attr name="hideLineWhenFilled" format="boolean" />
+    </declare-styleable>
+
+    <declare-styleable name="CropImageView">
+        <attr name="cropGuidelines">
+            <enum name="off" value="0"/>
+            <enum name="onTouch" value="1"/>
+            <enum name="on" value="2"/>
+        </attr>
+        <attr name="cropScaleType">
+            <enum name="fitCenter" value="0"/>
+            <enum name="center" value="1"/>
+            <enum name="centerCrop" value="2"/>
+            <enum name="centerInside" value="3"/>
+        </attr>
+        <attr name="cropShape">
+            <enum name="rectangle" value="0"/>
+            <enum name="oval" value="1"/>
+        </attr>
+        <attr name="cropAutoZoomEnabled" format="boolean"/>
+        <attr name="cropMaxZoom" format="integer"/>
+        <attr name="cropMultiTouchEnabled" format="boolean"/>
+        <attr name="cropFixAspectRatio" format="boolean"/>
+        <attr name="cropAspectRatioX" format="integer"/>
+        <attr name="cropAspectRatioY" format="integer"/>
+        <attr name="cropInitialCropWindowPaddingRatio" format="float"/>
+        <attr name="cropBorderLineThickness" format="dimension"/>
+        <attr name="cropBorderLineColor" format="color"/>
+        <attr name="cropBorderCornerThickness" format="dimension"/>
+        <attr name="cropBorderCornerOffset" format="dimension"/>
+        <attr name="cropBorderCornerLength" format="dimension"/>
+        <attr name="cropBorderCornerColor" format="color"/>
+        <attr name="cropGuidelinesThickness" format="dimension"/>
+        <attr name="cropGuidelinesColor" format="color"/>
+        <attr name="cropBackgroundColor" format="color"/>
+        <attr name="cropSnapRadius" format="dimension"/>
+        <attr name="cropTouchRadius" format="dimension"/>
+        <attr name="cropSaveBitmapToInstanceState" format="boolean"/>
+        <attr name="cropShowCropOverlay" format="boolean"/>
+        <attr name="cropShowProgressBar" format="boolean"/>
+        <attr name="cropMinCropWindowWidth" format="dimension"/>
+        <attr name="cropMinCropWindowHeight" format="dimension"/>
+        <attr name="cropMinCropResultWidthPX" format="float"/>
+        <attr name="cropMinCropResultHeightPX" format="float"/>
+        <attr name="cropMaxCropResultWidthPX" format="float"/>
+        <attr name="cropMaxCropResultHeightPX" format="float"/>
+        <attr name="cropFlipHorizontally" format="boolean"/>
+        <attr name="cropFlipVertically" format="boolean"/>
+    </declare-styleable>
+
+    <declare-styleable name="RangeBar">
+        <attr name="mrb_tickStart" format="float" />
+        <attr name="mrb_tickEnd" format="float" />
+        <attr name="mrb_tickInterval" format="float" />
+        <attr name="mrb_tickHeight" format="dimension" />
+        <attr name="mrb_tickDefaultColor" format="color" />
+        <attr name="mrb_tickColors" format="reference" />
+        <attr name="mrb_tickLabelColor" format="color" />
+        <attr name="mrb_tickLabelSelectedColor" format="color" />
+        <attr name="mrb_tickBottomLabels" format="reference" />
+        <attr name="mrb_tickTopLabels" format="reference" />
+        <attr name="mrb_tickDefaultLabel" format="reference|string" />
+        <attr name="mrb_tickLabelSize" format="dimension" />
+        <attr name="mrb_barWeight" format="dimension" />
+        <attr name="mrb_rangeBarColor" format="reference|color" />
+        <attr name="mrb_minThumbDistance" format="float"/>
+        <attr name="mrb_thumbSize" format="dimension" />
+        <attr name="mrb_thumbBoundaryColor" format="reference|color" />
+        <attr name="mrb_thumbBoundarySize" format="dimension" />
+        <attr name="mrb_thumbColor" format="reference|color" />
+        <attr name="mrb_leftThumbColor" format="reference|color" />
+        <attr name="mrb_rightThumbColor" format="reference|color" />
+        <attr name="mrb_pinTextColor" format="reference|color" />
+        <attr name="mrb_pinColor" format="reference|color" />
+        <attr name="mrb_pinPadding" format="dimension" />
+        <attr name="mrb_pinMinFont" format="dimension" />
+        <attr name="mrb_pinMaxFont" format="dimension" />
+        <attr name="mrb_rangeBarPaddingBottom" format="dimension" />
+        <attr name="mrb_rangeBar" format="boolean" />
+        <attr name="mrb_temporaryPins" format="boolean" />
+        <attr name="mrb_rangeBar_rounded" format="boolean" />
+        <attr name="mrb_connectingLineWeight" format="dimension" />
+        <attr name="mrb_connectingLineColor" format="reference|color" />
+        <attr name="mrb_pinRadius" format="dimension" />
+        <attr name="mrb_connectingLineColors" format="reference" />
+        <attr name="mrb_onlyOnDrag" format="boolean" />
+    </declare-styleable>
+
+    <declare-styleable name="expandableLayout">
+        <attr name="ael_duration" format="integer" />
+        <attr name="ael_expanded" format="boolean" />
+        <attr name="ael_defaultChildIndex" format="integer" />
+        <attr name="ael_defaultPosition" format="dimension" />
+        <attr name="ael_orientation" format="enum">
+            <enum name="horizontal" value="0" />
+            <enum name="vertical" value="1" />
+        </attr>
+        <attr name="ael_interpolator" format="enum">
+            <enum name="accelerateDecelerate" value="0" />
+            <enum name="accelerate" value="1" />
+            <enum name="anticipate" value="2" />
+            <enum name="anticipateOvershoot" value="3" />
+            <enum name="bounce" value="4" />
+            <enum name="decelerate" value="5" />
+            <enum name="fastOutLinearIn" value="6" />
+            <enum name="fastOutSlowIn" value="7" />
+            <enum name="linear" value="8" />
+            <enum name="linearOutSlowIn" value="9" />
+            <enum name="overshoot" value="10" />
+        </attr>
+    </declare-styleable>
+</resources>
\ No newline at end of file
Index: app/src/main/res/values-ar/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values-ar/strings.xml b/app/src/main/res/values-ar/strings.xml
--- a/app/src/main/res/values-ar/strings.xml	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/app/src/main/res/values-ar/strings.xml	(date 1726418597202)
@@ -1,5 +1,17 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
+    <string name="crop_image_activity_title"></string>
+    <string name="crop_image_menu_rotate_left">أدر عكس اتجاه عقارب الساعة</string>
+    <string name="crop_image_menu_rotate_right">أدر</string>
+    <string name="crop_image_menu_crop">قُصّ</string>
+    <string name="crop_image_menu_flip">اقلب</string>
+    <string name="crop_image_menu_flip_horizontally">اقلب أفقيًا</string>
+    <string name="crop_image_menu_flip_vertically">اقلب رأسيًا</string>
+
+    <string name="pick_image_intent_chooser_title">اختر مصدرًا</string>
+
+    <string name="crop_image_activity_no_permissions">إلغاء؛ الأذونات المطلوبة غير ممنوحة</string>
+
     <string name="chat">دردشة</string>
     <string name="send_message_here">أرسل رسالة هنا...</string>
 
Index: app/src/main/java/com/theartofdev/edmodo/cropper/BitmapUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapUtils.java b/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapUtils.java
new file mode 100644
--- /dev/null	(date 1726418211348)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapUtils.java	(date 1726418211348)
@@ -0,0 +1,877 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapRegionDecoder;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.net.Uri;
+import android.util.Log;
+import android.util.Pair;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.ref.WeakReference;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+
+import androidx.exifinterface.media.ExifInterface;
+
+/** Utility class that deals with operations with an ImageView. */
+final class BitmapUtils {
+
+  static final Rect EMPTY_RECT = new Rect();
+
+  static final RectF EMPTY_RECT_F = new RectF();
+
+  /** Reusable rectangle for general internal usage */
+  static final RectF RECT = new RectF();
+
+  /** Reusable point for general internal usage */
+  static final float[] POINTS = new float[6];
+
+  /** Reusable point for general internal usage */
+  static final float[] POINTS2 = new float[6];
+
+  /** Used to know the max texture size allowed to be rendered */
+  private static int mMaxTextureSize;
+
+  /** used to save bitmaps during state save and restore so not to reload them. */
+  static Pair<String, WeakReference<Bitmap>> mStateBitmap;
+
+  /**
+   * Rotate the given image by reading the Exif value of the image (uri).<br>
+   * If no rotation is required the image will not be rotated.<br>
+   * New bitmap is created and the old one is recycled.
+   */
+  static RotateBitmapResult rotateBitmapByExif(Bitmap bitmap, Context context, Uri uri) {
+    ExifInterface ei = null;
+    try {
+      InputStream is = context.getContentResolver().openInputStream(uri);
+      if (is != null) {
+        ei = new ExifInterface(is);
+        is.close();
+      }
+    } catch (Exception ignored) {
+    }
+    return ei != null ? rotateBitmapByExif(bitmap, ei) : new RotateBitmapResult(bitmap, 0);
+  }
+
+  /**
+   * Rotate the given image by given Exif value.<br>
+   * If no rotation is required the image will not be rotated.<br>
+   * New bitmap is created and the old one is recycled.
+   */
+  static RotateBitmapResult rotateBitmapByExif(Bitmap bitmap, ExifInterface exif) {
+    int degrees;
+    int orientation =
+        exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
+    switch (orientation) {
+      case ExifInterface.ORIENTATION_ROTATE_90:
+        degrees = 90;
+        break;
+      case ExifInterface.ORIENTATION_ROTATE_180:
+        degrees = 180;
+        break;
+      case ExifInterface.ORIENTATION_ROTATE_270:
+        degrees = 270;
+        break;
+      default:
+        degrees = 0;
+        break;
+    }
+    return new RotateBitmapResult(bitmap, degrees);
+  }
+
+  /** Decode bitmap from stream using sampling to get bitmap with the requested limit. */
+  static BitmapSampled decodeSampledBitmap(Context context, Uri uri, int reqWidth, int reqHeight) {
+
+    try {
+      ContentResolver resolver = context.getContentResolver();
+
+      // First decode with inJustDecodeBounds=true to check dimensions
+      BitmapFactory.Options options = decodeImageForOption(resolver, uri);
+
+      if(options.outWidth  == -1 && options.outHeight == -1)
+        throw new RuntimeException("File is not a picture");
+
+      // Calculate inSampleSize
+      options.inSampleSize =
+          Math.max(
+              calculateInSampleSizeByReqestedSize(
+                  options.outWidth, options.outHeight, reqWidth, reqHeight),
+              calculateInSampleSizeByMaxTextureSize(options.outWidth, options.outHeight));
+
+      // Decode bitmap with inSampleSize set
+      Bitmap bitmap = decodeImage(resolver, uri, options);
+
+      return new BitmapSampled(bitmap, options.inSampleSize);
+
+    } catch (Exception e) {
+      throw new RuntimeException(
+          "Failed to load sampled bitmap: " + uri + "\r\n" + e.getMessage(), e);
+    }
+  }
+
+  /**
+   * Crop image bitmap from given bitmap using the given points in the original bitmap and the given
+   * rotation.<br>
+   * if the rotation is not 0,90,180 or 270 degrees then we must first crop a larger area of the
+   * image that contains the requires rectangle, rotate and then crop again a sub rectangle.<br>
+   * If crop fails due to OOM we scale the cropping image by 0.5 every time it fails until it is
+   * small enough.
+   */
+  static BitmapSampled cropBitmapObjectHandleOOM(
+      Bitmap bitmap,
+      float[] points,
+      int degreesRotated,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      boolean flipHorizontally,
+      boolean flipVertically) {
+    int scale = 1;
+    while (true) {
+      try {
+        Bitmap cropBitmap =
+            cropBitmapObjectWithScale(
+                bitmap,
+                points,
+                degreesRotated,
+                fixAspectRatio,
+                aspectRatioX,
+                aspectRatioY,
+                1 / (float) scale,
+                flipHorizontally,
+                flipVertically);
+        return new BitmapSampled(cropBitmap, scale);
+      } catch (OutOfMemoryError e) {
+        scale *= 2;
+        if (scale > 8) {
+          throw e;
+        }
+      }
+    }
+  }
+
+  /**
+   * Crop image bitmap from given bitmap using the given points in the original bitmap and the given
+   * rotation.<br>
+   * if the rotation is not 0,90,180 or 270 degrees then we must first crop a larger area of the
+   * image that contains the requires rectangle, rotate and then crop again a sub rectangle.
+   *
+   * @param scale how much to scale the cropped image part, use 0.5 to lower the image by half (OOM
+   *     handling)
+   */
+  private static Bitmap cropBitmapObjectWithScale(
+      Bitmap bitmap,
+      float[] points,
+      int degreesRotated,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      float scale,
+      boolean flipHorizontally,
+      boolean flipVertically) {
+
+    // get the rectangle in original image that contains the required cropped area (larger for non
+    // rectangular crop)
+    Rect rect =
+        getRectFromPoints(
+            points,
+            bitmap.getWidth(),
+            bitmap.getHeight(),
+            fixAspectRatio,
+            aspectRatioX,
+            aspectRatioY);
+
+    // crop and rotate the cropped image in one operation
+    Matrix matrix = new Matrix();
+    matrix.setRotate(degreesRotated, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
+    matrix.postScale(flipHorizontally ? -scale : scale, flipVertically ? -scale : scale);
+    Bitmap result =
+        Bitmap.createBitmap(bitmap, rect.left, rect.top, rect.width(), rect.height(), matrix, true);
+
+    if (result == bitmap) {
+      // corner case when all bitmap is selected, no worth optimizing for it
+      result = bitmap.copy(bitmap.getConfig(), false);
+    }
+
+    // rotating by 0, 90, 180 or 270 degrees doesn't require extra cropping
+    if (degreesRotated % 90 != 0) {
+
+      // extra crop because non rectangular crop cannot be done directly on the image without
+      // rotating first
+      result =
+          cropForRotatedImage(
+              result, points, rect, degreesRotated, fixAspectRatio, aspectRatioX, aspectRatioY);
+    }
+
+    return result;
+  }
+
+  /**
+   * Crop image bitmap from URI by decoding it with specific width and height to down-sample if
+   * required.<br>
+   * Additionally if OOM is thrown try to increase the sampling (2,4,8).
+   */
+  static BitmapSampled cropBitmap(
+      Context context,
+      Uri loadedImageUri,
+      float[] points,
+      int degreesRotated,
+      int orgWidth,
+      int orgHeight,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      int reqWidth,
+      int reqHeight,
+      boolean flipHorizontally,
+      boolean flipVertically) {
+    int sampleMulti = 1;
+    while (true) {
+      try {
+        // if successful, just return the resulting bitmap
+        return cropBitmap(
+            context,
+            loadedImageUri,
+            points,
+            degreesRotated,
+            orgWidth,
+            orgHeight,
+            fixAspectRatio,
+            aspectRatioX,
+            aspectRatioY,
+            reqWidth,
+            reqHeight,
+            flipHorizontally,
+            flipVertically,
+            sampleMulti);
+      } catch (OutOfMemoryError e) {
+        // if OOM try to increase the sampling to lower the memory usage
+        sampleMulti *= 2;
+        if (sampleMulti > 16) {
+          throw new RuntimeException(
+              "Failed to handle OOM by sampling ("
+                  + sampleMulti
+                  + "): "
+                  + loadedImageUri
+                  + "\r\n"
+                  + e.getMessage(),
+              e);
+        }
+      }
+    }
+  }
+
+  /** Get left value of the bounding rectangle of the given points. */
+  static float getRectLeft(float[] points) {
+    return Math.min(Math.min(Math.min(points[0], points[2]), points[4]), points[6]);
+  }
+
+  /** Get top value of the bounding rectangle of the given points. */
+  static float getRectTop(float[] points) {
+    return Math.min(Math.min(Math.min(points[1], points[3]), points[5]), points[7]);
+  }
+
+  /** Get right value of the bounding rectangle of the given points. */
+  static float getRectRight(float[] points) {
+    return Math.max(Math.max(Math.max(points[0], points[2]), points[4]), points[6]);
+  }
+
+  /** Get bottom value of the bounding rectangle of the given points. */
+  static float getRectBottom(float[] points) {
+    return Math.max(Math.max(Math.max(points[1], points[3]), points[5]), points[7]);
+  }
+
+  /** Get width of the bounding rectangle of the given points. */
+  static float getRectWidth(float[] points) {
+    return getRectRight(points) - getRectLeft(points);
+  }
+
+  /** Get height of the bounding rectangle of the given points. */
+  static float getRectHeight(float[] points) {
+    return getRectBottom(points) - getRectTop(points);
+  }
+
+  /** Get horizontal center value of the bounding rectangle of the given points. */
+  static float getRectCenterX(float[] points) {
+    return (getRectRight(points) + getRectLeft(points)) / 2f;
+  }
+
+  /** Get vertical center value of the bounding rectangle of the given points. */
+  static float getRectCenterY(float[] points) {
+    return (getRectBottom(points) + getRectTop(points)) / 2f;
+  }
+
+  /**
+   * Get a rectangle for the given 4 points (x0,y0,x1,y1,x2,y2,x3,y3) by finding the min/max 2
+   * points that contains the given 4 points and is a straight rectangle.
+   */
+  static Rect getRectFromPoints(
+      float[] points,
+      int imageWidth,
+      int imageHeight,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY) {
+    int left = Math.round(Math.max(0, getRectLeft(points)));
+    int top = Math.round(Math.max(0, getRectTop(points)));
+    int right = Math.round(Math.min(imageWidth, getRectRight(points)));
+    int bottom = Math.round(Math.min(imageHeight, getRectBottom(points)));
+
+    Rect rect = new Rect(left, top, right, bottom);
+    if (fixAspectRatio) {
+      fixRectForAspectRatio(rect, aspectRatioX, aspectRatioY);
+    }
+
+    return rect;
+  }
+
+  /**
+   * Fix the given rectangle if it doesn't confirm to aspect ration rule.<br>
+   * Make sure that width and height are equal if 1:1 fixed aspect ratio is requested.
+   */
+  private static void fixRectForAspectRatio(Rect rect, int aspectRatioX, int aspectRatioY) {
+    if (aspectRatioX == aspectRatioY && rect.width() != rect.height()) {
+      if (rect.height() > rect.width()) {
+        rect.bottom -= rect.height() - rect.width();
+      } else {
+        rect.right -= rect.width() - rect.height();
+      }
+    }
+  }
+
+  /**
+   * Write given bitmap to a temp file. If file already exists no-op as we already saved the file in
+   * this session. Uses JPEG 95% compression.
+   *
+   * @param uri the uri to write the bitmap to, if null
+   * @return the uri where the image was saved in, either the given uri or new pointing to temp
+   *     file.
+   */
+  static Uri writeTempStateStoreBitmap(Context context, Bitmap bitmap, Uri uri) {
+    try {
+      boolean needSave = true;
+      if (uri == null) {
+        uri =
+            Uri.fromFile(
+                File.createTempFile("aic_state_store_temp", ".jpg", context.getCacheDir()));
+      } else if (new File(uri.getPath()).exists()) {
+        needSave = false;
+      }
+      if (needSave) {
+        writeBitmapToUri(context, bitmap, uri, Bitmap.CompressFormat.JPEG, 95);
+      }
+      return uri;
+    } catch (Exception e) {
+      Log.w("AIC", "Failed to write bitmap to temp file for image-cropper save instance state", e);
+      return null;
+    }
+  }
+
+  /** Write the given bitmap to the given uri using the given compression. */
+  static void writeBitmapToUri(
+      Context context,
+      Bitmap bitmap,
+      Uri uri,
+      Bitmap.CompressFormat compressFormat,
+      int compressQuality)
+      throws FileNotFoundException {
+    OutputStream outputStream = null;
+    try {
+      outputStream = context.getContentResolver().openOutputStream(uri);
+      bitmap.compress(compressFormat, compressQuality, outputStream);
+    } finally {
+      closeSafe(outputStream);
+    }
+  }
+
+  /** Resize the given bitmap to the given width/height by the given option.<br> */
+  static Bitmap resizeBitmap(
+      Bitmap bitmap, int reqWidth, int reqHeight, CropImageView.RequestSizeOptions options) {
+    try {
+      if (reqWidth > 0
+          && reqHeight > 0
+          && (options == CropImageView.RequestSizeOptions.RESIZE_FIT
+              || options == CropImageView.RequestSizeOptions.RESIZE_INSIDE
+              || options == CropImageView.RequestSizeOptions.RESIZE_EXACT)) {
+
+        Bitmap resized = null;
+        if (options == CropImageView.RequestSizeOptions.RESIZE_EXACT) {
+          resized = Bitmap.createScaledBitmap(bitmap, reqWidth, reqHeight, false);
+        } else {
+          int width = bitmap.getWidth();
+          int height = bitmap.getHeight();
+          float scale = Math.max(width / (float) reqWidth, height / (float) reqHeight);
+          if (scale > 1 || options == CropImageView.RequestSizeOptions.RESIZE_FIT) {
+            resized =
+                Bitmap.createScaledBitmap(
+                    bitmap, (int) (width / scale), (int) (height / scale), false);
+          }
+        }
+        if (resized != null) {
+          if (resized != bitmap) {
+            bitmap.recycle();
+          }
+          return resized;
+        }
+      }
+    } catch (Exception e) {
+      Log.w("AIC", "Failed to resize cropped image, return bitmap before resize", e);
+    }
+    return bitmap;
+  }
+
+  // region: Private methods
+
+  /**
+   * Crop image bitmap from URI by decoding it with specific width and height to down-sample if
+   * required.
+   *
+   * @param orgWidth used to get rectangle from points (handle edge cases to limit rectangle)
+   * @param orgHeight used to get rectangle from points (handle edge cases to limit rectangle)
+   * @param sampleMulti used to increase the sampling of the image to handle memory issues.
+   */
+  private static BitmapSampled cropBitmap(
+      Context context,
+      Uri loadedImageUri,
+      float[] points,
+      int degreesRotated,
+      int orgWidth,
+      int orgHeight,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      int reqWidth,
+      int reqHeight,
+      boolean flipHorizontally,
+      boolean flipVertically,
+      int sampleMulti) {
+
+    // get the rectangle in original image that contains the required cropped area (larger for non
+    // rectangular crop)
+    Rect rect =
+        getRectFromPoints(points, orgWidth, orgHeight, fixAspectRatio, aspectRatioX, aspectRatioY);
+
+    int width = reqWidth > 0 ? reqWidth : rect.width();
+    int height = reqHeight > 0 ? reqHeight : rect.height();
+
+    Bitmap result = null;
+    int sampleSize = 1;
+    try {
+      // decode only the required image from URI, optionally sub-sampling if reqWidth/reqHeight is
+      // given.
+      BitmapSampled bitmapSampled =
+          decodeSampledBitmapRegion(context, loadedImageUri, rect, width, height, sampleMulti);
+      result = bitmapSampled.bitmap;
+      sampleSize = bitmapSampled.sampleSize;
+    } catch (Exception ignored) {
+    }
+
+    if (result != null) {
+      try {
+        // rotate the decoded region by the required amount
+        result = rotateAndFlipBitmapInt(result, degreesRotated, flipHorizontally, flipVertically);
+
+        // rotating by 0, 90, 180 or 270 degrees doesn't require extra cropping
+        if (degreesRotated % 90 != 0) {
+
+          // extra crop because non rectangular crop cannot be done directly on the image without
+          // rotating first
+          result =
+              cropForRotatedImage(
+                  result, points, rect, degreesRotated, fixAspectRatio, aspectRatioX, aspectRatioY);
+        }
+      } catch (OutOfMemoryError e) {
+        if (result != null) {
+          result.recycle();
+        }
+        throw e;
+      }
+      return new BitmapSampled(result, sampleSize);
+    } else {
+      // failed to decode region, may be skia issue, try full decode and then crop
+      return cropBitmap(
+          context,
+          loadedImageUri,
+          points,
+          degreesRotated,
+          fixAspectRatio,
+          aspectRatioX,
+          aspectRatioY,
+          sampleMulti,
+          rect,
+          width,
+          height,
+          flipHorizontally,
+          flipVertically);
+    }
+  }
+
+  /**
+   * Crop bitmap by fully loading the original and then cropping it, fallback in case cropping
+   * region failed.
+   */
+  private static BitmapSampled cropBitmap(
+      Context context,
+      Uri loadedImageUri,
+      float[] points,
+      int degreesRotated,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      int sampleMulti,
+      Rect rect,
+      int width,
+      int height,
+      boolean flipHorizontally,
+      boolean flipVertically) {
+    Bitmap result = null;
+    int sampleSize;
+    try {
+      BitmapFactory.Options options = new BitmapFactory.Options();
+      options.inSampleSize =
+          sampleSize =
+              sampleMulti
+                  * calculateInSampleSizeByReqestedSize(rect.width(), rect.height(), width, height);
+
+      Bitmap fullBitmap = decodeImage(context.getContentResolver(), loadedImageUri, options);
+      if (fullBitmap != null) {
+        try {
+          // adjust crop points by the sampling because the image is smaller
+          float[] points2 = new float[points.length];
+          System.arraycopy(points, 0, points2, 0, points.length);
+          for (int i = 0; i < points2.length; i++) {
+            points2[i] = points2[i] / options.inSampleSize;
+          }
+
+          result =
+              cropBitmapObjectWithScale(
+                  fullBitmap,
+                  points2,
+                  degreesRotated,
+                  fixAspectRatio,
+                  aspectRatioX,
+                  aspectRatioY,
+                  1,
+                  flipHorizontally,
+                  flipVertically);
+        } finally {
+          if (result != fullBitmap) {
+            fullBitmap.recycle();
+          }
+        }
+      }
+    } catch (OutOfMemoryError e) {
+      if (result != null) {
+        result.recycle();
+      }
+      throw e;
+    } catch (Exception e) {
+      throw new RuntimeException(
+          "Failed to load sampled bitmap: " + loadedImageUri + "\r\n" + e.getMessage(), e);
+    }
+    return new BitmapSampled(result, sampleSize);
+  }
+
+  /** Decode image from uri using "inJustDecodeBounds" to get the image dimensions. */
+  private static BitmapFactory.Options decodeImageForOption(ContentResolver resolver, Uri uri)
+      throws FileNotFoundException {
+    InputStream stream = null;
+    try {
+      stream = resolver.openInputStream(uri);
+      BitmapFactory.Options options = new BitmapFactory.Options();
+      options.inJustDecodeBounds = true;
+      BitmapFactory.decodeStream(stream, EMPTY_RECT, options);
+      options.inJustDecodeBounds = false;
+      return options;
+    } finally {
+      closeSafe(stream);
+    }
+  }
+
+  /**
+   * Decode image from uri using given "inSampleSize", but if failed due to out-of-memory then raise
+   * the inSampleSize until success.
+   */
+  private static Bitmap decodeImage(
+      ContentResolver resolver, Uri uri, BitmapFactory.Options options)
+      throws FileNotFoundException {
+    do {
+      InputStream stream = null;
+      try {
+        stream = resolver.openInputStream(uri);
+        return BitmapFactory.decodeStream(stream, EMPTY_RECT, options);
+      } catch (OutOfMemoryError e) {
+        options.inSampleSize *= 2;
+      } finally {
+        closeSafe(stream);
+      }
+    } while (options.inSampleSize <= 512);
+    throw new RuntimeException("Failed to decode image: " + uri);
+  }
+
+  /**
+   * Decode specific rectangle bitmap from stream using sampling to get bitmap with the requested
+   * limit.
+   *
+   * @param sampleMulti used to increase the sampling of the image to handle memory issues.
+   */
+  private static BitmapSampled decodeSampledBitmapRegion(
+      Context context, Uri uri, Rect rect, int reqWidth, int reqHeight, int sampleMulti) {
+    InputStream stream = null;
+    BitmapRegionDecoder decoder = null;
+    try {
+      BitmapFactory.Options options = new BitmapFactory.Options();
+      options.inSampleSize =
+          sampleMulti
+              * calculateInSampleSizeByReqestedSize(
+                  rect.width(), rect.height(), reqWidth, reqHeight);
+
+      stream = context.getContentResolver().openInputStream(uri);
+      decoder = BitmapRegionDecoder.newInstance(stream, false);
+      do {
+        try {
+          return new BitmapSampled(decoder.decodeRegion(rect, options), options.inSampleSize);
+        } catch (OutOfMemoryError e) {
+          options.inSampleSize *= 2;
+        }
+      } while (options.inSampleSize <= 512);
+    } catch (Exception e) {
+      throw new RuntimeException(
+          "Failed to load sampled bitmap: " + uri + "\r\n" + e.getMessage(), e);
+    } finally {
+      closeSafe(stream);
+      if (decoder != null) {
+        decoder.recycle();
+      }
+    }
+    return new BitmapSampled(null, 1);
+  }
+
+  /**
+   * Special crop of bitmap rotated by not stright angle, in this case the original crop bitmap
+   * contains parts beyond the required crop area, this method crops the already cropped and rotated
+   * bitmap to the final rectangle.<br>
+   * Note: rotating by 0, 90, 180 or 270 degrees doesn't require extra cropping.
+   */
+  private static Bitmap cropForRotatedImage(
+      Bitmap bitmap,
+      float[] points,
+      Rect rect,
+      int degreesRotated,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY) {
+    if (degreesRotated % 90 != 0) {
+
+      int adjLeft = 0, adjTop = 0, width = 0, height = 0;
+      double rads = Math.toRadians(degreesRotated);
+      int compareTo =
+          degreesRotated < 90 || (degreesRotated > 180 && degreesRotated < 270)
+              ? rect.left
+              : rect.right;
+      for (int i = 0; i < points.length; i += 2) {
+        if (points[i] >= compareTo - 1 && points[i] <= compareTo + 1) {
+          adjLeft = (int) Math.abs(Math.sin(rads) * (rect.bottom - points[i + 1]));
+          adjTop = (int) Math.abs(Math.cos(rads) * (points[i + 1] - rect.top));
+          width = (int) Math.abs((points[i + 1] - rect.top) / Math.sin(rads));
+          height = (int) Math.abs((rect.bottom - points[i + 1]) / Math.cos(rads));
+          break;
+        }
+      }
+
+      rect.set(adjLeft, adjTop, adjLeft + width, adjTop + height);
+      if (fixAspectRatio) {
+        fixRectForAspectRatio(rect, aspectRatioX, aspectRatioY);
+      }
+
+      Bitmap bitmapTmp = bitmap;
+      bitmap = Bitmap.createBitmap(bitmap, rect.left, rect.top, rect.width(), rect.height());
+      if (bitmapTmp != bitmap) {
+        bitmapTmp.recycle();
+      }
+    }
+    return bitmap;
+  }
+
+  /**
+   * Calculate the largest inSampleSize value that is a power of 2 and keeps both height and width
+   * larger than the requested height and width.
+   */
+  private static int calculateInSampleSizeByReqestedSize(
+      int width, int height, int reqWidth, int reqHeight) {
+    int inSampleSize = 1;
+    if (height > reqHeight || width > reqWidth) {
+      while ((height / 2 / inSampleSize) > reqHeight && (width / 2 / inSampleSize) > reqWidth) {
+        inSampleSize *= 2;
+      }
+    }
+    return inSampleSize;
+  }
+
+  /**
+   * Calculate the largest inSampleSize value that is a power of 2 and keeps both height and width
+   * smaller than max texture size allowed for the device.
+   */
+  private static int calculateInSampleSizeByMaxTextureSize(int width, int height) {
+    int inSampleSize = 1;
+    if (mMaxTextureSize == 0) {
+      mMaxTextureSize = getMaxTextureSize();
+    }
+    if (mMaxTextureSize > 0) {
+      while ((height / inSampleSize) > mMaxTextureSize
+          || (width / inSampleSize) > mMaxTextureSize) {
+        inSampleSize *= 2;
+      }
+    }
+    return inSampleSize;
+  }
+
+  /**
+   * Rotate the given bitmap by the given degrees.<br>
+   * New bitmap is created and the old one is recycled.
+   */
+  private static Bitmap rotateAndFlipBitmapInt(
+      Bitmap bitmap, int degrees, boolean flipHorizontally, boolean flipVertically) {
+    if (degrees > 0 || flipHorizontally || flipVertically) {
+      Matrix matrix = new Matrix();
+      matrix.setRotate(degrees);
+      matrix.postScale(flipHorizontally ? -1 : 1, flipVertically ? -1 : 1);
+      Bitmap newBitmap =
+          Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, false);
+      if (newBitmap != bitmap) {
+        bitmap.recycle();
+      }
+      return newBitmap;
+    } else {
+      return bitmap;
+    }
+  }
+
+  /**
+   * Get the max size of bitmap allowed to be rendered on the device.<br>
+   * http://stackoverflow.com/questions/7428996/hw-accelerated-activity-how-to-get-opengl-texture-size-limit.
+   */
+  private static int getMaxTextureSize() {
+    // Safe minimum default size
+    final int IMAGE_MAX_BITMAP_DIMENSION = 2048;
+
+    try {
+      // Get EGL Display
+      EGL10 egl = (EGL10) EGLContext.getEGL();
+      EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
+
+      // Initialise
+      int[] version = new int[2];
+      egl.eglInitialize(display, version);
+
+      // Query total number of configurations
+      int[] totalConfigurations = new int[1];
+      egl.eglGetConfigs(display, null, 0, totalConfigurations);
+
+      // Query actual list configurations
+      EGLConfig[] configurationsList = new EGLConfig[totalConfigurations[0]];
+      egl.eglGetConfigs(display, configurationsList, totalConfigurations[0], totalConfigurations);
+
+      int[] textureSize = new int[1];
+      int maximumTextureSize = 0;
+
+      // Iterate through all the configurations to located the maximum texture size
+      for (int i = 0; i < totalConfigurations[0]; i++) {
+        // Only need to check for width since opengl textures are always squared
+        egl.eglGetConfigAttrib(
+            display, configurationsList[i], EGL10.EGL_MAX_PBUFFER_WIDTH, textureSize);
+
+        // Keep track of the maximum texture size
+        if (maximumTextureSize < textureSize[0]) {
+          maximumTextureSize = textureSize[0];
+        }
+      }
+
+      // Release
+      egl.eglTerminate(display);
+
+      // Return largest texture size found, or default
+      return Math.max(maximumTextureSize, IMAGE_MAX_BITMAP_DIMENSION);
+    } catch (Exception e) {
+      return IMAGE_MAX_BITMAP_DIMENSION;
+    }
+  }
+
+  /**
+   * Close the given closeable object (Stream) in a safe way: check if it is null and catch-log
+   * exception thrown.
+   *
+   * @param closeable the closable object to close
+   */
+  private static void closeSafe(Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (IOException ignored) {
+      }
+    }
+  }
+  // endregion
+
+  // region: Inner class: BitmapSampled
+
+  /** Holds bitmap instance and the sample size that the bitmap was loaded/cropped with. */
+  static final class BitmapSampled {
+
+    /** The bitmap instance */
+    public final Bitmap bitmap;
+
+    /** The sample size used to lower the size of the bitmap (1,2,4,8,...) */
+    final int sampleSize;
+
+    BitmapSampled(Bitmap bitmap, int sampleSize) {
+      this.bitmap = bitmap;
+      this.sampleSize = sampleSize;
+    }
+  }
+  // endregion
+
+  // region: Inner class: RotateBitmapResult
+
+  /** The result of {@link #rotateBitmapByExif(Bitmap, ExifInterface)}. */
+  static final class RotateBitmapResult {
+
+    /** The loaded bitmap */
+    public final Bitmap bitmap;
+
+    /** The degrees the image was rotated */
+    final int degrees;
+
+    RotateBitmapResult(Bitmap bitmap, int degrees) {
+      this.bitmap = bitmap;
+      this.degrees = degrees;
+    }
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropImage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropImage.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImage.java
new file mode 100644
--- /dev/null	(date 1726418597221)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImage.java	(date 1726418597221)
@@ -0,0 +1,1019 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.provider.MediaStore;
+
+import com.qboxus.binder.R;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.fragment.app.Fragment;
+
+/**
+ * Helper to simplify crop image work like starting pick-image acitvity and handling camera/gallery
+ * intents.<br>
+ * The goal of the helper is to simplify the starting and most-common usage of image cropping and
+ * not all porpose all possible scenario one-to-rule-them-all code base. So feel free to use it as
+ * is and as a wiki to make your own.<br>
+ * Added value you get out-of-the-box is some edge case handling that you may miss otherwise, like
+ * the stupid-ass Android camera result URI that may differ from version to version and from device
+ * to device.
+ */
+@SuppressWarnings("WeakerAccess, unused")
+public final class CropImage {
+
+  // region: Fields and Consts
+
+  /** The key used to pass crop image source URI to {@link CropImageActivity}. */
+  public static final String CROP_IMAGE_EXTRA_SOURCE = "CROP_IMAGE_EXTRA_SOURCE";
+
+  /** The key used to pass crop image options to {@link CropImageActivity}. */
+  public static final String CROP_IMAGE_EXTRA_OPTIONS = "CROP_IMAGE_EXTRA_OPTIONS";
+
+  /** The key used to pass crop image bundle data to {@link CropImageActivity}. */
+  public static final String CROP_IMAGE_EXTRA_BUNDLE = "CROP_IMAGE_EXTRA_BUNDLE";
+
+  /** The key used to pass crop image result data back from {@link CropImageActivity}. */
+  public static final String CROP_IMAGE_EXTRA_RESULT = "CROP_IMAGE_EXTRA_RESULT";
+
+  /**
+   * The request code used to start pick image activity to be used on result to identify the this
+   * specific request.
+   */
+  public static final int PICK_IMAGE_CHOOSER_REQUEST_CODE = 200;
+
+  /** The request code used to request permission to pick image from external storage. */
+  public static final int PICK_IMAGE_PERMISSIONS_REQUEST_CODE = 201;
+
+  /** The request code used to request permission to capture image from camera. */
+  public static final int CAMERA_CAPTURE_PERMISSIONS_REQUEST_CODE = 2011;
+
+  /**
+   * The request code used to start {@link CropImageActivity} to be used on result to identify the
+   * this specific request.
+   */
+  public static final int CROP_IMAGE_ACTIVITY_REQUEST_CODE = 203;
+
+  /** The result code used to return error from {@link CropImageActivity}. */
+  public static final int CROP_IMAGE_ACTIVITY_RESULT_ERROR_CODE = 204;
+  // endregion
+
+  private CropImage() {}
+
+  /**
+   * Create a new bitmap that has all pixels beyond the oval shape transparent. Old bitmap is
+   * recycled.
+   */
+  public static Bitmap toOvalBitmap(@NonNull Bitmap bitmap) {
+    int width = bitmap.getWidth();
+    int height = bitmap.getHeight();
+    Bitmap output = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+
+    Canvas canvas = new Canvas(output);
+
+    int color = 0xff424242;
+    Paint paint = new Paint();
+
+    paint.setAntiAlias(true);
+    canvas.drawARGB(0, 0, 0, 0);
+    paint.setColor(color);
+
+    RectF rect = new RectF(0, 0, width, height);
+    canvas.drawOval(rect, paint);
+    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
+    canvas.drawBitmap(bitmap, 0, 0, paint);
+
+    bitmap.recycle();
+
+    return output;
+  }
+
+  /**
+   * Start an activity to get image for cropping using chooser intent that will have all the
+   * available applications for the device like camera (MyCamera), galery (Photos), store apps
+   * (Dropbox), etc.<br>
+   * Use "pick_image_intent_chooser_title" string resource to override pick chooser title.
+   *
+   * @param activity the activity to be used to start activity from
+   */
+  public static void startPickImageActivity(@NonNull Activity activity) {
+    activity.startActivityForResult(
+        getPickImageChooserIntent(activity), PICK_IMAGE_CHOOSER_REQUEST_CODE);
+  }
+
+  /**
+   * Same as {@link #startPickImageActivity(Activity) startPickImageActivity} method but instead of
+   * being called and returning to an Activity, this method can be called and return to a Fragment.
+   *
+   * @param context The Fragments context. Use getContext()
+   * @param fragment The calling Fragment to start and return the image to
+   */
+  public static void startPickImageActivity(@NonNull Context context, @NonNull Fragment fragment) {
+    fragment.startActivityForResult(
+        getPickImageChooserIntent(context), PICK_IMAGE_CHOOSER_REQUEST_CODE);
+  }
+
+  /**
+   * Create a chooser intent to select the source to get image from.<br>
+   * The source can be camera's (ACTION_IMAGE_CAPTURE) or gallery's (ACTION_GET_CONTENT).<br>
+   * All possible sources are added to the intent chooser.<br>
+   * Use "pick_image_intent_chooser_title" string resource to override chooser title.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   */
+  public static Intent getPickImageChooserIntent(@NonNull Context context) {
+    return getPickImageChooserIntent(
+        context, context.getString(R.string.pick_image_intent_chooser_title), false, true);
+  }
+
+  /**
+   * Create a chooser intent to select the source to get image from.<br>
+   * The source can be camera's (ACTION_IMAGE_CAPTURE) or gallery's (ACTION_GET_CONTENT).<br>
+   * All possible sources are added to the intent chooser.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   * @param title the title to use for the chooser UI
+   * @param includeDocuments if to include KitKat documents activity containing all sources
+   * @param includeCamera if to include camera intents
+   */
+  public static Intent getPickImageChooserIntent(
+      @NonNull Context context,
+      CharSequence title,
+      boolean includeDocuments,
+      boolean includeCamera) {
+
+    List<Intent> allIntents = new ArrayList<>();
+    PackageManager packageManager = context.getPackageManager();
+
+    // collect all camera intents if Camera permission is available
+    if (!isExplicitCameraPermissionRequired(context) && includeCamera) {
+      allIntents.addAll(getCameraIntents(context, packageManager));
+    }
+
+    List<Intent> galleryIntents =
+        getGalleryIntents(packageManager, Intent.ACTION_GET_CONTENT, includeDocuments);
+    if (galleryIntents.size() == 0) {
+      // if no intents found for get-content try pick intent action (Huawei P9).
+      galleryIntents = getGalleryIntents(packageManager, Intent.ACTION_PICK, includeDocuments);
+    }
+    allIntents.addAll(galleryIntents);
+
+    Intent target;
+    if (allIntents.isEmpty()) {
+      target = new Intent();
+    } else {
+      target = allIntents.get(allIntents.size() - 1);
+      allIntents.remove(allIntents.size() - 1);
+    }
+
+    // Create a chooser from the main  intent
+    Intent chooserIntent = Intent.createChooser(target, title);
+
+    // Add all other intents
+    chooserIntent.putExtra(
+        Intent.EXTRA_INITIAL_INTENTS, allIntents.toArray(new Parcelable[allIntents.size()]));
+
+    return chooserIntent;
+  }
+
+  /**
+   * Get the main Camera intent for capturing image using device camera app. If the outputFileUri is
+   * null, a default Uri will be created with {@link #getCaptureImageOutputUri(Context)}, so then
+   * you will be able to get the pictureUri using {@link #getPickImageResultUri(Context, Intent)}.
+   * Otherwise, it is just you use the Uri passed to this method.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   * @param outputFileUri the Uri where the picture will be placed.
+   */
+  public static Intent getCameraIntent(@NonNull Context context, Uri outputFileUri) {
+    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
+    if (outputFileUri == null) {
+      outputFileUri = getCaptureImageOutputUri(context);
+    }
+    intent.putExtra(MediaStore.EXTRA_OUTPUT, outputFileUri);
+    return intent;
+  }
+
+  /** Get all Camera intents for capturing image using device camera apps. */
+  public static List<Intent> getCameraIntents(
+      @NonNull Context context, @NonNull PackageManager packageManager) {
+
+    List<Intent> allIntents = new ArrayList<>();
+
+    // Determine Uri of camera image to  save.
+    Uri outputFileUri = getCaptureImageOutputUri(context);
+
+    Intent captureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
+    List<ResolveInfo> listCam = packageManager.queryIntentActivities(captureIntent, 0);
+    for (ResolveInfo res : listCam) {
+      Intent intent = new Intent(captureIntent);
+      intent.setComponent(new ComponentName(res.activityInfo.packageName, res.activityInfo.name));
+      intent.setPackage(res.activityInfo.packageName);
+      if (outputFileUri != null) {
+        intent.putExtra(MediaStore.EXTRA_OUTPUT, outputFileUri);
+      }
+      allIntents.add(intent);
+    }
+
+    return allIntents;
+  }
+
+  /**
+   * Get all Gallery intents for getting image from one of the apps of the device that handle
+   * images.
+   */
+  public static List<Intent> getGalleryIntents(
+      @NonNull PackageManager packageManager, String action, boolean includeDocuments) {
+    List<Intent> intents = new ArrayList<>();
+    Intent galleryIntent =
+        action == Intent.ACTION_GET_CONTENT
+            ? new Intent(action)
+            : new Intent(action, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
+    galleryIntent.setType("image/*");
+    List<ResolveInfo> listGallery = packageManager.queryIntentActivities(galleryIntent, 0);
+    for (ResolveInfo res : listGallery) {
+      Intent intent = new Intent(galleryIntent);
+      intent.setComponent(new ComponentName(res.activityInfo.packageName, res.activityInfo.name));
+      intent.setPackage(res.activityInfo.packageName);
+      intents.add(intent);
+    }
+
+    // remove documents intent
+    if (!includeDocuments) {
+      for (Intent intent : intents) {
+        if (intent
+            .getComponent()
+            .getClassName()
+            .equals("com.android.documentsui.DocumentsActivity")) {
+          intents.remove(intent);
+          break;
+        }
+      }
+    }
+    return intents;
+  }
+
+  /**
+   * Check if explicetly requesting camera permission is required.<br>
+   * It is required in Android Marshmellow and above if "CAMERA" permission is requested in the
+   * manifest.<br>
+   * See <a
+   * href="http://stackoverflow.com/questions/32789027/android-m-camera-intent-permission-bug">StackOverflow
+   * question</a>.
+   */
+  public static boolean isExplicitCameraPermissionRequired(@NonNull Context context) {
+    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+        && hasPermissionInManifest(context, "android.permission.CAMERA")
+        && context.checkSelfPermission(Manifest.permission.CAMERA)
+            != PackageManager.PERMISSION_GRANTED;
+  }
+
+  /**
+   * Check if the app requests a specific permission in the manifest.
+   *
+   * @param permissionName the permission to check
+   * @return true - the permission in requested in manifest, false - not.
+   */
+  public static boolean hasPermissionInManifest(
+      @NonNull Context context, @NonNull String permissionName) {
+    String packageName = context.getPackageName();
+    try {
+      PackageInfo packageInfo =
+          context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
+      final String[] declaredPermisisons = packageInfo.requestedPermissions;
+      if (declaredPermisisons != null && declaredPermisisons.length > 0) {
+        for (String p : declaredPermisisons) {
+          if (p.equalsIgnoreCase(permissionName)) {
+            return true;
+          }
+        }
+      }
+    } catch (PackageManager.NameNotFoundException e) {
+    }
+    return false;
+  }
+
+  /**
+   * Get URI to image received from capture by camera.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   */
+  public static Uri getCaptureImageOutputUri(@NonNull Context context) {
+    Uri outputFileUri = null;
+    File getImage = context.getExternalCacheDir();
+    if (getImage != null) {
+      outputFileUri = Uri.fromFile(new File(getImage.getPath(), "pickImageResult.jpeg"));
+    }
+    return outputFileUri;
+  }
+
+  /**
+   * Get the URI of the selected image from {@link #getPickImageChooserIntent(Context)}.<br>
+   * Will return the correct URI for camera and gallery image.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   * @param data the returned data of the activity result
+   */
+  public static Uri getPickImageResultUri(@NonNull Context context, @Nullable Intent data) {
+    boolean isCamera = true;
+    if (data != null && data.getData() != null) {
+      String action = data.getAction();
+      isCamera = action != null && action.equals(MediaStore.ACTION_IMAGE_CAPTURE);
+    }
+    return isCamera || data.getData() == null ? getCaptureImageOutputUri(context) : data.getData();
+  }
+
+  /**
+   * Check if the given picked image URI requires READ_EXTERNAL_STORAGE permissions.<br>
+   * Only relevant for API version 23 and above and not required for all URI's depends on the
+   * implementation of the app that was used for picking the image. So we just test if we can open
+   * the stream or do we get an exception when we try, Android is awesome.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   * @param uri the result URI of image pick.
+   * @return true - required permission are not granted, false - either no need for permissions or
+   *     they are granted
+   */
+  public static boolean isReadExternalStoragePermissionsRequired(
+      @NonNull Context context, @NonNull Uri uri) {
+    return Build.VERSION.SDK_INT >= Build.VERSION_CODES.M
+        && context.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE)
+            != PackageManager.PERMISSION_GRANTED
+        && isUriRequiresPermissions(context, uri);
+  }
+
+  /**
+   * Test if we can open the given Android URI to test if permission required error is thrown.<br>
+   * Only relevant for API version 23 and above.
+   *
+   * @param context used to access Android APIs, like content resolve, it is your
+   *     activity/fragment/widget.
+   * @param uri the result URI of image pick.
+   */
+  public static boolean isUriRequiresPermissions(@NonNull Context context, @NonNull Uri uri) {
+    try {
+      ContentResolver resolver = context.getContentResolver();
+      InputStream stream = resolver.openInputStream(uri);
+      if (stream != null) {
+        stream.close();
+      }
+      return false;
+    } catch (Exception e) {
+      return true;
+    }
+  }
+
+  /**
+   * Create {@link ActivityBuilder} instance to open image picker for cropping and then start {@link
+   * CropImageActivity} to crop the selected image.<br>
+   * Result will be received in
+   * retrieved using {@link #getActivityResult(Intent)}.
+   *
+   * @return builder for Crop Image Activity
+   */
+  public static ActivityBuilder activity() {
+    return new ActivityBuilder(null);
+  }
+
+  /**
+   * Create {@link ActivityBuilder} instance to start {@link CropImageActivity} to crop the given
+   * image.<br>
+   * Result will be received in
+   * retrieved using {@link #getActivityResult(Intent)}.
+   *
+   * @param uri the image Android uri source to crop or null to start a picker
+   * @return builder for Crop Image Activity
+   */
+  public static ActivityBuilder activity(@Nullable Uri uri) {
+    return new ActivityBuilder(uri);
+  }
+
+  /**
+   * Get {@link CropImageActivity} result data object for crop image activity started using {@link
+   * #activity(Uri)}.
+   *
+   * @param data result data intent as received in
+   * @return Crop Image Activity Result object or null if none exists
+   */
+  public static ActivityResult getActivityResult(@Nullable Intent data) {
+    return data != null ? (ActivityResult) data.getParcelableExtra(CROP_IMAGE_EXTRA_RESULT) : null;
+  }
+
+  // region: Inner class: ActivityBuilder
+
+  /** Builder used for creating Image Crop Activity by user request. */
+  public static final class ActivityBuilder {
+
+    /** The image to crop source Android uri. */
+    @Nullable private final Uri mSource;
+
+    /** Options for image crop UX */
+    private final CropImageOptions mOptions;
+
+    private ActivityBuilder(@Nullable Uri source) {
+      mSource = source;
+      mOptions = new CropImageOptions();
+    }
+
+    /** Get {@link CropImageActivity} intent to start the activity. */
+    public Intent getIntent(@NonNull Context context) {
+      return getIntent(context, CropImageActivity.class);
+    }
+
+    /** Get {@link CropImageActivity} intent to start the activity. */
+    public Intent getIntent(@NonNull Context context, @Nullable Class<?> cls) {
+      mOptions.validate();
+
+      Intent intent = new Intent();
+      intent.setClass(context, cls);
+      Bundle bundle = new Bundle();
+      bundle.putParcelable(CROP_IMAGE_EXTRA_SOURCE, mSource);
+      bundle.putParcelable(CROP_IMAGE_EXTRA_OPTIONS, mOptions);
+      intent.putExtra(CropImage.CROP_IMAGE_EXTRA_BUNDLE, bundle);
+      return intent;
+    }
+
+    /**
+     * Start {@link CropImageActivity}.
+     *
+     * @param activity activity to receive result
+     */
+    public void start(@NonNull Activity activity) {
+      mOptions.validate();
+      activity.startActivityForResult(getIntent(activity), CROP_IMAGE_ACTIVITY_REQUEST_CODE);
+    }
+
+    /**
+     * Start {@link CropImageActivity}.
+     *
+     * @param activity activity to receive result
+     */
+    public void start(@NonNull Activity activity, @Nullable Class<?> cls) {
+      mOptions.validate();
+      activity.startActivityForResult(getIntent(activity, cls), CROP_IMAGE_ACTIVITY_REQUEST_CODE);
+    }
+
+    /**
+     * Start {@link CropImageActivity}.
+     *
+     * @param fragment fragment to receive result
+     */
+    public void start(@NonNull Context context, @NonNull Fragment fragment) {
+      fragment.startActivityForResult(getIntent(context), CROP_IMAGE_ACTIVITY_REQUEST_CODE);
+    }
+
+    /**
+     * Start {@link CropImageActivity}.
+     *
+     * @param fragment fragment to receive result
+     */
+    @RequiresApi(api = Build.VERSION_CODES.HONEYCOMB)
+    public void start(@NonNull Context context, @NonNull android.app.Fragment fragment) {
+      fragment.startActivityForResult(getIntent(context), CROP_IMAGE_ACTIVITY_REQUEST_CODE);
+    }
+
+    /**
+     * Start {@link CropImageActivity}.
+     *
+     * @param fragment fragment to receive result
+     */
+    public void start(
+        @NonNull Context context, @NonNull Fragment fragment, @Nullable Class<?> cls) {
+      fragment.startActivityForResult(getIntent(context, cls), CROP_IMAGE_ACTIVITY_REQUEST_CODE);
+    }
+
+    /**
+     * Start {@link CropImageActivity}.
+     *
+     * @param fragment fragment to receive result
+     */
+    @RequiresApi(api = Build.VERSION_CODES.HONEYCOMB)
+    public void start(
+        @NonNull Context context, @NonNull android.app.Fragment fragment, @Nullable Class<?> cls) {
+      fragment.startActivityForResult(getIntent(context, cls), CROP_IMAGE_ACTIVITY_REQUEST_CODE);
+    }
+
+    /**
+     * The shape of the cropping window.<br>
+     * To set square/circle crop shape set aspect ratio to 1:1.<br>
+     * <i>Default: RECTANGLE</i>
+     */
+    public ActivityBuilder setCropShape(@NonNull CropImageView.CropShape cropShape) {
+      mOptions.cropShape = cropShape;
+      return this;
+    }
+
+    /**
+     * An edge of the crop window will snap to the corresponding edge of a specified bounding box
+     * when the crop window edge is less than or equal to this distance (in pixels) away from the
+     * bounding box edge (in pixels).<br>
+     * <i>Default: 3dp</i>
+     */
+    public ActivityBuilder setSnapRadius(float snapRadius) {
+      mOptions.snapRadius = snapRadius;
+      return this;
+    }
+
+    /**
+     * The radius of the touchable area around the handle (in pixels).<br>
+     * We are basing this value off of the recommended 48dp Rhythm.<br>
+     * See: http://developer.android.com/design/style/metrics-grids.html#48dp-rhythm<br>
+     * <i>Default: 48dp</i>
+     */
+    public ActivityBuilder setTouchRadius(float touchRadius) {
+      mOptions.touchRadius = touchRadius;
+      return this;
+    }
+
+    /**
+     * whether the guidelines should be on, off, or only showing when resizing.<br>
+     * <i>Default: ON_TOUCH</i>
+     */
+    public ActivityBuilder setGuidelines(@NonNull CropImageView.Guidelines guidelines) {
+      mOptions.guidelines = guidelines;
+      return this;
+    }
+
+    /**
+     * The initial scale type of the image in the crop image view<br>
+     * <i>Default: FIT_CENTER</i>
+     */
+    public ActivityBuilder setScaleType(@NonNull CropImageView.ScaleType scaleType) {
+      mOptions.scaleType = scaleType;
+      return this;
+    }
+
+    /**
+     * if to show crop overlay UI what contains the crop window UI surrounded by background over the
+     * cropping image.<br>
+     * <i>default: true, may disable for animation or frame transition.</i>
+     */
+    public ActivityBuilder setShowCropOverlay(boolean showCropOverlay) {
+      mOptions.showCropOverlay = showCropOverlay;
+      return this;
+    }
+
+    /**
+     * if auto-zoom functionality is enabled.<br>
+     * default: true.
+     */
+    public ActivityBuilder setAutoZoomEnabled(boolean autoZoomEnabled) {
+      mOptions.autoZoomEnabled = autoZoomEnabled;
+      return this;
+    }
+
+    /**
+     * if multi touch functionality is enabled.<br>
+     * default: true.
+     */
+    public ActivityBuilder setMultiTouchEnabled(boolean multiTouchEnabled) {
+      mOptions.multiTouchEnabled = multiTouchEnabled;
+      return this;
+    }
+
+    /**
+     * The max zoom allowed during cropping.<br>
+     * <i>Default: 4</i>
+     */
+    public ActivityBuilder setMaxZoom(int maxZoom) {
+      mOptions.maxZoom = maxZoom;
+      return this;
+    }
+
+    /**
+     * The initial crop window padding from image borders in percentage of the cropping image
+     * dimensions.<br>
+     * <i>Default: 0.1</i>
+     */
+    public ActivityBuilder setInitialCropWindowPaddingRatio(float initialCropWindowPaddingRatio) {
+      mOptions.initialCropWindowPaddingRatio = initialCropWindowPaddingRatio;
+      return this;
+    }
+
+    /**
+     * whether the width to height aspect ratio should be maintained or free to change.<br>
+     * <i>Default: false</i>
+     */
+    public ActivityBuilder setFixAspectRatio(boolean fixAspectRatio) {
+      mOptions.fixAspectRatio = fixAspectRatio;
+      return this;
+    }
+
+    /**
+     * the X,Y value of the aspect ratio.<br>
+     * Also sets fixes aspect ratio to TRUE.<br>
+     * <i>Default: 1/1</i>
+     *
+     * @param aspectRatioX the width
+     * @param aspectRatioY the height
+     */
+    public ActivityBuilder setAspectRatio(int aspectRatioX, int aspectRatioY) {
+      mOptions.aspectRatioX = aspectRatioX;
+      mOptions.aspectRatioY = aspectRatioY;
+      mOptions.fixAspectRatio = true;
+      return this;
+    }
+
+    /**
+     * the thickness of the guidelines lines (in pixels).<br>
+     * <i>Default: 3dp</i>
+     */
+    public ActivityBuilder setBorderLineThickness(float borderLineThickness) {
+      mOptions.borderLineThickness = borderLineThickness;
+      return this;
+    }
+
+    /**
+     * the color of the guidelines lines.<br>
+     * <i>Default: Color.argb(170, 255, 255, 255)</i>
+     */
+    public ActivityBuilder setBorderLineColor(int borderLineColor) {
+      mOptions.borderLineColor = borderLineColor;
+      return this;
+    }
+
+    /**
+     * thickness of the corner line (in pixels).<br>
+     * <i>Default: 2dp</i>
+     */
+    public ActivityBuilder setBorderCornerThickness(float borderCornerThickness) {
+      mOptions.borderCornerThickness = borderCornerThickness;
+      return this;
+    }
+
+    /**
+     * the offset of corner line from crop window border (in pixels).<br>
+     * <i>Default: 5dp</i>
+     */
+    public ActivityBuilder setBorderCornerOffset(float borderCornerOffset) {
+      mOptions.borderCornerOffset = borderCornerOffset;
+      return this;
+    }
+
+    /**
+     * the length of the corner line away from the corner (in pixels).<br>
+     * <i>Default: 14dp</i>
+     */
+    public ActivityBuilder setBorderCornerLength(float borderCornerLength) {
+      mOptions.borderCornerLength = borderCornerLength;
+      return this;
+    }
+
+    /**
+     * the color of the corner line.<br>
+     * <i>Default: WHITE</i>
+     */
+    public ActivityBuilder setBorderCornerColor(int borderCornerColor) {
+      mOptions.borderCornerColor = borderCornerColor;
+      return this;
+    }
+
+    /**
+     * the thickness of the guidelines lines (in pixels).<br>
+     * <i>Default: 1dp</i>
+     */
+    public ActivityBuilder setGuidelinesThickness(float guidelinesThickness) {
+      mOptions.guidelinesThickness = guidelinesThickness;
+      return this;
+    }
+
+    /**
+     * the color of the guidelines lines.<br>
+     * <i>Default: Color.argb(170, 255, 255, 255)</i>
+     */
+    public ActivityBuilder setGuidelinesColor(int guidelinesColor) {
+      mOptions.guidelinesColor = guidelinesColor;
+      return this;
+    }
+
+    /**
+     * the color of the overlay background around the crop window cover the image parts not in the
+     * crop window.<br>
+     * <i>Default: Color.argb(119, 0, 0, 0)</i>
+     */
+    public ActivityBuilder setBackgroundColor(int backgroundColor) {
+      mOptions.backgroundColor = backgroundColor;
+      return this;
+    }
+
+    /**
+     * the min size the crop window is allowed to be (in pixels).<br>
+     * <i>Default: 42dp, 42dp</i>
+     */
+    public ActivityBuilder setMinCropWindowSize(int minCropWindowWidth, int minCropWindowHeight) {
+      mOptions.minCropWindowWidth = minCropWindowWidth;
+      mOptions.minCropWindowHeight = minCropWindowHeight;
+      return this;
+    }
+
+    /**
+     * the min size the resulting cropping image is allowed to be, affects the cropping window
+     * limits (in pixels).<br>
+     * <i>Default: 40px, 40px</i>
+     */
+    public ActivityBuilder setMinCropResultSize(int minCropResultWidth, int minCropResultHeight) {
+      mOptions.minCropResultWidth = minCropResultWidth;
+      mOptions.minCropResultHeight = minCropResultHeight;
+      return this;
+    }
+
+    /**
+     * the max size the resulting cropping image is allowed to be, affects the cropping window
+     * limits (in pixels).<br>
+     * <i>Default: 99999, 99999</i>
+     */
+    public ActivityBuilder setMaxCropResultSize(int maxCropResultWidth, int maxCropResultHeight) {
+      mOptions.maxCropResultWidth = maxCropResultWidth;
+      mOptions.maxCropResultHeight = maxCropResultHeight;
+      return this;
+    }
+
+    /**
+     * the title of the {@link CropImageActivity}.<br>
+     * <i>Default: ""</i>
+     */
+    public ActivityBuilder setActivityTitle(CharSequence activityTitle) {
+      mOptions.activityTitle = activityTitle;
+      return this;
+    }
+
+    /**
+     * the color to use for action bar items icons.<br>
+     * <i>Default: NONE</i>
+     */
+    public ActivityBuilder setActivityMenuIconColor(int activityMenuIconColor) {
+      mOptions.activityMenuIconColor = activityMenuIconColor;
+      return this;
+    }
+
+    /**
+     * the Android Uri to save the cropped image to.<br>
+     * <i>Default: NONE, will create a temp file</i>
+     */
+    public ActivityBuilder setOutputUri(Uri outputUri) {
+      mOptions.outputUri = outputUri;
+      return this;
+    }
+
+    /**
+     * the compression format to use when writting the image.<br>
+     * <i>Default: JPEG</i>
+     */
+    public ActivityBuilder setOutputCompressFormat(Bitmap.CompressFormat outputCompressFormat) {
+      mOptions.outputCompressFormat = outputCompressFormat;
+      return this;
+    }
+
+    /**
+     * the quility (if applicable) to use when writting the image (0 - 100).<br>
+     * <i>Default: 90</i>
+     */
+    public ActivityBuilder setOutputCompressQuality(int outputCompressQuality) {
+      mOptions.outputCompressQuality = outputCompressQuality;
+      return this;
+    }
+
+    /**
+     * the size to resize the cropped image to.<br>
+     * Uses {@link CropImageView.RequestSizeOptions#RESIZE_INSIDE} option.<br>
+     * <i>Default: 0, 0 - not set, will not resize</i>
+     */
+    public ActivityBuilder setRequestedSize(int reqWidth, int reqHeight) {
+      return setRequestedSize(reqWidth, reqHeight, CropImageView.RequestSizeOptions.RESIZE_INSIDE);
+    }
+
+    /**
+     * the size to resize the cropped image to.<br>
+     * <i>Default: 0, 0 - not set, will not resize</i>
+     */
+    public ActivityBuilder setRequestedSize(
+        int reqWidth, int reqHeight, CropImageView.RequestSizeOptions options) {
+      mOptions.outputRequestWidth = reqWidth;
+      mOptions.outputRequestHeight = reqHeight;
+      mOptions.outputRequestSizeOptions = options;
+      return this;
+    }
+
+    /**
+     * if the result of crop image activity should not save the cropped image bitmap.<br>
+     * Used if you want to crop the image manually and need only the crop rectangle and rotation
+     * data.<br>
+     * <i>Default: false</i>
+     */
+    public ActivityBuilder setNoOutputImage(boolean noOutputImage) {
+      mOptions.noOutputImage = noOutputImage;
+      return this;
+    }
+
+    /**
+     * the initial rectangle to set on the cropping image after loading.<br>
+     * <i>Default: NONE - will initialize using initial crop window padding ratio</i>
+     */
+    public ActivityBuilder setInitialCropWindowRectangle(Rect initialCropWindowRectangle) {
+      mOptions.initialCropWindowRectangle = initialCropWindowRectangle;
+      return this;
+    }
+
+    /**
+     * the initial rotation to set on the cropping image after loading (0-360 degrees clockwise).
+     * <br>
+     * <i>Default: NONE - will read image exif data</i>
+     */
+    public ActivityBuilder setInitialRotation(int initialRotation) {
+      mOptions.initialRotation = (initialRotation + 360) % 360;
+      return this;
+    }
+
+    /**
+     * if to allow rotation during cropping.<br>
+     * <i>Default: true</i>
+     */
+    public ActivityBuilder setAllowRotation(boolean allowRotation) {
+      mOptions.allowRotation = allowRotation;
+      return this;
+    }
+
+    /**
+     * if to allow flipping during cropping.<br>
+     * <i>Default: true</i>
+     */
+    public ActivityBuilder setAllowFlipping(boolean allowFlipping) {
+      mOptions.allowFlipping = allowFlipping;
+      return this;
+    }
+
+    /**
+     * if to allow counter-clockwise rotation during cropping.<br>
+     * Note: if rotation is disabled this option has no effect.<br>
+     * <i>Default: false</i>
+     */
+    public ActivityBuilder setAllowCounterRotation(boolean allowCounterRotation) {
+      mOptions.allowCounterRotation = allowCounterRotation;
+      return this;
+    }
+
+    /**
+     * The amount of degreees to rotate clockwise or counter-clockwise (0-360).<br>
+     * <i>Default: 90</i>
+     */
+    public ActivityBuilder setRotationDegrees(int rotationDegrees) {
+      mOptions.rotationDegrees = (rotationDegrees + 360) % 360;
+      return this;
+    }
+
+    /**
+     * whether the image should be flipped horizontally.<br>
+     * <i>Default: false</i>
+     */
+    public ActivityBuilder setFlipHorizontally(boolean flipHorizontally) {
+      mOptions.flipHorizontally = flipHorizontally;
+      return this;
+    }
+
+    /**
+     * whether the image should be flipped vertically.<br>
+     * <i>Default: false</i>
+     */
+    public ActivityBuilder setFlipVertically(boolean flipVertically) {
+      mOptions.flipVertically = flipVertically;
+      return this;
+    }
+
+    /**
+     * optional, set crop menu crop button title.<br>
+     * <i>Default: null, will use resource string: crop_image_menu_crop</i>
+     */
+    public ActivityBuilder setCropMenuCropButtonTitle(CharSequence title) {
+      mOptions.cropMenuCropButtonTitle = title;
+      return this;
+    }
+
+    /**
+     * Image resource id to use for crop icon instead of text.<br>
+     * <i>Default: 0</i>
+     */
+    public ActivityBuilder setCropMenuCropButtonIcon(@DrawableRes int drawableResource) {
+      mOptions.cropMenuCropButtonIcon = drawableResource;
+      return this;
+    }
+  }
+  // endregion
+
+  // region: Inner class: ActivityResult
+
+  /** Result data of Crop Image Activity. */
+  public static final class ActivityResult extends CropImageView.CropResult implements Parcelable {
+
+    public static final Creator<ActivityResult> CREATOR =
+        new Creator<ActivityResult>() {
+          @Override
+          public ActivityResult createFromParcel(Parcel in) {
+            return new ActivityResult(in);
+          }
+
+          @Override
+          public ActivityResult[] newArray(int size) {
+            return new ActivityResult[size];
+          }
+        };
+
+    public ActivityResult(
+        Uri originalUri,
+        Uri uri,
+        Exception error,
+        float[] cropPoints,
+        Rect cropRect,
+        int rotation,
+        Rect wholeImageRect,
+        int sampleSize) {
+      super(
+          null,
+          originalUri,
+          null,
+          uri,
+          error,
+          cropPoints,
+          cropRect,
+          wholeImageRect,
+          rotation,
+          sampleSize);
+    }
+
+    protected ActivityResult(Parcel in) {
+      super(
+          null,
+          (Uri) in.readParcelable(Uri.class.getClassLoader()),
+          null,
+          (Uri) in.readParcelable(Uri.class.getClassLoader()),
+          (Exception) in.readSerializable(),
+          in.createFloatArray(),
+          (Rect) in.readParcelable(Rect.class.getClassLoader()),
+          (Rect) in.readParcelable(Rect.class.getClassLoader()),
+          in.readInt(),
+          in.readInt());
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+      dest.writeParcelable(getOriginalUri(), flags);
+      dest.writeParcelable(getUri(), flags);
+      dest.writeSerializable(getError());
+      dest.writeFloatArray(getCropPoints());
+      dest.writeParcelable(getCropRect(), flags);
+      dest.writeParcelable(getWholeImageRect(), flags);
+      dest.writeInt(getRotation());
+      dest.writeInt(getSampleSize());
+    }
+
+    @Override
+    public int describeContents() {
+      return 0;
+    }
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropImageAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageAnimation.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageAnimation.java
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageAnimation.java	(date 1694964014000)
@@ -0,0 +1,121 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.graphics.Matrix;
+import android.graphics.RectF;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.Animation;
+import android.view.animation.Transformation;
+import android.widget.ImageView;
+
+/**
+ * Animation to handle smooth cropping image matrix transformation change, specifically for
+ * zoom-in/out.
+ */
+final class CropImageAnimation extends Animation implements Animation.AnimationListener {
+
+  // region: Fields and Consts
+
+  private final ImageView mImageView;
+
+  private final CropOverlayView mCropOverlayView;
+
+  private final float[] mStartBoundPoints = new float[8];
+
+  private final float[] mEndBoundPoints = new float[8];
+
+  private final RectF mStartCropWindowRect = new RectF();
+
+  private final RectF mEndCropWindowRect = new RectF();
+
+  private final float[] mStartImageMatrix = new float[9];
+
+  private final float[] mEndImageMatrix = new float[9];
+
+  private final RectF mAnimRect = new RectF();
+
+  private final float[] mAnimPoints = new float[8];
+
+  private final float[] mAnimMatrix = new float[9];
+  // endregion
+
+  public CropImageAnimation(ImageView cropImageView, CropOverlayView cropOverlayView) {
+    mImageView = cropImageView;
+    mCropOverlayView = cropOverlayView;
+
+    setDuration(300);
+    setFillAfter(true);
+    setInterpolator(new AccelerateDecelerateInterpolator());
+    setAnimationListener(this);
+  }
+
+  public void setStartState(float[] boundPoints, Matrix imageMatrix) {
+    reset();
+    System.arraycopy(boundPoints, 0, mStartBoundPoints, 0, 8);
+    mStartCropWindowRect.set(mCropOverlayView.getCropWindowRect());
+    imageMatrix.getValues(mStartImageMatrix);
+  }
+
+  public void setEndState(float[] boundPoints, Matrix imageMatrix) {
+    System.arraycopy(boundPoints, 0, mEndBoundPoints, 0, 8);
+    mEndCropWindowRect.set(mCropOverlayView.getCropWindowRect());
+    imageMatrix.getValues(mEndImageMatrix);
+  }
+
+  @Override
+  protected void applyTransformation(float interpolatedTime, Transformation t) {
+
+    mAnimRect.left =
+        mStartCropWindowRect.left
+            + (mEndCropWindowRect.left - mStartCropWindowRect.left) * interpolatedTime;
+    mAnimRect.top =
+        mStartCropWindowRect.top
+            + (mEndCropWindowRect.top - mStartCropWindowRect.top) * interpolatedTime;
+    mAnimRect.right =
+        mStartCropWindowRect.right
+            + (mEndCropWindowRect.right - mStartCropWindowRect.right) * interpolatedTime;
+    mAnimRect.bottom =
+        mStartCropWindowRect.bottom
+            + (mEndCropWindowRect.bottom - mStartCropWindowRect.bottom) * interpolatedTime;
+    mCropOverlayView.setCropWindowRect(mAnimRect);
+
+    for (int i = 0; i < mAnimPoints.length; i++) {
+      mAnimPoints[i] =
+          mStartBoundPoints[i] + (mEndBoundPoints[i] - mStartBoundPoints[i]) * interpolatedTime;
+    }
+    mCropOverlayView.setBounds(mAnimPoints, mImageView.getWidth(), mImageView.getHeight());
+
+    for (int i = 0; i < mAnimMatrix.length; i++) {
+      mAnimMatrix[i] =
+          mStartImageMatrix[i] + (mEndImageMatrix[i] - mStartImageMatrix[i]) * interpolatedTime;
+    }
+    Matrix m = mImageView.getImageMatrix();
+    m.setValues(mAnimMatrix);
+    mImageView.setImageMatrix(m);
+
+    mImageView.invalidate();
+    mCropOverlayView.invalidate();
+  }
+
+  @Override
+  public void onAnimationStart(Animation animation) {}
+
+  @Override
+  public void onAnimationEnd(Animation animation) {
+    mImageView.clearAnimation();
+  }
+
+  @Override
+  public void onAnimationRepeat(Animation animation) {}
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowHandler.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowHandler.java
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowHandler.java	(date 1694964014000)
@@ -0,0 +1,371 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.graphics.RectF;
+
+/** Handler from crop window stuff, moving and knowing possition. */
+final class CropWindowHandler {
+
+  // region: Fields and Consts
+
+  /** The 4 edges of the crop window defining its coordinates and size */
+  private final RectF mEdges = new RectF();
+
+  /**
+   * Rectangle used to return the edges rectangle without ability to change it and without creating
+   * new all the time.
+   */
+  private final RectF mGetEdges = new RectF();
+
+  /** Minimum width in pixels that the crop window can get. */
+  private float mMinCropWindowWidth;
+
+  /** Minimum height in pixels that the crop window can get. */
+  private float mMinCropWindowHeight;
+
+  /** Maximum width in pixels that the crop window can CURRENTLY get. */
+  private float mMaxCropWindowWidth;
+
+  /** Maximum height in pixels that the crop window can CURRENTLY get. */
+  private float mMaxCropWindowHeight;
+
+  /**
+   * Minimum width in pixels that the result of cropping an image can get, affects crop window width
+   * adjusted by width scale factor.
+   */
+  private float mMinCropResultWidth;
+
+  /**
+   * Minimum height in pixels that the result of cropping an image can get, affects crop window
+   * height adjusted by height scale factor.
+   */
+  private float mMinCropResultHeight;
+
+  /**
+   * Maximum width in pixels that the result of cropping an image can get, affects crop window width
+   * adjusted by width scale factor.
+   */
+  private float mMaxCropResultWidth;
+
+  /**
+   * Maximum height in pixels that the result of cropping an image can get, affects crop window
+   * height adjusted by height scale factor.
+   */
+  private float mMaxCropResultHeight;
+
+  /** The width scale factor of shown image and actual image */
+  private float mScaleFactorWidth = 1;
+
+  /** The height scale factor of shown image and actual image */
+  private float mScaleFactorHeight = 1;
+  // endregion
+
+  /** Get the left/top/right/bottom coordinates of the crop window. */
+  public RectF getRect() {
+    mGetEdges.set(mEdges);
+    return mGetEdges;
+  }
+
+  /** Minimum width in pixels that the crop window can get. */
+  public float getMinCropWidth() {
+    return Math.max(mMinCropWindowWidth, mMinCropResultWidth / mScaleFactorWidth);
+  }
+
+  /** Minimum height in pixels that the crop window can get. */
+  public float getMinCropHeight() {
+    return Math.max(mMinCropWindowHeight, mMinCropResultHeight / mScaleFactorHeight);
+  }
+
+  /** Maximum width in pixels that the crop window can get. */
+  public float getMaxCropWidth() {
+    return Math.min(mMaxCropWindowWidth, mMaxCropResultWidth / mScaleFactorWidth);
+  }
+
+  /** Maximum height in pixels that the crop window can get. */
+  public float getMaxCropHeight() {
+    return Math.min(mMaxCropWindowHeight, mMaxCropResultHeight / mScaleFactorHeight);
+  }
+
+  /** get the scale factor (on width) of the showen image to original image. */
+  public float getScaleFactorWidth() {
+    return mScaleFactorWidth;
+  }
+
+  /** get the scale factor (on height) of the showen image to original image. */
+  public float getScaleFactorHeight() {
+    return mScaleFactorHeight;
+  }
+
+  /**
+   * the min size the resulting cropping image is allowed to be, affects the cropping window limits
+   * (in pixels).<br>
+   */
+  public void setMinCropResultSize(int minCropResultWidth, int minCropResultHeight) {
+    mMinCropResultWidth = minCropResultWidth;
+    mMinCropResultHeight = minCropResultHeight;
+  }
+
+  /**
+   * the max size the resulting cropping image is allowed to be, affects the cropping window limits
+   * (in pixels).<br>
+   */
+  public void setMaxCropResultSize(int maxCropResultWidth, int maxCropResultHeight) {
+    mMaxCropResultWidth = maxCropResultWidth;
+    mMaxCropResultHeight = maxCropResultHeight;
+  }
+
+  /**
+   * set the max width/height and scale factor of the showen image to original image to scale the
+   * limits appropriately.
+   */
+  public void setCropWindowLimits(
+      float maxWidth, float maxHeight, float scaleFactorWidth, float scaleFactorHeight) {
+    mMaxCropWindowWidth = maxWidth;
+    mMaxCropWindowHeight = maxHeight;
+    mScaleFactorWidth = scaleFactorWidth;
+    mScaleFactorHeight = scaleFactorHeight;
+  }
+
+  /** Set the variables to be used during crop window handling. */
+  public void setInitialAttributeValues(CropImageOptions options) {
+    mMinCropWindowWidth = options.minCropWindowWidth;
+    mMinCropWindowHeight = options.minCropWindowHeight;
+    mMinCropResultWidth = options.minCropResultWidth;
+    mMinCropResultHeight = options.minCropResultHeight;
+    mMaxCropResultWidth = options.maxCropResultWidth;
+    mMaxCropResultHeight = options.maxCropResultHeight;
+  }
+
+  /** Set the left/top/right/bottom coordinates of the crop window. */
+  public void setRect(RectF rect) {
+    mEdges.set(rect);
+  }
+
+  /**
+   * Indicates whether the crop window is small enough that the guidelines should be shown. Public
+   * because this function is also used to determine if the center handle should be focused.
+   *
+   * @return boolean Whether the guidelines should be shown or not
+   */
+  public boolean showGuidelines() {
+    return !(mEdges.width() < 100 || mEdges.height() < 100);
+  }
+
+  /**
+   * Determines which, if any, of the handles are pressed given the touch coordinates, the bounding
+   * box, and the touch radius.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @param targetRadius the target radius in pixels
+   * @return the Handle that was pressed; null if no Handle was pressed
+   */
+  public CropWindowMoveHandler getMoveHandler(
+      float x, float y, float targetRadius, CropImageView.CropShape cropShape) {
+    CropWindowMoveHandler.Type type =
+        cropShape == CropImageView.CropShape.OVAL
+            ? getOvalPressedMoveType(x, y)
+            : getRectanglePressedMoveType(x, y, targetRadius);
+    return type != null ? new CropWindowMoveHandler(type, this, x, y) : null;
+  }
+
+  // region: Private methods
+
+  /**
+   * Determines which, if any, of the handles are pressed given the touch coordinates, the bounding
+   * box, and the touch radius.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @param targetRadius the target radius in pixels
+   * @return the Handle that was pressed; null if no Handle was pressed
+   */
+  private CropWindowMoveHandler.Type getRectanglePressedMoveType(
+      float x, float y, float targetRadius) {
+    CropWindowMoveHandler.Type moveType = null;
+
+    // Note: corner-handles take precedence, then side-handles, then center.
+    if (CropWindowHandler.isInCornerTargetZone(x, y, mEdges.left, mEdges.top, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.TOP_LEFT;
+    } else if (CropWindowHandler.isInCornerTargetZone(
+        x, y, mEdges.right, mEdges.top, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.TOP_RIGHT;
+    } else if (CropWindowHandler.isInCornerTargetZone(
+        x, y, mEdges.left, mEdges.bottom, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.BOTTOM_LEFT;
+    } else if (CropWindowHandler.isInCornerTargetZone(
+        x, y, mEdges.right, mEdges.bottom, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.BOTTOM_RIGHT;
+    } else if (CropWindowHandler.isInCenterTargetZone(
+            x, y, mEdges.left, mEdges.top, mEdges.right, mEdges.bottom)
+        && focusCenter()) {
+      moveType = CropWindowMoveHandler.Type.CENTER;
+    } else if (CropWindowHandler.isInHorizontalTargetZone(
+        x, y, mEdges.left, mEdges.right, mEdges.top, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.TOP;
+    } else if (CropWindowHandler.isInHorizontalTargetZone(
+        x, y, mEdges.left, mEdges.right, mEdges.bottom, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.BOTTOM;
+    } else if (CropWindowHandler.isInVerticalTargetZone(
+        x, y, mEdges.left, mEdges.top, mEdges.bottom, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.LEFT;
+    } else if (CropWindowHandler.isInVerticalTargetZone(
+        x, y, mEdges.right, mEdges.top, mEdges.bottom, targetRadius)) {
+      moveType = CropWindowMoveHandler.Type.RIGHT;
+    } else if (CropWindowHandler.isInCenterTargetZone(
+            x, y, mEdges.left, mEdges.top, mEdges.right, mEdges.bottom)
+        && !focusCenter()) {
+      moveType = CropWindowMoveHandler.Type.CENTER;
+    }
+
+    return moveType;
+  }
+
+  /**
+   * Determines which, if any, of the handles are pressed given the touch coordinates, the bounding
+   * box/oval, and the touch radius.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @return the Handle that was pressed; null if no Handle was pressed
+   */
+  private CropWindowMoveHandler.Type getOvalPressedMoveType(float x, float y) {
+
+    /*
+       Use a 6x6 grid system divided into 9 "handles", with the center the biggest region. While
+       this is not perfect, it's a good quick-to-ship approach.
+
+       TL T T T T TR
+        L C C C C R
+        L C C C C R
+        L C C C C R
+        L C C C C R
+       BL B B B B BR
+    */
+
+    float cellLength = mEdges.width() / 6;
+    float leftCenter = mEdges.left + cellLength;
+    float rightCenter = mEdges.left + (5 * cellLength);
+
+    float cellHeight = mEdges.height() / 6;
+    float topCenter = mEdges.top + cellHeight;
+    float bottomCenter = mEdges.top + 5 * cellHeight;
+
+    CropWindowMoveHandler.Type moveType;
+    if (x < leftCenter) {
+      if (y < topCenter) {
+        moveType = CropWindowMoveHandler.Type.TOP_LEFT;
+      } else if (y < bottomCenter) {
+        moveType = CropWindowMoveHandler.Type.LEFT;
+      } else {
+        moveType = CropWindowMoveHandler.Type.BOTTOM_LEFT;
+      }
+    } else if (x < rightCenter) {
+      if (y < topCenter) {
+        moveType = CropWindowMoveHandler.Type.TOP;
+      } else if (y < bottomCenter) {
+        moveType = CropWindowMoveHandler.Type.CENTER;
+      } else {
+        moveType = CropWindowMoveHandler.Type.BOTTOM;
+      }
+    } else {
+      if (y < topCenter) {
+        moveType = CropWindowMoveHandler.Type.TOP_RIGHT;
+      } else if (y < bottomCenter) {
+        moveType = CropWindowMoveHandler.Type.RIGHT;
+      } else {
+        moveType = CropWindowMoveHandler.Type.BOTTOM_RIGHT;
+      }
+    }
+
+    return moveType;
+  }
+
+  /**
+   * Determines if the specified coordinate is in the target touch zone for a corner handle.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @param handleX the x-coordinate of the corner handle
+   * @param handleY the y-coordinate of the corner handle
+   * @param targetRadius the target radius in pixels
+   * @return true if the touch point is in the target touch zone; false otherwise
+   */
+  private static boolean isInCornerTargetZone(
+      float x, float y, float handleX, float handleY, float targetRadius) {
+    return Math.abs(x - handleX) <= targetRadius && Math.abs(y - handleY) <= targetRadius;
+  }
+
+  /**
+   * Determines if the specified coordinate is in the target touch zone for a horizontal bar handle.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @param handleXStart the left x-coordinate of the horizontal bar handle
+   * @param handleXEnd the right x-coordinate of the horizontal bar handle
+   * @param handleY the y-coordinate of the horizontal bar handle
+   * @param targetRadius the target radius in pixels
+   * @return true if the touch point is in the target touch zone; false otherwise
+   */
+  private static boolean isInHorizontalTargetZone(
+      float x, float y, float handleXStart, float handleXEnd, float handleY, float targetRadius) {
+    return x > handleXStart && x < handleXEnd && Math.abs(y - handleY) <= targetRadius;
+  }
+
+  /**
+   * Determines if the specified coordinate is in the target touch zone for a vertical bar handle.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @param handleX the x-coordinate of the vertical bar handle
+   * @param handleYStart the top y-coordinate of the vertical bar handle
+   * @param handleYEnd the bottom y-coordinate of the vertical bar handle
+   * @param targetRadius the target radius in pixels
+   * @return true if the touch point is in the target touch zone; false otherwise
+   */
+  private static boolean isInVerticalTargetZone(
+      float x, float y, float handleX, float handleYStart, float handleYEnd, float targetRadius) {
+    return Math.abs(x - handleX) <= targetRadius && y > handleYStart && y < handleYEnd;
+  }
+
+  /**
+   * Determines if the specified coordinate falls anywhere inside the given bounds.
+   *
+   * @param x the x-coordinate of the touch point
+   * @param y the y-coordinate of the touch point
+   * @param left the x-coordinate of the left bound
+   * @param top the y-coordinate of the top bound
+   * @param right the x-coordinate of the right bound
+   * @param bottom the y-coordinate of the bottom bound
+   * @return true if the touch point is inside the bounding rectangle; false otherwise
+   */
+  private static boolean isInCenterTargetZone(
+      float x, float y, float left, float top, float right, float bottom) {
+    return x > left && x < right && y > top && y < bottom;
+  }
+
+  /**
+   * Determines if the cropper should focus on the center handle or the side handles. If it is a
+   * small image, focus on the center handle so the user can move it. If it is a large image, focus
+   * on the side handles so user can grab them. Corresponds to the appearance of the
+   * RuleOfThirdsGuidelines.
+   *
+   * @return true if it is small enough such that it should focus on the center; less than
+   *     show_guidelines limit
+   */
+  private boolean focusCenter() {
+    return !showGuidelines();
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/BitmapLoadingWorkerTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapLoadingWorkerTask.java b/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapLoadingWorkerTask.java
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapLoadingWorkerTask.java	(date 1694964014000)
@@ -0,0 +1,150 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.util.DisplayMetrics;
+
+import java.lang.ref.WeakReference;
+
+/** Task to load bitmap asynchronously from the UI thread. */
+final class BitmapLoadingWorkerTask extends AsyncTask<Void, Void, BitmapLoadingWorkerTask.Result> {
+
+  // region: Fields and Consts
+
+  /** Use a WeakReference to ensure the ImageView can be garbage collected */
+  private final WeakReference<CropImageView> mCropImageViewReference;
+
+  /** The Android URI of the image to load */
+  private final Uri mUri;
+
+  /** The context of the crop image view widget used for loading of bitmap by Android URI */
+  private final Context mContext;
+
+  /** required width of the cropping image after density adjustment */
+  private final int mWidth;
+
+  /** required height of the cropping image after density adjustment */
+  private final int mHeight;
+  // endregion
+
+  public BitmapLoadingWorkerTask(CropImageView cropImageView, Uri uri) {
+    mUri = uri;
+    mCropImageViewReference = new WeakReference<>(cropImageView);
+
+    mContext = cropImageView.getContext();
+
+    DisplayMetrics metrics = cropImageView.getResources().getDisplayMetrics();
+    double densityAdj = metrics.density > 1 ? 1 / metrics.density : 1;
+    mWidth = (int) (metrics.widthPixels * densityAdj);
+    mHeight = (int) (metrics.heightPixels * densityAdj);
+  }
+
+  /** The Android URI that this task is currently loading. */
+  public Uri getUri() {
+    return mUri;
+  }
+
+  /**
+   * Decode image in background.
+   *
+   * @param params ignored
+   * @return the decoded bitmap data
+   */
+  @Override
+  protected Result doInBackground(Void... params) {
+    try {
+      if (!isCancelled()) {
+
+        BitmapUtils.BitmapSampled decodeResult =
+            BitmapUtils.decodeSampledBitmap(mContext, mUri, mWidth, mHeight);
+
+        if (!isCancelled()) {
+
+          BitmapUtils.RotateBitmapResult rotateResult =
+              BitmapUtils.rotateBitmapByExif(decodeResult.bitmap, mContext, mUri);
+
+          return new Result(
+              mUri, rotateResult.bitmap, decodeResult.sampleSize, rotateResult.degrees);
+        }
+      }
+      return null;
+    } catch (Exception e) {
+      return new Result(mUri, e);
+    }
+  }
+
+  /**
+   * Once complete, see if ImageView is still around and set bitmap.
+   *
+   * @param result the result of bitmap loading
+   */
+  @Override
+  protected void onPostExecute(Result result) {
+    if (result != null) {
+      boolean completeCalled = false;
+      if (!isCancelled()) {
+        CropImageView cropImageView = mCropImageViewReference.get();
+        if (cropImageView != null) {
+          completeCalled = true;
+          cropImageView.onSetImageUriAsyncComplete(result);
+        }
+      }
+      if (!completeCalled && result.bitmap != null) {
+        // fast release of unused bitmap
+        result.bitmap.recycle();
+      }
+    }
+  }
+
+  // region: Inner class: Result
+
+  /** The result of BitmapLoadingWorkerTask async loading. */
+  public static final class Result {
+
+    /** The Android URI of the image to load */
+    public final Uri uri;
+
+    /** The loaded bitmap */
+    public final Bitmap bitmap;
+
+    /** The sample size used to load the given bitmap */
+    public final int loadSampleSize;
+
+    /** The degrees the image was rotated */
+    public final int degreesRotated;
+
+    /** The error that occurred during async bitmap loading. */
+    public final Exception error;
+
+    Result(Uri uri, Bitmap bitmap, int loadSampleSize, int degreesRotated) {
+      this.uri = uri;
+      this.bitmap = bitmap;
+      this.loadSampleSize = loadSampleSize;
+      this.degreesRotated = degreesRotated;
+      this.error = null;
+    }
+
+    Result(Uri uri, Exception error) {
+      this.uri = uri;
+      this.bitmap = null;
+      this.loadSampleSize = 0;
+      this.degreesRotated = 0;
+      this.error = error;
+    }
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowMoveHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowMoveHandler.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowMoveHandler.java
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropWindowMoveHandler.java	(date 1694964014000)
@@ -0,0 +1,766 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.graphics.Matrix;
+import android.graphics.PointF;
+import android.graphics.RectF;
+
+/**
+ * Handler to update crop window edges by the move type - Horizontal, Vertical, Corner or Center.
+ * <br>
+ */
+final class CropWindowMoveHandler {
+
+  // region: Fields and Consts
+
+  /** Matrix used for rectangle rotation handling */
+  private static final Matrix MATRIX = new Matrix();
+
+  /** Minimum width in pixels that the crop window can get. */
+  private final float mMinCropWidth;
+
+  /** Minimum width in pixels that the crop window can get. */
+  private final float mMinCropHeight;
+
+  /** Maximum height in pixels that the crop window can get. */
+  private final float mMaxCropWidth;
+
+  /** Maximum height in pixels that the crop window can get. */
+  private final float mMaxCropHeight;
+
+  /** The type of crop window move that is handled. */
+  private final Type mType;
+
+  /**
+   * Holds the x and y offset between the exact touch location and the exact handle location that is
+   * activated. There may be an offset because we allow for some leeway (specified by mHandleRadius)
+   * in activating a handle. However, we want to maintain these offset values while the handle is
+   * being dragged so that the handle doesn't jump.
+   */
+  private final PointF mTouchOffset = new PointF();
+  // endregion
+
+  /**
+   * @param edgeMoveType the type of move this handler is executing
+   * @param horizontalEdge the primary edge associated with this handle; may be null
+   * @param verticalEdge the secondary edge associated with this handle; may be null
+   * @param cropWindowHandler main crop window handle to get and update the crop window edges
+   * @param touchX the location of the initial toch possition to measure move distance
+   * @param touchY the location of the initial toch possition to measure move distance
+   */
+  public CropWindowMoveHandler(
+      Type type, CropWindowHandler cropWindowHandler, float touchX, float touchY) {
+    mType = type;
+    mMinCropWidth = cropWindowHandler.getMinCropWidth();
+    mMinCropHeight = cropWindowHandler.getMinCropHeight();
+    mMaxCropWidth = cropWindowHandler.getMaxCropWidth();
+    mMaxCropHeight = cropWindowHandler.getMaxCropHeight();
+    calculateTouchOffset(cropWindowHandler.getRect(), touchX, touchY);
+  }
+
+  /**
+   * Updates the crop window by change in the toch location.<br>
+   * Move type handled by this instance, as initialized in creation, affects how the change in toch
+   * location changes the crop window position and size.<br>
+   * After the crop window position/size is changed by toch move it may result in values that
+   * vialate contraints: outside the bounds of the shown bitmap, smaller/larger than min/max size or
+   * missmatch in aspect ratio. So a series of fixes is executed on "secondary" edges to adjust it
+   * by the "primary" edge movement.<br>
+   * Primary is the edge directly affected by move type, secondary is the other edge.<br>
+   * The crop window is changed by directly setting the Edge coordinates.
+   *
+   * @param x the new x-coordinate of this handle
+   * @param y the new y-coordinate of this handle
+   * @param bounds the bounding rectangle of the image
+   * @param viewWidth The bounding image view width used to know the crop overlay is at view edges.
+   * @param viewHeight The bounding image view height used to know the crop overlay is at view
+   *     edges.
+   * @param parentView the parent View containing the image
+   * @param snapMargin the maximum distance (in pixels) at which the crop window should snap to the
+   *     image
+   * @param fixedAspectRatio is the aspect ration fixed and 'targetAspectRatio' should be used
+   * @param aspectRatio the aspect ratio to maintain
+   */
+  public void move(
+      RectF rect,
+      float x,
+      float y,
+      RectF bounds,
+      int viewWidth,
+      int viewHeight,
+      float snapMargin,
+      boolean fixedAspectRatio,
+      float aspectRatio) {
+
+    // Adjust the coordinates for the finger position's offset (i.e. the
+    // distance from the initial touch to the precise handle location).
+    // We want to maintain the initial touch's distance to the pressed
+    // handle so that the crop window size does not "jump".
+    float adjX = x + mTouchOffset.x;
+    float adjY = y + mTouchOffset.y;
+
+    if (mType == Type.CENTER) {
+      moveCenter(rect, adjX, adjY, bounds, viewWidth, viewHeight, snapMargin);
+    } else {
+      if (fixedAspectRatio) {
+        moveSizeWithFixedAspectRatio(
+            rect, adjX, adjY, bounds, viewWidth, viewHeight, snapMargin, aspectRatio);
+      } else {
+        moveSizeWithFreeAspectRatio(rect, adjX, adjY, bounds, viewWidth, viewHeight, snapMargin);
+      }
+    }
+  }
+
+  // region: Private methods
+
+  /**
+   * Calculates the offset of the touch point from the precise location of the specified handle.<br>
+   * Save these values in a member variable since we want to maintain this offset as we drag the
+   * handle.
+   */
+  private void calculateTouchOffset(RectF rect, float touchX, float touchY) {
+
+    float touchOffsetX = 0;
+    float touchOffsetY = 0;
+
+    // Calculate the offset from the appropriate handle.
+    switch (mType) {
+      case TOP_LEFT:
+        touchOffsetX = rect.left - touchX;
+        touchOffsetY = rect.top - touchY;
+        break;
+      case TOP_RIGHT:
+        touchOffsetX = rect.right - touchX;
+        touchOffsetY = rect.top - touchY;
+        break;
+      case BOTTOM_LEFT:
+        touchOffsetX = rect.left - touchX;
+        touchOffsetY = rect.bottom - touchY;
+        break;
+      case BOTTOM_RIGHT:
+        touchOffsetX = rect.right - touchX;
+        touchOffsetY = rect.bottom - touchY;
+        break;
+      case LEFT:
+        touchOffsetX = rect.left - touchX;
+        touchOffsetY = 0;
+        break;
+      case TOP:
+        touchOffsetX = 0;
+        touchOffsetY = rect.top - touchY;
+        break;
+      case RIGHT:
+        touchOffsetX = rect.right - touchX;
+        touchOffsetY = 0;
+        break;
+      case BOTTOM:
+        touchOffsetX = 0;
+        touchOffsetY = rect.bottom - touchY;
+        break;
+      case CENTER:
+        touchOffsetX = rect.centerX() - touchX;
+        touchOffsetY = rect.centerY() - touchY;
+        break;
+      default:
+        break;
+    }
+
+    mTouchOffset.x = touchOffsetX;
+    mTouchOffset.y = touchOffsetY;
+  }
+
+  /** Center move only changes the position of the crop window without changing the size. */
+  private void moveCenter(
+      RectF rect, float x, float y, RectF bounds, int viewWidth, int viewHeight, float snapRadius) {
+    float dx = x - rect.centerX();
+    float dy = y - rect.centerY();
+    if (rect.left + dx < 0
+        || rect.right + dx > viewWidth
+        || rect.left + dx < bounds.left
+        || rect.right + dx > bounds.right) {
+      dx /= 1.05f;
+      mTouchOffset.x -= dx / 2;
+    }
+    if (rect.top + dy < 0
+        || rect.bottom + dy > viewHeight
+        || rect.top + dy < bounds.top
+        || rect.bottom + dy > bounds.bottom) {
+      dy /= 1.05f;
+      mTouchOffset.y -= dy / 2;
+    }
+    rect.offset(dx, dy);
+    snapEdgesToBounds(rect, bounds, snapRadius);
+  }
+
+  /**
+   * Change the size of the crop window on the required edge (or edges for corner size move) without
+   * affecting "secondary" edges.<br>
+   * Only the primary edge(s) are fixed to stay within limits.
+   */
+  private void moveSizeWithFreeAspectRatio(
+      RectF rect, float x, float y, RectF bounds, int viewWidth, int viewHeight, float snapMargin) {
+    switch (mType) {
+      case TOP_LEFT:
+        adjustTop(rect, y, bounds, snapMargin, 0, false, false);
+        adjustLeft(rect, x, bounds, snapMargin, 0, false, false);
+        break;
+      case TOP_RIGHT:
+        adjustTop(rect, y, bounds, snapMargin, 0, false, false);
+        adjustRight(rect, x, bounds, viewWidth, snapMargin, 0, false, false);
+        break;
+      case BOTTOM_LEFT:
+        adjustBottom(rect, y, bounds, viewHeight, snapMargin, 0, false, false);
+        adjustLeft(rect, x, bounds, snapMargin, 0, false, false);
+        break;
+      case BOTTOM_RIGHT:
+        adjustBottom(rect, y, bounds, viewHeight, snapMargin, 0, false, false);
+        adjustRight(rect, x, bounds, viewWidth, snapMargin, 0, false, false);
+        break;
+      case LEFT:
+        adjustLeft(rect, x, bounds, snapMargin, 0, false, false);
+        break;
+      case TOP:
+        adjustTop(rect, y, bounds, snapMargin, 0, false, false);
+        break;
+      case RIGHT:
+        adjustRight(rect, x, bounds, viewWidth, snapMargin, 0, false, false);
+        break;
+      case BOTTOM:
+        adjustBottom(rect, y, bounds, viewHeight, snapMargin, 0, false, false);
+        break;
+      default:
+        break;
+    }
+  }
+
+  /**
+   * Change the size of the crop window on the required "primary" edge WITH affect to relevant
+   * "secondary" edge via aspect ratio.<br>
+   * Example: change in the left edge (primary) will affect top and bottom edges (secondary) to
+   * preserve the given aspect ratio.
+   */
+  private void moveSizeWithFixedAspectRatio(
+      RectF rect,
+      float x,
+      float y,
+      RectF bounds,
+      int viewWidth,
+      int viewHeight,
+      float snapMargin,
+      float aspectRatio) {
+    switch (mType) {
+      case TOP_LEFT:
+        if (calculateAspectRatio(x, y, rect.right, rect.bottom) < aspectRatio) {
+          adjustTop(rect, y, bounds, snapMargin, aspectRatio, true, false);
+          adjustLeftByAspectRatio(rect, aspectRatio);
+        } else {
+          adjustLeft(rect, x, bounds, snapMargin, aspectRatio, true, false);
+          adjustTopByAspectRatio(rect, aspectRatio);
+        }
+        break;
+      case TOP_RIGHT:
+        if (calculateAspectRatio(rect.left, y, x, rect.bottom) < aspectRatio) {
+          adjustTop(rect, y, bounds, snapMargin, aspectRatio, false, true);
+          adjustRightByAspectRatio(rect, aspectRatio);
+        } else {
+          adjustRight(rect, x, bounds, viewWidth, snapMargin, aspectRatio, true, false);
+          adjustTopByAspectRatio(rect, aspectRatio);
+        }
+        break;
+      case BOTTOM_LEFT:
+        if (calculateAspectRatio(x, rect.top, rect.right, y) < aspectRatio) {
+          adjustBottom(rect, y, bounds, viewHeight, snapMargin, aspectRatio, true, false);
+          adjustLeftByAspectRatio(rect, aspectRatio);
+        } else {
+          adjustLeft(rect, x, bounds, snapMargin, aspectRatio, false, true);
+          adjustBottomByAspectRatio(rect, aspectRatio);
+        }
+        break;
+      case BOTTOM_RIGHT:
+        if (calculateAspectRatio(rect.left, rect.top, x, y) < aspectRatio) {
+          adjustBottom(rect, y, bounds, viewHeight, snapMargin, aspectRatio, false, true);
+          adjustRightByAspectRatio(rect, aspectRatio);
+        } else {
+          adjustRight(rect, x, bounds, viewWidth, snapMargin, aspectRatio, false, true);
+          adjustBottomByAspectRatio(rect, aspectRatio);
+        }
+        break;
+      case LEFT:
+        adjustLeft(rect, x, bounds, snapMargin, aspectRatio, true, true);
+        adjustTopBottomByAspectRatio(rect, bounds, aspectRatio);
+        break;
+      case TOP:
+        adjustTop(rect, y, bounds, snapMargin, aspectRatio, true, true);
+        adjustLeftRightByAspectRatio(rect, bounds, aspectRatio);
+        break;
+      case RIGHT:
+        adjustRight(rect, x, bounds, viewWidth, snapMargin, aspectRatio, true, true);
+        adjustTopBottomByAspectRatio(rect, bounds, aspectRatio);
+        break;
+      case BOTTOM:
+        adjustBottom(rect, y, bounds, viewHeight, snapMargin, aspectRatio, true, true);
+        adjustLeftRightByAspectRatio(rect, bounds, aspectRatio);
+        break;
+      default:
+        break;
+    }
+  }
+
+  /** Check if edges have gone out of bounds (including snap margin), and fix if needed. */
+  private void snapEdgesToBounds(RectF edges, RectF bounds, float margin) {
+    if (edges.left < bounds.left + margin) {
+      edges.offset(bounds.left - edges.left, 0);
+    }
+    if (edges.top < bounds.top + margin) {
+      edges.offset(0, bounds.top - edges.top);
+    }
+    if (edges.right > bounds.right - margin) {
+      edges.offset(bounds.right - edges.right, 0);
+    }
+    if (edges.bottom > bounds.bottom - margin) {
+      edges.offset(0, bounds.bottom - edges.bottom);
+    }
+  }
+
+  /**
+   * Get the resulting x-position of the left edge of the crop window given the handle's position
+   * and the image's bounding box and snap radius.
+   *
+   * @param left the position that the left edge is dragged to
+   * @param bounds the bounding box of the image that is being cropped
+   * @param snapMargin the snap distance to the image edge (in pixels)
+   */
+  private void adjustLeft(
+      RectF rect,
+      float left,
+      RectF bounds,
+      float snapMargin,
+      float aspectRatio,
+      boolean topMoves,
+      boolean bottomMoves) {
+
+    float newLeft = left;
+
+    if (newLeft < 0) {
+      newLeft /= 1.05f;
+      mTouchOffset.x -= newLeft / 1.1f;
+    }
+
+    if (newLeft < bounds.left) {
+      mTouchOffset.x -= (newLeft - bounds.left) / 2f;
+    }
+
+    if (newLeft - bounds.left < snapMargin) {
+      newLeft = bounds.left;
+    }
+
+    // Checks if the window is too small horizontally
+    if (rect.right - newLeft < mMinCropWidth) {
+      newLeft = rect.right - mMinCropWidth;
+    }
+
+    // Checks if the window is too large horizontally
+    if (rect.right - newLeft > mMaxCropWidth) {
+      newLeft = rect.right - mMaxCropWidth;
+    }
+
+    if (newLeft - bounds.left < snapMargin) {
+      newLeft = bounds.left;
+    }
+
+    // check vertical bounds if aspect ratio is in play
+    if (aspectRatio > 0) {
+      float newHeight = (rect.right - newLeft) / aspectRatio;
+
+      // Checks if the window is too small vertically
+      if (newHeight < mMinCropHeight) {
+        newLeft = Math.max(bounds.left, rect.right - mMinCropHeight * aspectRatio);
+        newHeight = (rect.right - newLeft) / aspectRatio;
+      }
+
+      // Checks if the window is too large vertically
+      if (newHeight > mMaxCropHeight) {
+        newLeft = Math.max(bounds.left, rect.right - mMaxCropHeight * aspectRatio);
+        newHeight = (rect.right - newLeft) / aspectRatio;
+      }
+
+      // if top AND bottom edge moves by aspect ratio check that it is within full height bounds
+      if (topMoves && bottomMoves) {
+        newLeft =
+            Math.max(newLeft, Math.max(bounds.left, rect.right - bounds.height() * aspectRatio));
+      } else {
+        // if top edge moves by aspect ratio check that it is within bounds
+        if (topMoves && rect.bottom - newHeight < bounds.top) {
+          newLeft = Math.max(bounds.left, rect.right - (rect.bottom - bounds.top) * aspectRatio);
+          newHeight = (rect.right - newLeft) / aspectRatio;
+        }
+
+        // if bottom edge moves by aspect ratio check that it is within bounds
+        if (bottomMoves && rect.top + newHeight > bounds.bottom) {
+          newLeft =
+              Math.max(
+                  newLeft,
+                  Math.max(bounds.left, rect.right - (bounds.bottom - rect.top) * aspectRatio));
+        }
+      }
+    }
+
+    rect.left = newLeft;
+  }
+
+  /**
+   * Get the resulting x-position of the right edge of the crop window given the handle's position
+   * and the image's bounding box and snap radius.
+   *
+   * @param right the position that the right edge is dragged to
+   * @param bounds the bounding box of the image that is being cropped
+   * @param viewWidth
+   * @param snapMargin the snap distance to the image edge (in pixels)
+   */
+  private void adjustRight(
+      RectF rect,
+      float right,
+      RectF bounds,
+      int viewWidth,
+      float snapMargin,
+      float aspectRatio,
+      boolean topMoves,
+      boolean bottomMoves) {
+
+    float newRight = right;
+
+    if (newRight > viewWidth) {
+      newRight = viewWidth + (newRight - viewWidth) / 1.05f;
+      mTouchOffset.x -= (newRight - viewWidth) / 1.1f;
+    }
+
+    if (newRight > bounds.right) {
+      mTouchOffset.x -= (newRight - bounds.right) / 2f;
+    }
+
+    // If close to the edge
+    if (bounds.right - newRight < snapMargin) {
+      newRight = bounds.right;
+    }
+
+    // Checks if the window is too small horizontally
+    if (newRight - rect.left < mMinCropWidth) {
+      newRight = rect.left + mMinCropWidth;
+    }
+
+    // Checks if the window is too large horizontally
+    if (newRight - rect.left > mMaxCropWidth) {
+      newRight = rect.left + mMaxCropWidth;
+    }
+
+    // If close to the edge
+    if (bounds.right - newRight < snapMargin) {
+      newRight = bounds.right;
+    }
+
+    // check vertical bounds if aspect ratio is in play
+    if (aspectRatio > 0) {
+      float newHeight = (newRight - rect.left) / aspectRatio;
+
+      // Checks if the window is too small vertically
+      if (newHeight < mMinCropHeight) {
+        newRight = Math.min(bounds.right, rect.left + mMinCropHeight * aspectRatio);
+        newHeight = (newRight - rect.left) / aspectRatio;
+      }
+
+      // Checks if the window is too large vertically
+      if (newHeight > mMaxCropHeight) {
+        newRight = Math.min(bounds.right, rect.left + mMaxCropHeight * aspectRatio);
+        newHeight = (newRight - rect.left) / aspectRatio;
+      }
+
+      // if top AND bottom edge moves by aspect ratio check that it is within full height bounds
+      if (topMoves && bottomMoves) {
+        newRight =
+            Math.min(newRight, Math.min(bounds.right, rect.left + bounds.height() * aspectRatio));
+      } else {
+        // if top edge moves by aspect ratio check that it is within bounds
+        if (topMoves && rect.bottom - newHeight < bounds.top) {
+          newRight = Math.min(bounds.right, rect.left + (rect.bottom - bounds.top) * aspectRatio);
+          newHeight = (newRight - rect.left) / aspectRatio;
+        }
+
+        // if bottom edge moves by aspect ratio check that it is within bounds
+        if (bottomMoves && rect.top + newHeight > bounds.bottom) {
+          newRight =
+              Math.min(
+                  newRight,
+                  Math.min(bounds.right, rect.left + (bounds.bottom - rect.top) * aspectRatio));
+        }
+      }
+    }
+
+    rect.right = newRight;
+  }
+
+  /**
+   * Get the resulting y-position of the top edge of the crop window given the handle's position and
+   * the image's bounding box and snap radius.
+   *
+   * @param top the x-position that the top edge is dragged to
+   * @param bounds the bounding box of the image that is being cropped
+   * @param snapMargin the snap distance to the image edge (in pixels)
+   */
+  private void adjustTop(
+      RectF rect,
+      float top,
+      RectF bounds,
+      float snapMargin,
+      float aspectRatio,
+      boolean leftMoves,
+      boolean rightMoves) {
+
+    float newTop = top;
+
+    if (newTop < 0) {
+      newTop /= 1.05f;
+      mTouchOffset.y -= newTop / 1.1f;
+    }
+
+    if (newTop < bounds.top) {
+      mTouchOffset.y -= (newTop - bounds.top) / 2f;
+    }
+
+    if (newTop - bounds.top < snapMargin) {
+      newTop = bounds.top;
+    }
+
+    // Checks if the window is too small vertically
+    if (rect.bottom - newTop < mMinCropHeight) {
+      newTop = rect.bottom - mMinCropHeight;
+    }
+
+    // Checks if the window is too large vertically
+    if (rect.bottom - newTop > mMaxCropHeight) {
+      newTop = rect.bottom - mMaxCropHeight;
+    }
+
+    if (newTop - bounds.top < snapMargin) {
+      newTop = bounds.top;
+    }
+
+    // check horizontal bounds if aspect ratio is in play
+    if (aspectRatio > 0) {
+      float newWidth = (rect.bottom - newTop) * aspectRatio;
+
+      // Checks if the crop window is too small horizontally due to aspect ratio adjustment
+      if (newWidth < mMinCropWidth) {
+        newTop = Math.max(bounds.top, rect.bottom - (mMinCropWidth / aspectRatio));
+        newWidth = (rect.bottom - newTop) * aspectRatio;
+      }
+
+      // Checks if the crop window is too large horizontally due to aspect ratio adjustment
+      if (newWidth > mMaxCropWidth) {
+        newTop = Math.max(bounds.top, rect.bottom - (mMaxCropWidth / aspectRatio));
+        newWidth = (rect.bottom - newTop) * aspectRatio;
+      }
+
+      // if left AND right edge moves by aspect ratio check that it is within full width bounds
+      if (leftMoves && rightMoves) {
+        newTop = Math.max(newTop, Math.max(bounds.top, rect.bottom - bounds.width() / aspectRatio));
+      } else {
+        // if left edge moves by aspect ratio check that it is within bounds
+        if (leftMoves && rect.right - newWidth < bounds.left) {
+          newTop = Math.max(bounds.top, rect.bottom - (rect.right - bounds.left) / aspectRatio);
+          newWidth = (rect.bottom - newTop) * aspectRatio;
+        }
+
+        // if right edge moves by aspect ratio check that it is within bounds
+        if (rightMoves && rect.left + newWidth > bounds.right) {
+          newTop =
+              Math.max(
+                  newTop,
+                  Math.max(bounds.top, rect.bottom - (bounds.right - rect.left) / aspectRatio));
+        }
+      }
+    }
+
+    rect.top = newTop;
+  }
+
+  /**
+   * Get the resulting y-position of the bottom edge of the crop window given the handle's position
+   * and the image's bounding box and snap radius.
+   *
+   * @param bottom the position that the bottom edge is dragged to
+   * @param bounds the bounding box of the image that is being cropped
+   * @param viewHeight
+   * @param snapMargin the snap distance to the image edge (in pixels)
+   */
+  private void adjustBottom(
+      RectF rect,
+      float bottom,
+      RectF bounds,
+      int viewHeight,
+      float snapMargin,
+      float aspectRatio,
+      boolean leftMoves,
+      boolean rightMoves) {
+
+    float newBottom = bottom;
+
+    if (newBottom > viewHeight) {
+      newBottom = viewHeight + (newBottom - viewHeight) / 1.05f;
+      mTouchOffset.y -= (newBottom - viewHeight) / 1.1f;
+    }
+
+    if (newBottom > bounds.bottom) {
+      mTouchOffset.y -= (newBottom - bounds.bottom) / 2f;
+    }
+
+    if (bounds.bottom - newBottom < snapMargin) {
+      newBottom = bounds.bottom;
+    }
+
+    // Checks if the window is too small vertically
+    if (newBottom - rect.top < mMinCropHeight) {
+      newBottom = rect.top + mMinCropHeight;
+    }
+
+    // Checks if the window is too small vertically
+    if (newBottom - rect.top > mMaxCropHeight) {
+      newBottom = rect.top + mMaxCropHeight;
+    }
+
+    if (bounds.bottom - newBottom < snapMargin) {
+      newBottom = bounds.bottom;
+    }
+
+    // check horizontal bounds if aspect ratio is in play
+    if (aspectRatio > 0) {
+      float newWidth = (newBottom - rect.top) * aspectRatio;
+
+      // Checks if the window is too small horizontally
+      if (newWidth < mMinCropWidth) {
+        newBottom = Math.min(bounds.bottom, rect.top + mMinCropWidth / aspectRatio);
+        newWidth = (newBottom - rect.top) * aspectRatio;
+      }
+
+      // Checks if the window is too large horizontally
+      if (newWidth > mMaxCropWidth) {
+        newBottom = Math.min(bounds.bottom, rect.top + mMaxCropWidth / aspectRatio);
+        newWidth = (newBottom - rect.top) * aspectRatio;
+      }
+
+      // if left AND right edge moves by aspect ratio check that it is within full width bounds
+      if (leftMoves && rightMoves) {
+        newBottom =
+            Math.min(newBottom, Math.min(bounds.bottom, rect.top + bounds.width() / aspectRatio));
+      } else {
+        // if left edge moves by aspect ratio check that it is within bounds
+        if (leftMoves && rect.right - newWidth < bounds.left) {
+          newBottom = Math.min(bounds.bottom, rect.top + (rect.right - bounds.left) / aspectRatio);
+          newWidth = (newBottom - rect.top) * aspectRatio;
+        }
+
+        // if right edge moves by aspect ratio check that it is within bounds
+        if (rightMoves && rect.left + newWidth > bounds.right) {
+          newBottom =
+              Math.min(
+                  newBottom,
+                  Math.min(bounds.bottom, rect.top + (bounds.right - rect.left) / aspectRatio));
+        }
+      }
+    }
+
+    rect.bottom = newBottom;
+  }
+
+  /**
+   * Adjust left edge by current crop window height and the given aspect ratio, the right edge
+   * remains in possition while the left adjusts to keep aspect ratio to the height.
+   */
+  private void adjustLeftByAspectRatio(RectF rect, float aspectRatio) {
+    rect.left = rect.right - rect.height() * aspectRatio;
+  }
+
+  /**
+   * Adjust top edge by current crop window width and the given aspect ratio, the bottom edge
+   * remains in possition while the top adjusts to keep aspect ratio to the width.
+   */
+  private void adjustTopByAspectRatio(RectF rect, float aspectRatio) {
+    rect.top = rect.bottom - rect.width() / aspectRatio;
+  }
+
+  /**
+   * Adjust right edge by current crop window height and the given aspect ratio, the left edge
+   * remains in possition while the left adjusts to keep aspect ratio to the height.
+   */
+  private void adjustRightByAspectRatio(RectF rect, float aspectRatio) {
+    rect.right = rect.left + rect.height() * aspectRatio;
+  }
+
+  /**
+   * Adjust bottom edge by current crop window width and the given aspect ratio, the top edge
+   * remains in possition while the top adjusts to keep aspect ratio to the width.
+   */
+  private void adjustBottomByAspectRatio(RectF rect, float aspectRatio) {
+    rect.bottom = rect.top + rect.width() / aspectRatio;
+  }
+
+  /**
+   * Adjust left and right edges by current crop window height and the given aspect ratio, both
+   * right and left edges adjusts equally relative to center to keep aspect ratio to the height.
+   */
+  private void adjustLeftRightByAspectRatio(RectF rect, RectF bounds, float aspectRatio) {
+    rect.inset((rect.width() - rect.height() * aspectRatio) / 2, 0);
+    if (rect.left < bounds.left) {
+      rect.offset(bounds.left - rect.left, 0);
+    }
+    if (rect.right > bounds.right) {
+      rect.offset(bounds.right - rect.right, 0);
+    }
+  }
+
+  /**
+   * Adjust top and bottom edges by current crop window width and the given aspect ratio, both top
+   * and bottom edges adjusts equally relative to center to keep aspect ratio to the width.
+   */
+  private void adjustTopBottomByAspectRatio(RectF rect, RectF bounds, float aspectRatio) {
+    rect.inset(0, (rect.height() - rect.width() / aspectRatio) / 2);
+    if (rect.top < bounds.top) {
+      rect.offset(0, bounds.top - rect.top);
+    }
+    if (rect.bottom > bounds.bottom) {
+      rect.offset(0, bounds.bottom - rect.bottom);
+    }
+  }
+
+  /** Calculates the aspect ratio given a rectangle. */
+  private static float calculateAspectRatio(float left, float top, float right, float bottom) {
+    return (right - left) / (bottom - top);
+  }
+  // endregion
+
+  // region: Inner class: Type
+
+  /** The type of crop window move that is handled. */
+  public enum Type {
+    TOP_LEFT,
+    TOP_RIGHT,
+    BOTTOM_LEFT,
+    BOTTOM_RIGHT,
+    LEFT,
+    TOP,
+    RIGHT,
+    BOTTOM,
+    CENTER
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropOverlayView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropOverlayView.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropOverlayView.java
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropOverlayView.java	(date 1694964014000)
@@ -0,0 +1,1040 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.Region;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.MotionEvent;
+import android.view.ScaleGestureDetector;
+import android.view.View;
+
+import java.util.Arrays;
+
+/** A custom View representing the crop window and the shaded background outside the crop window. */
+public class CropOverlayView extends View {
+
+  // region: Fields and Consts
+
+  /** Gesture detector used for multi touch box scaling */
+  private ScaleGestureDetector mScaleDetector;
+
+  /** Boolean to see if multi touch is enabled for the crop rectangle */
+  private boolean mMultiTouchEnabled;
+
+  /** Handler from crop window stuff, moving and knowing possition. */
+  private final CropWindowHandler mCropWindowHandler = new CropWindowHandler();
+
+  /** Listener to publicj crop window changes */
+  private CropWindowChangeListener mCropWindowChangeListener;
+
+  /** Rectangle used for drawing */
+  private final RectF mDrawRect = new RectF();
+
+  /** The Paint used to draw the white rectangle around the crop area. */
+  private Paint mBorderPaint;
+
+  /** The Paint used to draw the corners of the Border */
+  private Paint mBorderCornerPaint;
+
+  /** The Paint used to draw the guidelines within the crop area when pressed. */
+  private Paint mGuidelinePaint;
+
+  /** The Paint used to darken the surrounding areas outside the crop area. */
+  private Paint mBackgroundPaint;
+
+  /** Used for oval crop window shape or non-straight rotation drawing. */
+  private Path mPath = new Path();
+
+  /** The bounding box around the Bitmap that we are cropping. */
+  private final float[] mBoundsPoints = new float[8];
+
+  /** The bounding box around the Bitmap that we are cropping. */
+  private final RectF mCalcBounds = new RectF();
+
+  /** The bounding image view width used to know the crop overlay is at view edges. */
+  private int mViewWidth;
+
+  /** The bounding image view height used to know the crop overlay is at view edges. */
+  private int mViewHeight;
+
+  /** The offset to draw the border corener from the border */
+  private float mBorderCornerOffset;
+
+  /** the length of the border corner to draw */
+  private float mBorderCornerLength;
+
+  /** The initial crop window padding from image borders */
+  private float mInitialCropWindowPaddingRatio;
+
+  /** The radius of the touch zone (in pixels) around a given Handle. */
+  private float mTouchRadius;
+
+  /**
+   * An edge of the crop window will snap to the corresponding edge of a specified bounding box when
+   * the crop window edge is less than or equal to this distance (in pixels) away from the bounding
+   * box edge.
+   */
+  private float mSnapRadius;
+
+  /** The Handle that is currently pressed; null if no Handle is pressed. */
+  private CropWindowMoveHandler mMoveHandler;
+
+  /**
+   * Flag indicating if the crop area should always be a certain aspect ratio (indicated by
+   * mTargetAspectRatio).
+   */
+  private boolean mFixAspectRatio;
+
+  /** save the current aspect ratio of the image */
+  private int mAspectRatioX;
+
+  /** save the current aspect ratio of the image */
+  private int mAspectRatioY;
+
+  /**
+   * The aspect ratio that the crop area should maintain; this variable is only used when
+   * mMaintainAspectRatio is true.
+   */
+  private float mTargetAspectRatio = ((float) mAspectRatioX) / mAspectRatioY;
+
+  /** Instance variables for customizable attributes */
+  private CropImageView.Guidelines mGuidelines;
+
+  /** The shape of the cropping area - rectangle/circular. */
+  private CropImageView.CropShape mCropShape;
+
+  /** the initial crop window rectangle to set */
+  private final Rect mInitialCropWindowRect = new Rect();
+
+  /** Whether the Crop View has been initialized for the first time */
+  private boolean initializedCropWindow;
+
+  /** Used to set back LayerType after changing to software. */
+  private Integer mOriginalLayerType;
+  // endregion
+
+  public CropOverlayView(Context context) {
+    this(context, null);
+  }
+
+  public CropOverlayView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  /** Set the crop window change listener. */
+  public void setCropWindowChangeListener(CropWindowChangeListener listener) {
+    mCropWindowChangeListener = listener;
+  }
+
+  /** Get the left/top/right/bottom coordinates of the crop window. */
+  public RectF getCropWindowRect() {
+    return mCropWindowHandler.getRect();
+  }
+
+  /** Set the left/top/right/bottom coordinates of the crop window. */
+  public void setCropWindowRect(RectF rect) {
+    mCropWindowHandler.setRect(rect);
+  }
+
+  /** Fix the current crop window rectangle if it is outside of cropping image or view bounds. */
+  public void fixCurrentCropWindowRect() {
+    RectF rect = getCropWindowRect();
+    fixCropWindowRectByRules(rect);
+    mCropWindowHandler.setRect(rect);
+  }
+
+  /**
+   * Informs the CropOverlayView of the image's position relative to the ImageView. This is
+   * necessary to call in order to draw the crop window.
+   *
+   * @param boundsPoints the image's bounding points
+   * @param viewWidth The bounding image view width.
+   * @param viewHeight The bounding image view height.
+   */
+  public void setBounds(float[] boundsPoints, int viewWidth, int viewHeight) {
+    if (boundsPoints == null || !Arrays.equals(mBoundsPoints, boundsPoints)) {
+      if (boundsPoints == null) {
+        Arrays.fill(mBoundsPoints, 0);
+      } else {
+        System.arraycopy(boundsPoints, 0, mBoundsPoints, 0, boundsPoints.length);
+      }
+      mViewWidth = viewWidth;
+      mViewHeight = viewHeight;
+      RectF cropRect = mCropWindowHandler.getRect();
+      if (cropRect.width() == 0 || cropRect.height() == 0) {
+        initCropWindow();
+      }
+    }
+  }
+
+  /** Resets the crop overlay view. */
+  public void resetCropOverlayView() {
+    if (initializedCropWindow) {
+      setCropWindowRect(BitmapUtils.EMPTY_RECT_F);
+      initCropWindow();
+      invalidate();
+    }
+  }
+
+  /** The shape of the cropping area - rectangle/circular. */
+  public CropImageView.CropShape getCropShape() {
+    return mCropShape;
+  }
+
+  /** The shape of the cropping area - rectangle/circular. */
+  public void setCropShape(CropImageView.CropShape cropShape) {
+    if (mCropShape != cropShape) {
+      mCropShape = cropShape;
+        if (Build.VERSION.SDK_INT <= 17) {
+        if (mCropShape == CropImageView.CropShape.OVAL) {
+          mOriginalLayerType = getLayerType();
+          if (mOriginalLayerType != View.LAYER_TYPE_SOFTWARE) {
+            // TURN off hardware acceleration
+            setLayerType(View.LAYER_TYPE_SOFTWARE, null);
+          } else {
+            mOriginalLayerType = null;
+          }
+        } else if (mOriginalLayerType != null) {
+          // return hardware acceleration back
+          setLayerType(mOriginalLayerType, null);
+          mOriginalLayerType = null;
+        }
+      }
+      invalidate();
+    }
+  }
+
+  /** Get the current guidelines option set. */
+  public CropImageView.Guidelines getGuidelines() {
+    return mGuidelines;
+  }
+
+  /**
+   * Sets the guidelines for the CropOverlayView to be either on, off, or to show when resizing the
+   * application.
+   */
+  public void setGuidelines(CropImageView.Guidelines guidelines) {
+    if (mGuidelines != guidelines) {
+      mGuidelines = guidelines;
+      if (initializedCropWindow) {
+        invalidate();
+      }
+    }
+  }
+
+  /**
+   * whether the aspect ratio is fixed or not; true fixes the aspect ratio, while false allows it to
+   * be changed.
+   */
+  public boolean isFixAspectRatio() {
+    return mFixAspectRatio;
+  }
+
+  /**
+   * Sets whether the aspect ratio is fixed or not; true fixes the aspect ratio, while false allows
+   * it to be changed.
+   */
+  public void setFixedAspectRatio(boolean fixAspectRatio) {
+    if (mFixAspectRatio != fixAspectRatio) {
+      mFixAspectRatio = fixAspectRatio;
+      if (initializedCropWindow) {
+        initCropWindow();
+        invalidate();
+      }
+    }
+  }
+
+  /** the X value of the aspect ratio; */
+  public int getAspectRatioX() {
+    return mAspectRatioX;
+  }
+
+  /** Sets the X value of the aspect ratio; is defaulted to 1. */
+  public void setAspectRatioX(int aspectRatioX) {
+    if (aspectRatioX <= 0) {
+      throw new IllegalArgumentException(
+          "Cannot set aspect ratio value to a number less than or equal to 0.");
+    } else if (mAspectRatioX != aspectRatioX) {
+      mAspectRatioX = aspectRatioX;
+      mTargetAspectRatio = ((float) mAspectRatioX) / mAspectRatioY;
+
+      if (initializedCropWindow) {
+        initCropWindow();
+        invalidate();
+      }
+    }
+  }
+
+  /** the Y value of the aspect ratio; */
+  public int getAspectRatioY() {
+    return mAspectRatioY;
+  }
+
+  /**
+   * Sets the Y value of the aspect ratio; is defaulted to 1.
+   *
+   * @param aspectRatioY int that specifies the new Y value of the aspect ratio
+   */
+  public void setAspectRatioY(int aspectRatioY) {
+    if (aspectRatioY <= 0) {
+      throw new IllegalArgumentException(
+          "Cannot set aspect ratio value to a number less than or equal to 0.");
+    } else if (mAspectRatioY != aspectRatioY) {
+      mAspectRatioY = aspectRatioY;
+      mTargetAspectRatio = ((float) mAspectRatioX) / mAspectRatioY;
+
+      if (initializedCropWindow) {
+        initCropWindow();
+        invalidate();
+      }
+    }
+  }
+
+  /**
+   * An edge of the crop window will snap to the corresponding edge of a specified bounding box when
+   * the crop window edge is less than or equal to this distance (in pixels) away from the bounding
+   * box edge. (default: 3)
+   */
+  public void setSnapRadius(float snapRadius) {
+    mSnapRadius = snapRadius;
+  }
+
+  /** Set multi touch functionality to enabled/disabled. */
+  public boolean setMultiTouchEnabled(boolean multiTouchEnabled) {
+      if (mMultiTouchEnabled != multiTouchEnabled) {
+      mMultiTouchEnabled = multiTouchEnabled;
+      if (mMultiTouchEnabled && mScaleDetector == null) {
+        mScaleDetector = new ScaleGestureDetector(getContext(), new ScaleListener());
+      }
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * the min size the resulting cropping image is allowed to be, affects the cropping window limits
+   * (in pixels).<br>
+   */
+  public void setMinCropResultSize(int minCropResultWidth, int minCropResultHeight) {
+    mCropWindowHandler.setMinCropResultSize(minCropResultWidth, minCropResultHeight);
+  }
+
+  /**
+   * the max size the resulting cropping image is allowed to be, affects the cropping window limits
+   * (in pixels).<br>
+   */
+  public void setMaxCropResultSize(int maxCropResultWidth, int maxCropResultHeight) {
+    mCropWindowHandler.setMaxCropResultSize(maxCropResultWidth, maxCropResultHeight);
+  }
+
+  /**
+   * set the max width/height and scale factor of the shown image to original image to scale the
+   * limits appropriately.
+   */
+  public void setCropWindowLimits(
+      float maxWidth, float maxHeight, float scaleFactorWidth, float scaleFactorHeight) {
+    mCropWindowHandler.setCropWindowLimits(
+        maxWidth, maxHeight, scaleFactorWidth, scaleFactorHeight);
+  }
+
+  /** Get crop window initial rectangle. */
+  public Rect getInitialCropWindowRect() {
+    return mInitialCropWindowRect;
+  }
+
+  /** Set crop window initial rectangle to be used instead of default. */
+  public void setInitialCropWindowRect(Rect rect) {
+    mInitialCropWindowRect.set(rect != null ? rect : BitmapUtils.EMPTY_RECT);
+    if (initializedCropWindow) {
+      initCropWindow();
+      invalidate();
+      callOnCropWindowChanged(false);
+    }
+  }
+
+  /** Reset crop window to initial rectangle. */
+  public void resetCropWindowRect() {
+    if (initializedCropWindow) {
+      initCropWindow();
+      invalidate();
+      callOnCropWindowChanged(false);
+    }
+  }
+
+  /**
+   * Sets all initial values, but does not call initCropWindow to reset the views.<br>
+   * Used once at the very start to initialize the attributes.
+   */
+  public void setInitialAttributeValues(CropImageOptions options) {
+
+    mCropWindowHandler.setInitialAttributeValues(options);
+
+    setCropShape(options.cropShape);
+
+    setSnapRadius(options.snapRadius);
+
+    setGuidelines(options.guidelines);
+
+    setFixedAspectRatio(options.fixAspectRatio);
+
+    setAspectRatioX(options.aspectRatioX);
+
+    setAspectRatioY(options.aspectRatioY);
+
+    setMultiTouchEnabled(options.multiTouchEnabled);
+
+    mTouchRadius = options.touchRadius;
+
+    mInitialCropWindowPaddingRatio = options.initialCropWindowPaddingRatio;
+
+    mBorderPaint = getNewPaintOrNull(options.borderLineThickness, options.borderLineColor);
+
+    mBorderCornerOffset = options.borderCornerOffset;
+    mBorderCornerLength = options.borderCornerLength;
+    mBorderCornerPaint =
+        getNewPaintOrNull(options.borderCornerThickness, options.borderCornerColor);
+
+    mGuidelinePaint = getNewPaintOrNull(options.guidelinesThickness, options.guidelinesColor);
+
+    mBackgroundPaint = getNewPaint(options.backgroundColor);
+  }
+
+  // region: Private methods
+
+  /**
+   * Set the initial crop window size and position. This is dependent on the size and position of
+   * the image being cropped.
+   */
+  private void initCropWindow() {
+
+    float leftLimit = Math.max(BitmapUtils.getRectLeft(mBoundsPoints), 0);
+    float topLimit = Math.max(BitmapUtils.getRectTop(mBoundsPoints), 0);
+    float rightLimit = Math.min(BitmapUtils.getRectRight(mBoundsPoints), getWidth());
+    float bottomLimit = Math.min(BitmapUtils.getRectBottom(mBoundsPoints), getHeight());
+
+    if (rightLimit <= leftLimit || bottomLimit <= topLimit) {
+      return;
+    }
+
+    RectF rect = new RectF();
+
+    // Tells the attribute functions the crop window has already been initialized
+    initializedCropWindow = true;
+
+    float horizontalPadding = mInitialCropWindowPaddingRatio * (rightLimit - leftLimit);
+    float verticalPadding = mInitialCropWindowPaddingRatio * (bottomLimit - topLimit);
+
+    if (mInitialCropWindowRect.width() > 0 && mInitialCropWindowRect.height() > 0) {
+      // Get crop window position relative to the displayed image.
+      rect.left =
+          leftLimit + mInitialCropWindowRect.left / mCropWindowHandler.getScaleFactorWidth();
+      rect.top = topLimit + mInitialCropWindowRect.top / mCropWindowHandler.getScaleFactorHeight();
+      rect.right =
+          rect.left + mInitialCropWindowRect.width() / mCropWindowHandler.getScaleFactorWidth();
+      rect.bottom =
+          rect.top + mInitialCropWindowRect.height() / mCropWindowHandler.getScaleFactorHeight();
+
+      // Correct for floating point errors. Crop rect boundaries should not exceed the source Bitmap
+      // bounds.
+      rect.left = Math.max(leftLimit, rect.left);
+      rect.top = Math.max(topLimit, rect.top);
+      rect.right = Math.min(rightLimit, rect.right);
+      rect.bottom = Math.min(bottomLimit, rect.bottom);
+
+    } else if (mFixAspectRatio && rightLimit > leftLimit && bottomLimit > topLimit) {
+
+      // If the image aspect ratio is wider than the crop aspect ratio,
+      // then the image height is the determining initial length. Else, vice-versa.
+      float bitmapAspectRatio = (rightLimit - leftLimit) / (bottomLimit - topLimit);
+      if (bitmapAspectRatio > mTargetAspectRatio) {
+
+        rect.top = topLimit + verticalPadding;
+        rect.bottom = bottomLimit - verticalPadding;
+
+        float centerX = getWidth() / 2f;
+
+        // dirty fix for wrong crop overlay aspect ratio when using fixed aspect ratio
+        mTargetAspectRatio = (float) mAspectRatioX / mAspectRatioY;
+
+        // Limits the aspect ratio to no less than 40 wide or 40 tall
+        float cropWidth =
+            Math.max(mCropWindowHandler.getMinCropWidth(), rect.height() * mTargetAspectRatio);
+
+        float halfCropWidth = cropWidth / 2f;
+        rect.left = centerX - halfCropWidth;
+        rect.right = centerX + halfCropWidth;
+
+      } else {
+
+        rect.left = leftLimit + horizontalPadding;
+        rect.right = rightLimit - horizontalPadding;
+
+        float centerY = getHeight() / 2f;
+
+        // Limits the aspect ratio to no less than 40 wide or 40 tall
+        float cropHeight =
+            Math.max(mCropWindowHandler.getMinCropHeight(), rect.width() / mTargetAspectRatio);
+
+        float halfCropHeight = cropHeight / 2f;
+        rect.top = centerY - halfCropHeight;
+        rect.bottom = centerY + halfCropHeight;
+      }
+    } else {
+      // Initialize crop window to have 10% padding w/ respect to image.
+      rect.left = leftLimit + horizontalPadding;
+      rect.top = topLimit + verticalPadding;
+      rect.right = rightLimit - horizontalPadding;
+      rect.bottom = bottomLimit - verticalPadding;
+    }
+
+    fixCropWindowRectByRules(rect);
+
+    mCropWindowHandler.setRect(rect);
+  }
+
+  /** Fix the given rect to fit into bitmap rect and follow min, max and aspect ratio rules. */
+  private void fixCropWindowRectByRules(RectF rect) {
+    if (rect.width() < mCropWindowHandler.getMinCropWidth()) {
+      float adj = (mCropWindowHandler.getMinCropWidth() - rect.width()) / 2;
+      rect.left -= adj;
+      rect.right += adj;
+    }
+    if (rect.height() < mCropWindowHandler.getMinCropHeight()) {
+      float adj = (mCropWindowHandler.getMinCropHeight() - rect.height()) / 2;
+      rect.top -= adj;
+      rect.bottom += adj;
+    }
+    if (rect.width() > mCropWindowHandler.getMaxCropWidth()) {
+      float adj = (rect.width() - mCropWindowHandler.getMaxCropWidth()) / 2;
+      rect.left += adj;
+      rect.right -= adj;
+    }
+    if (rect.height() > mCropWindowHandler.getMaxCropHeight()) {
+      float adj = (rect.height() - mCropWindowHandler.getMaxCropHeight()) / 2;
+      rect.top += adj;
+      rect.bottom -= adj;
+    }
+
+    calculateBounds(rect);
+    if (mCalcBounds.width() > 0 && mCalcBounds.height() > 0) {
+      float leftLimit = Math.max(mCalcBounds.left, 0);
+      float topLimit = Math.max(mCalcBounds.top, 0);
+      float rightLimit = Math.min(mCalcBounds.right, getWidth());
+      float bottomLimit = Math.min(mCalcBounds.bottom, getHeight());
+      if (rect.left < leftLimit) {
+        rect.left = leftLimit;
+      }
+      if (rect.top < topLimit) {
+        rect.top = topLimit;
+      }
+      if (rect.right > rightLimit) {
+        rect.right = rightLimit;
+      }
+      if (rect.bottom > bottomLimit) {
+        rect.bottom = bottomLimit;
+      }
+    }
+    if (mFixAspectRatio && Math.abs(rect.width() - rect.height() * mTargetAspectRatio) > 0.1) {
+      if (rect.width() > rect.height() * mTargetAspectRatio) {
+        float adj = Math.abs(rect.height() * mTargetAspectRatio - rect.width()) / 2;
+        rect.left += adj;
+        rect.right -= adj;
+      } else {
+        float adj = Math.abs(rect.width() / mTargetAspectRatio - rect.height()) / 2;
+        rect.top += adj;
+        rect.bottom -= adj;
+      }
+    }
+  }
+
+  /**
+   * Draw crop overview by drawing background over image not in the cripping area, then borders and
+   * guidelines.
+   */
+  @Override
+  protected void onDraw(Canvas canvas) {
+
+    super.onDraw(canvas);
+
+    // Draw translucent background for the cropped area.
+    drawBackground(canvas);
+
+    if (mCropWindowHandler.showGuidelines()) {
+      // Determines whether guidelines should be drawn or not
+      if (mGuidelines == CropImageView.Guidelines.ON) {
+        drawGuidelines(canvas);
+      } else if (mGuidelines == CropImageView.Guidelines.ON_TOUCH && mMoveHandler != null) {
+        // Draw only when resizing
+        drawGuidelines(canvas);
+      }
+    }
+
+    drawBorders(canvas);
+
+    drawCorners(canvas);
+  }
+
+  /** Draw shadow background over the image not including the crop area. */
+  private void drawBackground(Canvas canvas) {
+
+    RectF rect = mCropWindowHandler.getRect();
+
+    float left = Math.max(BitmapUtils.getRectLeft(mBoundsPoints), 0);
+    float top = Math.max(BitmapUtils.getRectTop(mBoundsPoints), 0);
+    float right = Math.min(BitmapUtils.getRectRight(mBoundsPoints), getWidth());
+    float bottom = Math.min(BitmapUtils.getRectBottom(mBoundsPoints), getHeight());
+
+    if (mCropShape == CropImageView.CropShape.RECTANGLE) {
+      if (!isNonStraightAngleRotated() || Build.VERSION.SDK_INT <= 17) {
+        canvas.drawRect(left, top, right, rect.top, mBackgroundPaint);
+        canvas.drawRect(left, rect.bottom, right, bottom, mBackgroundPaint);
+        canvas.drawRect(left, rect.top, rect.left, rect.bottom, mBackgroundPaint);
+        canvas.drawRect(rect.right, rect.top, right, rect.bottom, mBackgroundPaint);
+      } else {
+        mPath.reset();
+        mPath.moveTo(mBoundsPoints[0], mBoundsPoints[1]);
+        mPath.lineTo(mBoundsPoints[2], mBoundsPoints[3]);
+        mPath.lineTo(mBoundsPoints[4], mBoundsPoints[5]);
+        mPath.lineTo(mBoundsPoints[6], mBoundsPoints[7]);
+        mPath.close();
+
+        canvas.save();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+          canvas.clipOutPath(mPath);
+        } else {
+          canvas.clipPath(mPath, Region.Op.INTERSECT);
+        }
+        canvas.clipRect(rect, Region.Op.XOR);
+        canvas.drawRect(left, top, right, bottom, mBackgroundPaint);
+        canvas.restore();
+      }
+    } else {
+      mPath.reset();
+        if (Build.VERSION.SDK_INT <= 17 && mCropShape == CropImageView.CropShape.OVAL) {
+        mDrawRect.set(rect.left + 2, rect.top + 2, rect.right - 2, rect.bottom - 2);
+      } else {
+        mDrawRect.set(rect.left, rect.top, rect.right, rect.bottom);
+      }
+      mPath.addOval(mDrawRect, Path.Direction.CW);
+      canvas.save();
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+        canvas.clipOutPath(mPath);
+      } else {
+        canvas.clipPath(mPath, Region.Op.XOR);
+      }
+      canvas.drawRect(left, top, right, bottom, mBackgroundPaint);
+      canvas.restore();
+    }
+  }
+
+  /**
+   * Draw 2 veritcal and 2 horizontal guidelines inside the cropping area to split it into 9 equal
+   * parts.
+   */
+  private void drawGuidelines(Canvas canvas) {
+    if (mGuidelinePaint != null) {
+      float sw = mBorderPaint != null ? mBorderPaint.getStrokeWidth() : 0;
+      RectF rect = mCropWindowHandler.getRect();
+      rect.inset(sw, sw);
+
+      float oneThirdCropWidth = rect.width() / 3;
+      float oneThirdCropHeight = rect.height() / 3;
+
+      if (mCropShape == CropImageView.CropShape.OVAL) {
+
+        float w = rect.width() / 2 - sw;
+        float h = rect.height() / 2 - sw;
+
+        // Draw vertical guidelines.
+        float x1 = rect.left + oneThirdCropWidth;
+        float x2 = rect.right - oneThirdCropWidth;
+        float yv = (float) (h * Math.sin(Math.acos((w - oneThirdCropWidth) / w)));
+        canvas.drawLine(x1, rect.top + h - yv, x1, rect.bottom - h + yv, mGuidelinePaint);
+        canvas.drawLine(x2, rect.top + h - yv, x2, rect.bottom - h + yv, mGuidelinePaint);
+
+        // Draw horizontal guidelines.
+        float y1 = rect.top + oneThirdCropHeight;
+        float y2 = rect.bottom - oneThirdCropHeight;
+        float xv = (float) (w * Math.cos(Math.asin((h - oneThirdCropHeight) / h)));
+        canvas.drawLine(rect.left + w - xv, y1, rect.right - w + xv, y1, mGuidelinePaint);
+        canvas.drawLine(rect.left + w - xv, y2, rect.right - w + xv, y2, mGuidelinePaint);
+      } else {
+
+        // Draw vertical guidelines.
+        float x1 = rect.left + oneThirdCropWidth;
+        float x2 = rect.right - oneThirdCropWidth;
+        canvas.drawLine(x1, rect.top, x1, rect.bottom, mGuidelinePaint);
+        canvas.drawLine(x2, rect.top, x2, rect.bottom, mGuidelinePaint);
+
+        // Draw horizontal guidelines.
+        float y1 = rect.top + oneThirdCropHeight;
+        float y2 = rect.bottom - oneThirdCropHeight;
+        canvas.drawLine(rect.left, y1, rect.right, y1, mGuidelinePaint);
+        canvas.drawLine(rect.left, y2, rect.right, y2, mGuidelinePaint);
+      }
+    }
+  }
+
+  /** Draw borders of the crop area. */
+  private void drawBorders(Canvas canvas) {
+    if (mBorderPaint != null) {
+      float w = mBorderPaint.getStrokeWidth();
+      RectF rect = mCropWindowHandler.getRect();
+      rect.inset(w / 2, w / 2);
+
+      if (mCropShape == CropImageView.CropShape.RECTANGLE) {
+        // Draw rectangle crop window border.
+        canvas.drawRect(rect, mBorderPaint);
+      } else {
+        // Draw circular crop window border
+        canvas.drawOval(rect, mBorderPaint);
+      }
+    }
+  }
+
+  /** Draw the corner of crop overlay. */
+  private void drawCorners(Canvas canvas) {
+    if (mBorderCornerPaint != null) {
+
+      float lineWidth = mBorderPaint != null ? mBorderPaint.getStrokeWidth() : 0;
+      float cornerWidth = mBorderCornerPaint.getStrokeWidth();
+
+      // for rectangle crop shape we allow the corners to be offset from the borders
+      float w =
+          cornerWidth / 2
+              + (mCropShape == CropImageView.CropShape.RECTANGLE ? mBorderCornerOffset : 0);
+
+      RectF rect = mCropWindowHandler.getRect();
+      rect.inset(w, w);
+
+      float cornerOffset = (cornerWidth - lineWidth) / 2;
+      float cornerExtension = cornerWidth / 2 + cornerOffset;
+
+      // Top left
+      canvas.drawLine(
+          rect.left - cornerOffset,
+          rect.top - cornerExtension,
+          rect.left - cornerOffset,
+          rect.top + mBorderCornerLength,
+          mBorderCornerPaint);
+      canvas.drawLine(
+          rect.left - cornerExtension,
+          rect.top - cornerOffset,
+          rect.left + mBorderCornerLength,
+          rect.top - cornerOffset,
+          mBorderCornerPaint);
+
+      // Top right
+      canvas.drawLine(
+          rect.right + cornerOffset,
+          rect.top - cornerExtension,
+          rect.right + cornerOffset,
+          rect.top + mBorderCornerLength,
+          mBorderCornerPaint);
+      canvas.drawLine(
+          rect.right + cornerExtension,
+          rect.top - cornerOffset,
+          rect.right - mBorderCornerLength,
+          rect.top - cornerOffset,
+          mBorderCornerPaint);
+
+      // Bottom left
+      canvas.drawLine(
+          rect.left - cornerOffset,
+          rect.bottom + cornerExtension,
+          rect.left - cornerOffset,
+          rect.bottom - mBorderCornerLength,
+          mBorderCornerPaint);
+      canvas.drawLine(
+          rect.left - cornerExtension,
+          rect.bottom + cornerOffset,
+          rect.left + mBorderCornerLength,
+          rect.bottom + cornerOffset,
+          mBorderCornerPaint);
+
+      // Bottom left
+      canvas.drawLine(
+          rect.right + cornerOffset,
+          rect.bottom + cornerExtension,
+          rect.right + cornerOffset,
+          rect.bottom - mBorderCornerLength,
+          mBorderCornerPaint);
+      canvas.drawLine(
+          rect.right + cornerExtension,
+          rect.bottom + cornerOffset,
+          rect.right - mBorderCornerLength,
+          rect.bottom + cornerOffset,
+          mBorderCornerPaint);
+    }
+  }
+
+  /** Creates the Paint object for drawing. */
+  private static Paint getNewPaint(int color) {
+    Paint paint = new Paint();
+    paint.setColor(color);
+    return paint;
+  }
+
+  /** Creates the Paint object for given thickness and color, if thickness < 0 return null. */
+  private static Paint getNewPaintOrNull(float thickness, int color) {
+    if (thickness > 0) {
+      Paint borderPaint = new Paint();
+      borderPaint.setColor(color);
+      borderPaint.setStrokeWidth(thickness);
+      borderPaint.setStyle(Paint.Style.STROKE);
+      borderPaint.setAntiAlias(true);
+      return borderPaint;
+    } else {
+      return null;
+    }
+  }
+
+  @Override
+  public boolean onTouchEvent(MotionEvent event) {
+    // If this View is not enabled, don't allow for touch interactions.
+    if (isEnabled()) {
+      if (mMultiTouchEnabled) {
+        mScaleDetector.onTouchEvent(event);
+      }
+
+      switch (event.getAction()) {
+        case MotionEvent.ACTION_DOWN:
+          onActionDown(event.getX(), event.getY());
+          return true;
+        case MotionEvent.ACTION_UP:
+        case MotionEvent.ACTION_CANCEL:
+          getParent().requestDisallowInterceptTouchEvent(false);
+          onActionUp();
+          return true;
+        case MotionEvent.ACTION_MOVE:
+          onActionMove(event.getX(), event.getY());
+          getParent().requestDisallowInterceptTouchEvent(true);
+          return true;
+        default:
+          return false;
+      }
+    } else {
+      return false;
+    }
+  }
+
+  /**
+   * On press down start crop window movment depending on the location of the press.<br>
+   * if press is far from crop window then no move handler is returned (null).
+   */
+  private void onActionDown(float x, float y) {
+    mMoveHandler = mCropWindowHandler.getMoveHandler(x, y, mTouchRadius, mCropShape);
+    if (mMoveHandler != null) {
+      invalidate();
+    }
+  }
+
+  /** Clear move handler starting in {@link #onActionDown(float, float)} if exists. */
+  private void onActionUp() {
+    if (mMoveHandler != null) {
+      mMoveHandler = null;
+      callOnCropWindowChanged(false);
+      invalidate();
+    }
+  }
+
+  /**
+   * Handle move of crop window using the move handler created in {@link #onActionDown(float,
+   * float)}.<br>
+   * The move handler will do the proper move/resize of the crop window.
+   */
+  private void onActionMove(float x, float y) {
+    if (mMoveHandler != null) {
+      float snapRadius = mSnapRadius;
+      RectF rect = mCropWindowHandler.getRect();
+
+      if (calculateBounds(rect)) {
+        snapRadius = 0;
+      }
+
+      mMoveHandler.move(
+          rect,
+          x,
+          y,
+          mCalcBounds,
+          mViewWidth,
+          mViewHeight,
+          snapRadius,
+          mFixAspectRatio,
+          mTargetAspectRatio);
+      mCropWindowHandler.setRect(rect);
+      callOnCropWindowChanged(true);
+      invalidate();
+    }
+  }
+
+  /**
+   * Calculate the bounding rectangle for current crop window, handle non-straight rotation angles.
+   * <br>
+   * If the rotation angle is straight then the bounds rectangle is the bitmap rectangle, otherwsie
+   * we find the max rectangle that is within the image bounds starting from the crop window
+   * rectangle.
+   *
+   * @param rect the crop window rectangle to start finsing bounded rectangle from
+   * @return true - non straight rotation in place, false - otherwise.
+   */
+  private boolean calculateBounds(RectF rect) {
+
+    float left = BitmapUtils.getRectLeft(mBoundsPoints);
+    float top = BitmapUtils.getRectTop(mBoundsPoints);
+    float right = BitmapUtils.getRectRight(mBoundsPoints);
+    float bottom = BitmapUtils.getRectBottom(mBoundsPoints);
+
+    if (!isNonStraightAngleRotated()) {
+      mCalcBounds.set(left, top, right, bottom);
+      return false;
+    } else {
+      float x0 = mBoundsPoints[0];
+      float y0 = mBoundsPoints[1];
+      float x2 = mBoundsPoints[4];
+      float y2 = mBoundsPoints[5];
+      float x3 = mBoundsPoints[6];
+      float y3 = mBoundsPoints[7];
+
+      if (mBoundsPoints[7] < mBoundsPoints[1]) {
+        if (mBoundsPoints[1] < mBoundsPoints[3]) {
+          x0 = mBoundsPoints[6];
+          y0 = mBoundsPoints[7];
+          x2 = mBoundsPoints[2];
+          y2 = mBoundsPoints[3];
+          x3 = mBoundsPoints[4];
+          y3 = mBoundsPoints[5];
+        } else {
+          x0 = mBoundsPoints[4];
+          y0 = mBoundsPoints[5];
+          x2 = mBoundsPoints[0];
+          y2 = mBoundsPoints[1];
+          x3 = mBoundsPoints[2];
+          y3 = mBoundsPoints[3];
+        }
+      } else if (mBoundsPoints[1] > mBoundsPoints[3]) {
+        x0 = mBoundsPoints[2];
+        y0 = mBoundsPoints[3];
+        x2 = mBoundsPoints[6];
+        y2 = mBoundsPoints[7];
+        x3 = mBoundsPoints[0];
+        y3 = mBoundsPoints[1];
+      }
+
+      float a0 = (y3 - y0) / (x3 - x0);
+      float a1 = -1f / a0;
+      float b0 = y0 - a0 * x0;
+      float b1 = y0 - a1 * x0;
+      float b2 = y2 - a0 * x2;
+      float b3 = y2 - a1 * x2;
+
+      float c0 = (rect.centerY() - rect.top) / (rect.centerX() - rect.left);
+      float c1 = -c0;
+      float d0 = rect.top - c0 * rect.left;
+      float d1 = rect.top - c1 * rect.right;
+
+      left = Math.max(left, (d0 - b0) / (a0 - c0) < rect.right ? (d0 - b0) / (a0 - c0) : left);
+      left = Math.max(left, (d0 - b1) / (a1 - c0) < rect.right ? (d0 - b1) / (a1 - c0) : left);
+      left = Math.max(left, (d1 - b3) / (a1 - c1) < rect.right ? (d1 - b3) / (a1 - c1) : left);
+      right = Math.min(right, (d1 - b1) / (a1 - c1) > rect.left ? (d1 - b1) / (a1 - c1) : right);
+      right = Math.min(right, (d1 - b2) / (a0 - c1) > rect.left ? (d1 - b2) / (a0 - c1) : right);
+      right = Math.min(right, (d0 - b2) / (a0 - c0) > rect.left ? (d0 - b2) / (a0 - c0) : right);
+
+      top = Math.max(top, Math.max(a0 * left + b0, a1 * right + b1));
+      bottom = Math.min(bottom, Math.min(a1 * left + b3, a0 * right + b2));
+
+      mCalcBounds.left = left;
+      mCalcBounds.top = top;
+      mCalcBounds.right = right;
+      mCalcBounds.bottom = bottom;
+      return true;
+    }
+  }
+
+  /** Is the cropping image has been rotated by NOT 0,90,180 or 270 degrees. */
+  private boolean isNonStraightAngleRotated() {
+    return mBoundsPoints[0] != mBoundsPoints[6] && mBoundsPoints[1] != mBoundsPoints[7];
+  }
+
+  /** Invoke on crop change listener safe, don't let the app crash on exception. */
+  private void callOnCropWindowChanged(boolean inProgress) {
+    try {
+      if (mCropWindowChangeListener != null) {
+        mCropWindowChangeListener.onCropWindowChanged(inProgress);
+      }
+    } catch (Exception e) {
+      Log.e("AIC", "Exception in crop window changed", e);
+    }
+  }
+  // endregion
+
+  // region: Inner class: CropWindowChangeListener
+
+  /** Interface definition for a callback to be invoked when crop window rectangle is changing. */
+  public interface CropWindowChangeListener {
+
+    /**
+     * Called after a change in crop window rectangle.
+     *
+     * @param inProgress is the crop window change operation is still in progress by user touch
+     */
+    void onCropWindowChanged(boolean inProgress);
+  }
+  // endregion
+
+  // region: Inner class: ScaleListener
+
+  /** Handle scaling the rectangle based on two finger input */
+  private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {
+
+    @Override
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public boolean onScale(ScaleGestureDetector detector) {
+      RectF rect = mCropWindowHandler.getRect();
+
+      float x = detector.getFocusX();
+      float y = detector.getFocusY();
+      float dY = detector.getCurrentSpanY() / 2;
+      float dX = detector.getCurrentSpanX() / 2;
+
+      float newTop = y - dY;
+      float newLeft = x - dX;
+      float newRight = x + dX;
+      float newBottom = y + dY;
+
+      if (newLeft < newRight
+          && newTop <= newBottom
+          && newLeft >= 0
+          && newRight <= mCropWindowHandler.getMaxCropWidth()
+          && newTop >= 0
+          && newBottom <= mCropWindowHandler.getMaxCropHeight()) {
+
+        rect.set(newLeft, newTop, newRight, newBottom);
+        mCropWindowHandler.setRect(rect);
+        invalidate();
+      }
+
+      return true;
+    }
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageView.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageView.java
new file mode 100644
--- /dev/null	(date 1726418597246)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageView.java	(date 1726418597246)
@@ -0,0 +1,2137 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Parcelable;
+import androidx.exifinterface.media.ExifInterface;
+import android.util.AttributeSet;
+import android.util.Pair;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+
+import com.qboxus.binder.R;
+
+import java.lang.ref.WeakReference;
+import java.util.UUID;
+
+/** Custom view that provides cropping capabilities to an image. */
+public class CropImageView extends FrameLayout {
+
+  // region: Fields and Consts
+
+  /** Image view widget used to show the image for cropping. */
+  private final ImageView mImageView;
+
+  /** Overlay over the image view to show cropping UI. */
+  private final CropOverlayView mCropOverlayView;
+
+  /** The matrix used to transform the cropping image in the image view */
+  private final Matrix mImageMatrix = new Matrix();
+
+  /** Reusing matrix instance for reverse matrix calculations. */
+  private final Matrix mImageInverseMatrix = new Matrix();
+
+  /** Progress bar widget to show progress bar on async image loading and cropping. */
+  private final ProgressBar mProgressBar;
+
+  /** Rectangle used in image matrix transformation calculation (reusing rect instance) */
+  private final float[] mImagePoints = new float[8];
+
+  /** Rectangle used in image matrix transformation for scale calculation (reusing rect instance) */
+  private final float[] mScaleImagePoints = new float[8];
+
+  /** Animation class to smooth animate zoom-in/out */
+  private CropImageAnimation mAnimation;
+
+  private Bitmap mBitmap;
+
+  /** The image rotation value used during loading of the image so we can reset to it */
+  private int mInitialDegreesRotated;
+
+  /** How much the image is rotated from original clockwise */
+  private int mDegreesRotated;
+
+  /** if the image flipped horizontally */
+  private boolean mFlipHorizontally;
+
+  /** if the image flipped vertically */
+  private boolean mFlipVertically;
+
+  private int mLayoutWidth;
+
+  private int mLayoutHeight;
+
+  private int mImageResource;
+
+  /** The initial scale type of the image in the crop image view */
+  private ScaleType mScaleType;
+
+  /**
+   * if to save bitmap on save instance state.<br>
+   * It is best to avoid it by using URI in setting image for cropping.<br>
+   * If false the bitmap is not saved and if restore is required to view will be empty, storing the
+   * bitmap requires saving it to file which can be expensive. default: false.
+   */
+  private boolean mSaveBitmapToInstanceState = false;
+
+  /**
+   * if to show crop overlay UI what contains the crop window UI surrounded by background over the
+   * cropping image.<br>
+   * default: true, may disable for animation or frame transition.
+   */
+  private boolean mShowCropOverlay = true;
+
+  /**
+   * if to show progress bar when image async loading/cropping is in progress.<br>
+   * default: true, disable to provide custom progress bar UI.
+   */
+  private boolean mShowProgressBar = true;
+
+  /**
+   * if auto-zoom functionality is enabled.<br>
+   * default: true.
+   */
+  private boolean mAutoZoomEnabled = true;
+
+  /** The max zoom allowed during cropping */
+  private int mMaxZoom;
+
+  /** callback to be invoked when crop overlay is released. */
+  private OnSetCropOverlayReleasedListener mOnCropOverlayReleasedListener;
+
+  /** callback to be invoked when crop overlay is moved. */
+  private OnSetCropOverlayMovedListener mOnSetCropOverlayMovedListener;
+
+  /** callback to be invoked when crop window is changed. */
+  private OnSetCropWindowChangeListener mOnSetCropWindowChangeListener;
+
+  /** callback to be invoked when image async loading is complete. */
+  private OnSetImageUriCompleteListener mOnSetImageUriCompleteListener;
+
+  /** callback to be invoked when image async cropping is complete. */
+  private OnCropImageCompleteListener mOnCropImageCompleteListener;
+
+  /** The URI that the image was loaded from (if loaded from URI) */
+  private Uri mLoadedImageUri;
+
+  /** The sample size the image was loaded by if was loaded by URI */
+  private int mLoadedSampleSize = 1;
+
+  /** The current zoom level to to scale the cropping image */
+  private float mZoom = 1;
+
+  /** The X offset that the cropping image was translated after zooming */
+  private float mZoomOffsetX;
+
+  /** The Y offset that the cropping image was translated after zooming */
+  private float mZoomOffsetY;
+
+  /** Used to restore the cropping windows rectangle after state restore */
+  private RectF mRestoreCropWindowRect;
+
+  /** Used to restore image rotation after state restore */
+  private int mRestoreDegreesRotated;
+
+  /**
+   * Used to detect size change to handle auto-zoom using {@link #handleCropWindowChanged(boolean,
+   * boolean)} in {@link #layout(int, int, int, int)}.
+   */
+  private boolean mSizeChanged;
+
+  /**
+   * Temp URI used to save bitmap image to disk to preserve for instance state in case cropped was
+   * set with bitmap
+   */
+  private Uri mSaveInstanceStateBitmapUri;
+
+  /** Task used to load bitmap async from UI thread */
+  private WeakReference<BitmapLoadingWorkerTask> mBitmapLoadingWorkerTask;
+
+  /** Task used to crop bitmap async from UI thread */
+  private WeakReference<BitmapCroppingWorkerTask> mBitmapCroppingWorkerTask;
+  // endregion
+
+  public CropImageView(Context context) {
+    this(context, null);
+  }
+
+  public CropImageView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+
+    CropImageOptions options = null;
+    Intent intent = context instanceof Activity ? ((Activity) context).getIntent() : null;
+    if (intent != null) {
+      Bundle bundle = intent.getBundleExtra(CropImage.CROP_IMAGE_EXTRA_BUNDLE);
+      if (bundle != null) {
+        options = bundle.getParcelable(CropImage.CROP_IMAGE_EXTRA_OPTIONS);
+      }
+    }
+
+    if (options == null) {
+
+      options = new CropImageOptions();
+
+      if (attrs != null) {
+        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.CropImageView, 0, 0);
+        try {
+          options.fixAspectRatio =
+              ta.getBoolean(R.styleable.CropImageView_cropFixAspectRatio, options.fixAspectRatio);
+          options.aspectRatioX =
+              ta.getInteger(R.styleable.CropImageView_cropAspectRatioX, options.aspectRatioX);
+          options.aspectRatioY =
+              ta.getInteger(R.styleable.CropImageView_cropAspectRatioY, options.aspectRatioY);
+          options.scaleType =
+              ScaleType.values()[
+                  ta.getInt(R.styleable.CropImageView_cropScaleType, options.scaleType.ordinal())];
+          options.autoZoomEnabled =
+              ta.getBoolean(R.styleable.CropImageView_cropAutoZoomEnabled, options.autoZoomEnabled);
+          options.multiTouchEnabled =
+              ta.getBoolean(
+                  R.styleable.CropImageView_cropMultiTouchEnabled, options.multiTouchEnabled);
+          options.maxZoom = ta.getInteger(R.styleable.CropImageView_cropMaxZoom, options.maxZoom);
+          options.cropShape =
+              CropShape.values()[
+                  ta.getInt(R.styleable.CropImageView_cropShape, options.cropShape.ordinal())];
+          options.guidelines =
+              Guidelines.values()[
+                  ta.getInt(
+                      R.styleable.CropImageView_cropGuidelines, options.guidelines.ordinal())];
+          options.snapRadius =
+              ta.getDimension(R.styleable.CropImageView_cropSnapRadius, options.snapRadius);
+          options.touchRadius =
+              ta.getDimension(R.styleable.CropImageView_cropTouchRadius, options.touchRadius);
+          options.initialCropWindowPaddingRatio =
+              ta.getFloat(
+                  R.styleable.CropImageView_cropInitialCropWindowPaddingRatio,
+                  options.initialCropWindowPaddingRatio);
+          options.borderLineThickness =
+              ta.getDimension(
+                  R.styleable.CropImageView_cropBorderLineThickness, options.borderLineThickness);
+          options.borderLineColor =
+              ta.getInteger(R.styleable.CropImageView_cropBorderLineColor, options.borderLineColor);
+          options.borderCornerThickness =
+              ta.getDimension(
+                  R.styleable.CropImageView_cropBorderCornerThickness,
+                  options.borderCornerThickness);
+          options.borderCornerOffset =
+              ta.getDimension(
+                  R.styleable.CropImageView_cropBorderCornerOffset, options.borderCornerOffset);
+          options.borderCornerLength =
+              ta.getDimension(
+                  R.styleable.CropImageView_cropBorderCornerLength, options.borderCornerLength);
+          options.borderCornerColor =
+              ta.getInteger(
+                  R.styleable.CropImageView_cropBorderCornerColor, options.borderCornerColor);
+          options.guidelinesThickness =
+              ta.getDimension(
+                  R.styleable.CropImageView_cropGuidelinesThickness, options.guidelinesThickness);
+          options.guidelinesColor =
+              ta.getInteger(R.styleable.CropImageView_cropGuidelinesColor, options.guidelinesColor);
+          options.backgroundColor =
+              ta.getInteger(R.styleable.CropImageView_cropBackgroundColor, options.backgroundColor);
+          options.showCropOverlay =
+              ta.getBoolean(R.styleable.CropImageView_cropShowCropOverlay, mShowCropOverlay);
+          options.showProgressBar =
+              ta.getBoolean(R.styleable.CropImageView_cropShowProgressBar, mShowProgressBar);
+          options.borderCornerThickness =
+              ta.getDimension(
+                  R.styleable.CropImageView_cropBorderCornerThickness,
+                  options.borderCornerThickness);
+          options.minCropWindowWidth =
+              (int)
+                  ta.getDimension(
+                      R.styleable.CropImageView_cropMinCropWindowWidth, options.minCropWindowWidth);
+          options.minCropWindowHeight =
+              (int)
+                  ta.getDimension(
+                      R.styleable.CropImageView_cropMinCropWindowHeight,
+                      options.minCropWindowHeight);
+          options.minCropResultWidth =
+              (int)
+                  ta.getFloat(
+                      R.styleable.CropImageView_cropMinCropResultWidthPX,
+                      options.minCropResultWidth);
+          options.minCropResultHeight =
+              (int)
+                  ta.getFloat(
+                      R.styleable.CropImageView_cropMinCropResultHeightPX,
+                      options.minCropResultHeight);
+          options.maxCropResultWidth =
+              (int)
+                  ta.getFloat(
+                      R.styleable.CropImageView_cropMaxCropResultWidthPX,
+                      options.maxCropResultWidth);
+          options.maxCropResultHeight =
+              (int)
+                  ta.getFloat(
+                      R.styleable.CropImageView_cropMaxCropResultHeightPX,
+                      options.maxCropResultHeight);
+          options.flipHorizontally =
+              ta.getBoolean(
+                  R.styleable.CropImageView_cropFlipHorizontally, options.flipHorizontally);
+          options.flipVertically =
+              ta.getBoolean(R.styleable.CropImageView_cropFlipHorizontally, options.flipVertically);
+
+          mSaveBitmapToInstanceState =
+              ta.getBoolean(
+                  R.styleable.CropImageView_cropSaveBitmapToInstanceState,
+                  mSaveBitmapToInstanceState);
+
+          // if aspect ratio is set then set fixed to true
+          if (ta.hasValue(R.styleable.CropImageView_cropAspectRatioX)
+              && ta.hasValue(R.styleable.CropImageView_cropAspectRatioX)
+              && !ta.hasValue(R.styleable.CropImageView_cropFixAspectRatio)) {
+            options.fixAspectRatio = true;
+          }
+        } finally {
+          ta.recycle();
+        }
+      }
+    }
+
+    options.validate();
+
+    mScaleType = options.scaleType;
+    mAutoZoomEnabled = options.autoZoomEnabled;
+    mMaxZoom = options.maxZoom;
+    mShowCropOverlay = options.showCropOverlay;
+    mShowProgressBar = options.showProgressBar;
+    mFlipHorizontally = options.flipHorizontally;
+    mFlipVertically = options.flipVertically;
+
+    LayoutInflater inflater = LayoutInflater.from(context);
+    View v = inflater.inflate(R.layout.crop_image_view, this, true);
+
+    mImageView = v.findViewById(R.id.ImageView_image);
+    mImageView.setScaleType(ImageView.ScaleType.MATRIX);
+
+    mCropOverlayView = v.findViewById(R.id.CropOverlayView);
+    mCropOverlayView.setCropWindowChangeListener(
+        new CropOverlayView.CropWindowChangeListener() {
+          @Override
+          public void onCropWindowChanged(boolean inProgress) {
+            handleCropWindowChanged(inProgress, true);
+            OnSetCropOverlayReleasedListener listener = mOnCropOverlayReleasedListener;
+            if (listener != null && !inProgress) {
+              listener.onCropOverlayReleased(getCropRect());
+            }
+            OnSetCropOverlayMovedListener movedListener = mOnSetCropOverlayMovedListener;
+            if (movedListener != null && inProgress) {
+              movedListener.onCropOverlayMoved(getCropRect());
+            }
+          }
+        });
+    mCropOverlayView.setInitialAttributeValues(options);
+
+    mProgressBar = v.findViewById(R.id.CropProgressBar);
+    setProgressBarVisibility();
+  }
+
+  /** Get the scale type of the image in the crop view. */
+  public ScaleType getScaleType() {
+    return mScaleType;
+  }
+
+  /** Set the scale type of the image in the crop view */
+  public void setScaleType(ScaleType scaleType) {
+    if (scaleType != mScaleType) {
+      mScaleType = scaleType;
+      mZoom = 1;
+      mZoomOffsetX = mZoomOffsetY = 0;
+      mCropOverlayView.resetCropOverlayView();
+      requestLayout();
+    }
+  }
+
+  /** The shape of the cropping area - rectangle/circular. */
+  public CropShape getCropShape() {
+    return mCropOverlayView.getCropShape();
+  }
+
+  /**
+   * The shape of the cropping area - rectangle/circular.<br>
+   * To set square/circle crop shape set aspect ratio to 1:1.
+   */
+  public void setCropShape(CropShape cropShape) {
+    mCropOverlayView.setCropShape(cropShape);
+  }
+
+  /** if auto-zoom functionality is enabled. default: true. */
+  public boolean isAutoZoomEnabled() {
+    return mAutoZoomEnabled;
+  }
+
+  /** Set auto-zoom functionality to enabled/disabled. */
+  public void setAutoZoomEnabled(boolean autoZoomEnabled) {
+    if (mAutoZoomEnabled != autoZoomEnabled) {
+      mAutoZoomEnabled = autoZoomEnabled;
+      handleCropWindowChanged(false, false);
+      mCropOverlayView.invalidate();
+    }
+  }
+
+  /** Set multi touch functionality to enabled/disabled. */
+  public void setMultiTouchEnabled(boolean multiTouchEnabled) {
+    if (mCropOverlayView.setMultiTouchEnabled(multiTouchEnabled)) {
+      handleCropWindowChanged(false, false);
+      mCropOverlayView.invalidate();
+    }
+  }
+
+  /** The max zoom allowed during cropping. */
+  public int getMaxZoom() {
+    return mMaxZoom;
+  }
+
+  /** The max zoom allowed during cropping. */
+  public void setMaxZoom(int maxZoom) {
+    if (mMaxZoom != maxZoom && maxZoom > 0) {
+      mMaxZoom = maxZoom;
+      handleCropWindowChanged(false, false);
+      mCropOverlayView.invalidate();
+    }
+  }
+
+  /**
+   * the min size the resulting cropping image is allowed to be, affects the cropping window limits
+   * (in pixels).<br>
+   */
+  public void setMinCropResultSize(int minCropResultWidth, int minCropResultHeight) {
+    mCropOverlayView.setMinCropResultSize(minCropResultWidth, minCropResultHeight);
+  }
+
+  /**
+   * the max size the resulting cropping image is allowed to be, affects the cropping window limits
+   * (in pixels).<br>
+   */
+  public void setMaxCropResultSize(int maxCropResultWidth, int maxCropResultHeight) {
+    mCropOverlayView.setMaxCropResultSize(maxCropResultWidth, maxCropResultHeight);
+  }
+
+  /**
+   * Get the amount of degrees the cropping image is rotated cloackwise.<br>
+   *
+   * @return 0-360
+   */
+  public int getRotatedDegrees() {
+    return mDegreesRotated;
+  }
+
+  /**
+   * Set the amount of degrees the cropping image is rotated cloackwise.<br>
+   *
+   * @param degrees 0-360
+   */
+  public void setRotatedDegrees(int degrees) {
+    if (mDegreesRotated != degrees) {
+      rotateImage(degrees - mDegreesRotated);
+    }
+  }
+
+  /**
+   * whether the aspect ratio is fixed or not; true fixes the aspect ratio, while false allows it to
+   * be changed.
+   */
+  public boolean isFixAspectRatio() {
+    return mCropOverlayView.isFixAspectRatio();
+  }
+
+  /**
+   * Sets whether the aspect ratio is fixed or not; true fixes the aspect ratio, while false allows
+   * it to be changed.
+   */
+  public void setFixedAspectRatio(boolean fixAspectRatio) {
+    mCropOverlayView.setFixedAspectRatio(fixAspectRatio);
+  }
+
+  /** whether the image should be flipped horizontally */
+  public boolean isFlippedHorizontally() {
+    return mFlipHorizontally;
+  }
+
+  /** Sets whether the image should be flipped horizontally */
+  public void setFlippedHorizontally(boolean flipHorizontally) {
+    if (mFlipHorizontally != flipHorizontally) {
+      mFlipHorizontally = flipHorizontally;
+      applyImageMatrix(getWidth(), getHeight(), true, false);
+    }
+  }
+
+  /** whether the image should be flipped vertically */
+  public boolean isFlippedVertically() {
+    return mFlipVertically;
+  }
+
+  /** Sets whether the image should be flipped vertically */
+  public void setFlippedVertically(boolean flipVertically) {
+    if (mFlipVertically != flipVertically) {
+      mFlipVertically = flipVertically;
+      applyImageMatrix(getWidth(), getHeight(), true, false);
+    }
+  }
+
+  /** Get the current guidelines option set. */
+  public Guidelines getGuidelines() {
+    return mCropOverlayView.getGuidelines();
+  }
+
+  /**
+   * Sets the guidelines for the CropOverlayView to be either on, off, or to show when resizing the
+   * application.
+   */
+  public void setGuidelines(Guidelines guidelines) {
+    mCropOverlayView.setGuidelines(guidelines);
+  }
+
+  /** both the X and Y values of the aspectRatio. */
+  public Pair<Integer, Integer> getAspectRatio() {
+    return new Pair<>(mCropOverlayView.getAspectRatioX(), mCropOverlayView.getAspectRatioY());
+  }
+
+  /**
+   * Sets the both the X and Y values of the aspectRatio.<br>
+   * Sets fixed aspect ratio to TRUE.
+   *
+   * @param aspectRatioX int that specifies the new X value of the aspect ratio
+   * @param aspectRatioY int that specifies the new Y value of the aspect ratio
+   */
+  public void setAspectRatio(int aspectRatioX, int aspectRatioY) {
+    mCropOverlayView.setAspectRatioX(aspectRatioX);
+    mCropOverlayView.setAspectRatioY(aspectRatioY);
+    setFixedAspectRatio(true);
+  }
+
+  /** Clears set aspect ratio values and sets fixed aspect ratio to FALSE. */
+  public void clearAspectRatio() {
+    mCropOverlayView.setAspectRatioX(1);
+    mCropOverlayView.setAspectRatioY(1);
+    setFixedAspectRatio(false);
+  }
+
+  /**
+   * An edge of the crop window will snap to the corresponding edge of a specified bounding box when
+   * the crop window edge is less than or equal to this distance (in pixels) away from the bounding
+   * box edge. (default: 3dp)
+   */
+  public void setSnapRadius(float snapRadius) {
+    if (snapRadius >= 0) {
+      mCropOverlayView.setSnapRadius(snapRadius);
+    }
+  }
+
+  /**
+   * if to show progress bar when image async loading/cropping is in progress.<br>
+   * default: true, disable to provide custom progress bar UI.
+   */
+  public boolean isShowProgressBar() {
+    return mShowProgressBar;
+  }
+
+  /**
+   * if to show progress bar when image async loading/cropping is in progress.<br>
+   * default: true, disable to provide custom progress bar UI.
+   */
+  public void setShowProgressBar(boolean showProgressBar) {
+    if (mShowProgressBar != showProgressBar) {
+      mShowProgressBar = showProgressBar;
+      setProgressBarVisibility();
+    }
+  }
+
+  /**
+   * if to show crop overlay UI what contains the crop window UI surrounded by background over the
+   * cropping image.<br>
+   * default: true, may disable for animation or frame transition.
+   */
+  public boolean isShowCropOverlay() {
+    return mShowCropOverlay;
+  }
+
+  /**
+   * if to show crop overlay UI what contains the crop window UI surrounded by background over the
+   * cropping image.<br>
+   * default: true, may disable for animation or frame transition.
+   */
+  public void setShowCropOverlay(boolean showCropOverlay) {
+    if (mShowCropOverlay != showCropOverlay) {
+      mShowCropOverlay = showCropOverlay;
+      setCropOverlayVisibility();
+    }
+  }
+
+  /**
+   * if to save bitmap on save instance state.<br>
+   * It is best to avoid it by using URI in setting image for cropping.<br>
+   * If false the bitmap is not saved and if restore is required to view will be empty, storing the
+   * bitmap requires saving it to file which can be expensive. default: false.
+   */
+  public boolean isSaveBitmapToInstanceState() {
+    return mSaveBitmapToInstanceState;
+  }
+
+  /**
+   * if to save bitmap on save instance state.<br>
+   * It is best to avoid it by using URI in setting image for cropping.<br>
+   * If false the bitmap is not saved and if restore is required to view will be empty, storing the
+   * bitmap requires saving it to file which can be expensive. default: false.
+   */
+  public void setSaveBitmapToInstanceState(boolean saveBitmapToInstanceState) {
+    mSaveBitmapToInstanceState = saveBitmapToInstanceState;
+  }
+
+  /** Returns the integer of the imageResource */
+  public int getImageResource() {
+    return mImageResource;
+  }
+
+  /** Get the URI of an image that was set by URI, null otherwise. */
+  public Uri getImageUri() {
+    return mLoadedImageUri;
+  }
+
+  /**
+   * Gets the source Bitmap's dimensions. This represents the largest possible crop rectangle.
+   *
+   * @return a Rect instance dimensions of the source Bitmap
+   */
+  public Rect getWholeImageRect() {
+    int loadedSampleSize = mLoadedSampleSize;
+    Bitmap bitmap = mBitmap;
+    if (bitmap == null) {
+      return null;
+    }
+
+    int orgWidth = bitmap.getWidth() * loadedSampleSize;
+    int orgHeight = bitmap.getHeight() * loadedSampleSize;
+    return new Rect(0, 0, orgWidth, orgHeight);
+  }
+
+  /**
+   * Gets the crop window's position relative to the source Bitmap (not the image displayed in the
+   * CropImageView) using the original image rotation.
+   *
+   * @return a Rect instance containing cropped area boundaries of the source Bitmap
+   */
+  public Rect getCropRect() {
+    int loadedSampleSize = mLoadedSampleSize;
+    Bitmap bitmap = mBitmap;
+    if (bitmap == null) {
+      return null;
+    }
+
+    // get the points of the crop rectangle adjusted to source bitmap
+    float[] points = getCropPoints();
+
+    int orgWidth = bitmap.getWidth() * loadedSampleSize;
+    int orgHeight = bitmap.getHeight() * loadedSampleSize;
+
+    // get the rectangle for the points (it may be larger than original if rotation is not stright)
+    return BitmapUtils.getRectFromPoints(
+        points,
+        orgWidth,
+        orgHeight,
+        mCropOverlayView.isFixAspectRatio(),
+        mCropOverlayView.getAspectRatioX(),
+        mCropOverlayView.getAspectRatioY());
+  }
+
+  /**
+   * Gets the crop window's position relative to the parent's view at screen.
+   *
+   * @return a Rect instance containing cropped area boundaries of the source Bitmap
+   */
+  public RectF getCropWindowRect() {
+    if (mCropOverlayView == null) {
+      return null;
+    }
+    return mCropOverlayView.getCropWindowRect();
+  }
+
+  /**
+   * Gets the 4 points of crop window's position relative to the source Bitmap (not the image
+   * displayed in the CropImageView) using the original image rotation.<br>
+   * Note: the 4 points may not be a rectangle if the image was rotates to NOT stright angle (!=
+   * 90/180/270).
+   *
+   * @return 4 points (x0,y0,x1,y1,x2,y2,x3,y3) of cropped area boundaries
+   */
+  public float[] getCropPoints() {
+
+    // Get crop window position relative to the displayed image.
+    RectF cropWindowRect = mCropOverlayView.getCropWindowRect();
+
+    float[] points =
+        new float[] {
+          cropWindowRect.left,
+          cropWindowRect.top,
+          cropWindowRect.right,
+          cropWindowRect.top,
+          cropWindowRect.right,
+          cropWindowRect.bottom,
+          cropWindowRect.left,
+          cropWindowRect.bottom
+        };
+
+    mImageMatrix.invert(mImageInverseMatrix);
+    mImageInverseMatrix.mapPoints(points);
+
+    for (int i = 0; i < points.length; i++) {
+      points[i] *= mLoadedSampleSize;
+    }
+
+    return points;
+  }
+
+  /**
+   * Set the crop window position and size to the given rectangle.<br>
+   * Image to crop must be first set before invoking this, for async - after complete callback.
+   *
+   * @param rect window rectangle (position and size) relative to source bitmap
+   */
+  public void setCropRect(Rect rect) {
+    mCropOverlayView.setInitialCropWindowRect(rect);
+  }
+
+  /** Reset crop window to initial rectangle. */
+  public void resetCropRect() {
+    mZoom = 1;
+    mZoomOffsetX = 0;
+    mZoomOffsetY = 0;
+    mDegreesRotated = mInitialDegreesRotated;
+    mFlipHorizontally = false;
+    mFlipVertically = false;
+    applyImageMatrix(getWidth(), getHeight(), false, false);
+    mCropOverlayView.resetCropWindowRect();
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.
+   *
+   * @return a new Bitmap representing the cropped image
+   */
+  public Bitmap getCroppedImage() {
+    return getCroppedImage(0, 0, RequestSizeOptions.NONE);
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.<br>
+   * Uses {@link RequestSizeOptions#RESIZE_INSIDE} option.
+   *
+   * @param reqWidth the width to resize the cropped image to
+   * @param reqHeight the height to resize the cropped image to
+   * @return a new Bitmap representing the cropped image
+   */
+  public Bitmap getCroppedImage(int reqWidth, int reqHeight) {
+    return getCroppedImage(reqWidth, reqHeight, RequestSizeOptions.RESIZE_INSIDE);
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.<br>
+   *
+   * @param reqWidth the width to resize the cropped image to (see options)
+   * @param reqHeight the height to resize the cropped image to (see options)
+   * @param options the resize method to use, see its documentation
+   * @return a new Bitmap representing the cropped image
+   */
+  public Bitmap getCroppedImage(int reqWidth, int reqHeight, RequestSizeOptions options) {
+    Bitmap croppedBitmap = null;
+    if (mBitmap != null) {
+      mImageView.clearAnimation();
+
+      reqWidth = options != RequestSizeOptions.NONE ? reqWidth : 0;
+      reqHeight = options != RequestSizeOptions.NONE ? reqHeight : 0;
+
+      if (mLoadedImageUri != null
+          && (mLoadedSampleSize > 1 || options == RequestSizeOptions.SAMPLING)) {
+        int orgWidth = mBitmap.getWidth() * mLoadedSampleSize;
+        int orgHeight = mBitmap.getHeight() * mLoadedSampleSize;
+        BitmapUtils.BitmapSampled bitmapSampled =
+            BitmapUtils.cropBitmap(
+                getContext(),
+                mLoadedImageUri,
+                getCropPoints(),
+                mDegreesRotated,
+                orgWidth,
+                orgHeight,
+                mCropOverlayView.isFixAspectRatio(),
+                mCropOverlayView.getAspectRatioX(),
+                mCropOverlayView.getAspectRatioY(),
+                reqWidth,
+                reqHeight,
+                mFlipHorizontally,
+                mFlipVertically);
+        croppedBitmap = bitmapSampled.bitmap;
+      } else {
+        croppedBitmap =
+            BitmapUtils.cropBitmapObjectHandleOOM(
+                    mBitmap,
+                    getCropPoints(),
+                    mDegreesRotated,
+                    mCropOverlayView.isFixAspectRatio(),
+                    mCropOverlayView.getAspectRatioX(),
+                    mCropOverlayView.getAspectRatioY(),
+                    mFlipHorizontally,
+                    mFlipVertically)
+                .bitmap;
+      }
+
+      croppedBitmap = BitmapUtils.resizeBitmap(croppedBitmap, reqWidth, reqHeight, options);
+    }
+
+    return croppedBitmap;
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   */
+  public void getCroppedImageAsync() {
+    getCroppedImageAsync(0, 0, RequestSizeOptions.NONE);
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.<br>
+   * Uses {@link RequestSizeOptions#RESIZE_INSIDE} option.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param reqWidth the width to resize the cropped image to
+   * @param reqHeight the height to resize the cropped image to
+   */
+  public void getCroppedImageAsync(int reqWidth, int reqHeight) {
+    getCroppedImageAsync(reqWidth, reqHeight, RequestSizeOptions.RESIZE_INSIDE);
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param reqWidth the width to resize the cropped image to (see options)
+   * @param reqHeight the height to resize the cropped image to (see options)
+   * @param options the resize method to use, see its documentation
+   */
+  public void getCroppedImageAsync(int reqWidth, int reqHeight, RequestSizeOptions options) {
+    if (mOnCropImageCompleteListener == null) {
+      throw new IllegalArgumentException("mOnCropImageCompleteListener is not set");
+    }
+    startCropWorkerTask(reqWidth, reqHeight, options, null, null, 0);
+  }
+
+  /**
+   * Save the cropped image based on the current crop window to the given uri.<br>
+   * Uses JPEG image compression with 90 compression quality.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param saveUri the Android Uri to save the cropped image to
+   */
+  public void saveCroppedImageAsync(Uri saveUri) {
+    saveCroppedImageAsync(saveUri, Bitmap.CompressFormat.JPEG, 90, 0, 0, RequestSizeOptions.NONE);
+  }
+
+  /**
+   * Save the cropped image based on the current crop window to the given uri.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param saveUri the Android Uri to save the cropped image to
+   * @param saveCompressFormat the compression format to use when writing the image
+   * @param saveCompressQuality the quality (if applicable) to use when writing the image (0 - 100)
+   */
+  public void saveCroppedImageAsync(
+      Uri saveUri, Bitmap.CompressFormat saveCompressFormat, int saveCompressQuality) {
+    saveCroppedImageAsync(
+        saveUri, saveCompressFormat, saveCompressQuality, 0, 0, RequestSizeOptions.NONE);
+  }
+
+  /**
+   * Save the cropped image based on the current crop window to the given uri.<br>
+   * Uses {@link RequestSizeOptions#RESIZE_INSIDE} option.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param saveUri the Android Uri to save the cropped image to
+   * @param saveCompressFormat the compression format to use when writing the image
+   * @param saveCompressQuality the quality (if applicable) to use when writing the image (0 - 100)
+   * @param reqWidth the width to resize the cropped image to
+   * @param reqHeight the height to resize the cropped image to
+   */
+  public void saveCroppedImageAsync(
+      Uri saveUri,
+      Bitmap.CompressFormat saveCompressFormat,
+      int saveCompressQuality,
+      int reqWidth,
+      int reqHeight) {
+    saveCroppedImageAsync(
+        saveUri,
+        saveCompressFormat,
+        saveCompressQuality,
+        reqWidth,
+        reqHeight,
+        RequestSizeOptions.RESIZE_INSIDE);
+  }
+
+  /**
+   * Save the cropped image based on the current crop window to the given uri.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param saveUri the Android Uri to save the cropped image to
+   * @param saveCompressFormat the compression format to use when writing the image
+   * @param saveCompressQuality the quality (if applicable) to use when writing the image (0 - 100)
+   * @param reqWidth the width to resize the cropped image to (see options)
+   * @param reqHeight the height to resize the cropped image to (see options)
+   * @param options the resize method to use, see its documentation
+   */
+  public void saveCroppedImageAsync(
+      Uri saveUri,
+      Bitmap.CompressFormat saveCompressFormat,
+      int saveCompressQuality,
+      int reqWidth,
+      int reqHeight,
+      RequestSizeOptions options) {
+    if (mOnCropImageCompleteListener == null) {
+      throw new IllegalArgumentException("mOnCropImageCompleteListener is not set");
+    }
+    startCropWorkerTask(
+        reqWidth, reqHeight, options, saveUri, saveCompressFormat, saveCompressQuality);
+  }
+
+  /** Set the callback t */
+  public void setOnSetCropOverlayReleasedListener(OnSetCropOverlayReleasedListener listener) {
+    mOnCropOverlayReleasedListener = listener;
+  }
+
+  /** Set the callback when the cropping is moved */
+  public void setOnSetCropOverlayMovedListener(OnSetCropOverlayMovedListener listener) {
+    mOnSetCropOverlayMovedListener = listener;
+  }
+
+  /** Set the callback when the crop window is changed */
+  public void setOnCropWindowChangedListener(OnSetCropWindowChangeListener listener) {
+    mOnSetCropWindowChangeListener = listener;
+  }
+
+  /**
+   * Set the callback to be invoked when image async loading ({@link #setImageUriAsync(Uri)}) is
+   * complete (successful or failed).
+   */
+  public void setOnSetImageUriCompleteListener(OnSetImageUriCompleteListener listener) {
+    mOnSetImageUriCompleteListener = listener;
+  }
+
+  /**
+   * Set the callback to be invoked when image async cropping image ({@link #getCroppedImageAsync()}
+   * or {@link #saveCroppedImageAsync(Uri)}) is complete (successful or failed).
+   */
+  public void setOnCropImageCompleteListener(OnCropImageCompleteListener listener) {
+    mOnCropImageCompleteListener = listener;
+  }
+
+  /**
+   * Sets a Bitmap as the content of the CropImageView.
+   *
+   * @param bitmap the Bitmap to set
+   */
+  public void setImageBitmap(Bitmap bitmap) {
+    mCropOverlayView.setInitialCropWindowRect(null);
+    setBitmap(bitmap, 0, null, 1, 0);
+  }
+
+  /**
+   * Sets a Bitmap and initializes the image rotation according to the EXIT data.<br>
+   * <br>
+   * The EXIF can be retrieved by doing the following: <code>
+   * ExifInterface exif = new ExifInterface(path);</code>
+   *
+   * @param bitmap the original bitmap to set; if null, this
+   * @param exif the EXIF information about this bitmap; may be null
+   */
+  public void setImageBitmap(Bitmap bitmap, ExifInterface exif) {
+    Bitmap setBitmap;
+    int degreesRotated = 0;
+    if (bitmap != null && exif != null) {
+      BitmapUtils.RotateBitmapResult result = BitmapUtils.rotateBitmapByExif(bitmap, exif);
+      setBitmap = result.bitmap;
+      degreesRotated = result.degrees;
+      mInitialDegreesRotated = result.degrees;
+    } else {
+      setBitmap = bitmap;
+    }
+    mCropOverlayView.setInitialCropWindowRect(null);
+    setBitmap(setBitmap, 0, null, 1, degreesRotated);
+  }
+
+  /**
+   * Sets a Drawable as the content of the CropImageView.
+   *
+   * @param resId the drawable resource ID to set
+   */
+  public void setImageResource(int resId) {
+    if (resId != 0) {
+      mCropOverlayView.setInitialCropWindowRect(null);
+      Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resId);
+      setBitmap(bitmap, resId, null, 1, 0);
+    }
+  }
+
+  /**
+   * Sets a bitmap loaded from the given Android URI as the content of the CropImageView.<br>
+   * Can be used with URI from gallery or camera source.<br>
+   * Will rotate the image by exif data.<br>
+   *
+   * @param uri the URI to load the image from
+   */
+  public void setImageUriAsync(Uri uri) {
+    if (uri != null) {
+      BitmapLoadingWorkerTask currentTask =
+          mBitmapLoadingWorkerTask != null ? mBitmapLoadingWorkerTask.get() : null;
+      if (currentTask != null) {
+        // cancel previous loading (no check if the same URI because camera URI can be the same for
+        // different images)
+        currentTask.cancel(true);
+      }
+
+      // either no existing task is working or we canceled it, need to load new URI
+      clearImageInt();
+      mRestoreCropWindowRect = null;
+      mRestoreDegreesRotated = 0;
+      mCropOverlayView.setInitialCropWindowRect(null);
+      mBitmapLoadingWorkerTask = new WeakReference<>(new BitmapLoadingWorkerTask(this, uri));
+      mBitmapLoadingWorkerTask.get().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+      setProgressBarVisibility();
+    }
+  }
+
+  /** Clear the current image set for cropping. */
+  public void clearImage() {
+    clearImageInt();
+    mCropOverlayView.setInitialCropWindowRect(null);
+  }
+
+  /**
+   * Rotates image by the specified number of degrees clockwise.<br>
+   * Negative values represent counter-clockwise rotations.
+   *
+   * @param degrees Integer specifying the number of degrees to rotate.
+   */
+  public void rotateImage(int degrees) {
+    if (mBitmap != null) {
+      // Force degrees to be a non-zero value between 0 and 360 (inclusive)
+      if (degrees < 0) {
+        degrees = (degrees % 360) + 360;
+      } else {
+        degrees = degrees % 360;
+      }
+
+      boolean flipAxes =
+          !mCropOverlayView.isFixAspectRatio()
+              && ((degrees > 45 && degrees < 135) || (degrees > 215 && degrees < 305));
+      BitmapUtils.RECT.set(mCropOverlayView.getCropWindowRect());
+      float halfWidth = (flipAxes ? BitmapUtils.RECT.height() : BitmapUtils.RECT.width()) / 2f;
+      float halfHeight = (flipAxes ? BitmapUtils.RECT.width() : BitmapUtils.RECT.height()) / 2f;
+      if (flipAxes) {
+        boolean isFlippedHorizontally = mFlipHorizontally;
+        mFlipHorizontally = mFlipVertically;
+        mFlipVertically = isFlippedHorizontally;
+      }
+
+      mImageMatrix.invert(mImageInverseMatrix);
+
+      BitmapUtils.POINTS[0] = BitmapUtils.RECT.centerX();
+      BitmapUtils.POINTS[1] = BitmapUtils.RECT.centerY();
+      BitmapUtils.POINTS[2] = 0;
+      BitmapUtils.POINTS[3] = 0;
+      BitmapUtils.POINTS[4] = 1;
+      BitmapUtils.POINTS[5] = 0;
+      mImageInverseMatrix.mapPoints(BitmapUtils.POINTS);
+
+      // This is valid because degrees is not negative.
+      mDegreesRotated = (mDegreesRotated + degrees) % 360;
+
+      applyImageMatrix(getWidth(), getHeight(), true, false);
+
+      // adjust the zoom so the crop window size remains the same even after image scale change
+      mImageMatrix.mapPoints(BitmapUtils.POINTS2, BitmapUtils.POINTS);
+      mZoom /=
+          Math.sqrt(
+              Math.pow(BitmapUtils.POINTS2[4] - BitmapUtils.POINTS2[2], 2)
+                  + Math.pow(BitmapUtils.POINTS2[5] - BitmapUtils.POINTS2[3], 2));
+      mZoom = Math.max(mZoom, 1);
+
+      applyImageMatrix(getWidth(), getHeight(), true, false);
+
+      mImageMatrix.mapPoints(BitmapUtils.POINTS2, BitmapUtils.POINTS);
+
+      // adjust the width/height by the changes in scaling to the image
+      double change =
+          Math.sqrt(
+              Math.pow(BitmapUtils.POINTS2[4] - BitmapUtils.POINTS2[2], 2)
+                  + Math.pow(BitmapUtils.POINTS2[5] - BitmapUtils.POINTS2[3], 2));
+      halfWidth *= change;
+      halfHeight *= change;
+
+      // calculate the new crop window rectangle to center in the same location and have proper
+      // width/height
+      BitmapUtils.RECT.set(
+          BitmapUtils.POINTS2[0] - halfWidth,
+          BitmapUtils.POINTS2[1] - halfHeight,
+          BitmapUtils.POINTS2[0] + halfWidth,
+          BitmapUtils.POINTS2[1] + halfHeight);
+
+      mCropOverlayView.resetCropOverlayView();
+      mCropOverlayView.setCropWindowRect(BitmapUtils.RECT);
+      applyImageMatrix(getWidth(), getHeight(), true, false);
+      handleCropWindowChanged(false, false);
+
+      // make sure the crop window rectangle is within the cropping image bounds after all the
+      // changes
+      mCropOverlayView.fixCurrentCropWindowRect();
+    }
+  }
+
+  /** Flips the image horizontally. */
+  public void flipImageHorizontally() {
+    mFlipHorizontally = !mFlipHorizontally;
+    applyImageMatrix(getWidth(), getHeight(), true, false);
+  }
+
+  /** Flips the image vertically. */
+  public void flipImageVertically() {
+    mFlipVertically = !mFlipVertically;
+    applyImageMatrix(getWidth(), getHeight(), true, false);
+  }
+
+  // region: Private methods
+
+  /**
+   * On complete of the async bitmap loading by {@link #setImageUriAsync(Uri)} set the result to the
+   * widget if still relevant and call listener if set.
+   *
+   * @param result the result of bitmap loading
+   */
+  void onSetImageUriAsyncComplete(BitmapLoadingWorkerTask.Result result) {
+
+    mBitmapLoadingWorkerTask = null;
+    setProgressBarVisibility();
+
+    if (result.error == null) {
+      mInitialDegreesRotated = result.degreesRotated;
+      setBitmap(result.bitmap, 0, result.uri, result.loadSampleSize, result.degreesRotated);
+    }
+
+    OnSetImageUriCompleteListener listener = mOnSetImageUriCompleteListener;
+    if (listener != null) {
+      listener.onSetImageUriComplete(this, result.uri, result.error);
+    }
+  }
+
+  /**
+   * On complete of the async bitmap cropping by {@link #getCroppedImageAsync()} call listener if
+   * set.
+   *
+   * @param result the result of bitmap cropping
+   */
+  void onImageCroppingAsyncComplete(BitmapCroppingWorkerTask.Result result) {
+
+    mBitmapCroppingWorkerTask = null;
+    setProgressBarVisibility();
+
+    OnCropImageCompleteListener listener = mOnCropImageCompleteListener;
+    if (listener != null) {
+      CropResult cropResult =
+          new CropResult(
+              mBitmap,
+              mLoadedImageUri,
+              result.bitmap,
+              result.uri,
+              result.error,
+              getCropPoints(),
+              getCropRect(),
+              getWholeImageRect(),
+              getRotatedDegrees(),
+              result.sampleSize);
+      listener.onCropImageComplete(this, cropResult);
+    }
+  }
+
+  /**
+   * Set the given bitmap to be used in for cropping<br>
+   * Optionally clear full if the bitmap is new, or partial clear if the bitmap has been
+   * manipulated.
+   */
+  private void setBitmap(
+      Bitmap bitmap, int imageResource, Uri imageUri, int loadSampleSize, int degreesRotated) {
+    if (mBitmap == null || !mBitmap.equals(bitmap)) {
+
+      mImageView.clearAnimation();
+
+      clearImageInt();
+
+      mBitmap = bitmap;
+      mImageView.setImageBitmap(mBitmap);
+
+      mLoadedImageUri = imageUri;
+      mImageResource = imageResource;
+      mLoadedSampleSize = loadSampleSize;
+      mDegreesRotated = degreesRotated;
+
+      applyImageMatrix(getWidth(), getHeight(), true, false);
+
+      if (mCropOverlayView != null) {
+        mCropOverlayView.resetCropOverlayView();
+        setCropOverlayVisibility();
+      }
+    }
+  }
+
+  /**
+   * Clear the current image set for cropping.<br>
+   * Full clear will also clear the data of the set image like Uri or Resource id while partial
+   * clear will only clear the bitmap and recycle if required.
+   */
+  private void clearImageInt() {
+
+    // if we allocated the bitmap, release it as fast as possible
+    if (mBitmap != null && (mImageResource > 0 || mLoadedImageUri != null)) {
+      mBitmap.recycle();
+    }
+    mBitmap = null;
+
+    // clean the loaded image flags for new image
+    mImageResource = 0;
+    mLoadedImageUri = null;
+    mLoadedSampleSize = 1;
+    mDegreesRotated = 0;
+    mZoom = 1;
+    mZoomOffsetX = 0;
+    mZoomOffsetY = 0;
+    mImageMatrix.reset();
+    mSaveInstanceStateBitmapUri = null;
+
+    mImageView.setImageBitmap(null);
+
+    setCropOverlayVisibility();
+  }
+
+  /**
+   * Gets the cropped image based on the current crop window.<br>
+   * If (reqWidth,reqHeight) is given AND image is loaded from URI cropping will try to use sample
+   * size to fit in the requested width and height down-sampling if possible - optimization to get
+   * best size to quality.<br>
+   * The result will be invoked to listener set by {@link
+   * #setOnCropImageCompleteListener(OnCropImageCompleteListener)}.
+   *
+   * @param reqWidth the width to resize the cropped image to (see options)
+   * @param reqHeight the height to resize the cropped image to (see options)
+   * @param options the resize method to use on the cropped bitmap
+   * @param saveUri optional: to save the cropped image to
+   * @param saveCompressFormat if saveUri is given, the given compression will be used for saving
+   *     the image
+   * @param saveCompressQuality if saveUri is given, the given quality will be used for the
+   *     compression.
+   */
+  public void startCropWorkerTask(
+      int reqWidth,
+      int reqHeight,
+      RequestSizeOptions options,
+      Uri saveUri,
+      Bitmap.CompressFormat saveCompressFormat,
+      int saveCompressQuality) {
+    Bitmap bitmap = mBitmap;
+    if (bitmap != null) {
+      mImageView.clearAnimation();
+
+      BitmapCroppingWorkerTask currentTask =
+          mBitmapCroppingWorkerTask != null ? mBitmapCroppingWorkerTask.get() : null;
+      if (currentTask != null) {
+        // cancel previous cropping
+        currentTask.cancel(true);
+      }
+
+      reqWidth = options != RequestSizeOptions.NONE ? reqWidth : 0;
+      reqHeight = options != RequestSizeOptions.NONE ? reqHeight : 0;
+
+      int orgWidth = bitmap.getWidth() * mLoadedSampleSize;
+      int orgHeight = bitmap.getHeight() * mLoadedSampleSize;
+      if (mLoadedImageUri != null
+          && (mLoadedSampleSize > 1 || options == RequestSizeOptions.SAMPLING)) {
+        mBitmapCroppingWorkerTask =
+            new WeakReference<>(
+                new BitmapCroppingWorkerTask(
+                    this,
+                    mLoadedImageUri,
+                    getCropPoints(),
+                    mDegreesRotated,
+                    orgWidth,
+                    orgHeight,
+                    mCropOverlayView.isFixAspectRatio(),
+                    mCropOverlayView.getAspectRatioX(),
+                    mCropOverlayView.getAspectRatioY(),
+                    reqWidth,
+                    reqHeight,
+                    mFlipHorizontally,
+                    mFlipVertically,
+                    options,
+                    saveUri,
+                    saveCompressFormat,
+                    saveCompressQuality));
+      } else {
+        mBitmapCroppingWorkerTask =
+            new WeakReference<>(
+                new BitmapCroppingWorkerTask(
+                    this,
+                    bitmap,
+                    getCropPoints(),
+                    mDegreesRotated,
+                    mCropOverlayView.isFixAspectRatio(),
+                    mCropOverlayView.getAspectRatioX(),
+                    mCropOverlayView.getAspectRatioY(),
+                    reqWidth,
+                    reqHeight,
+                    mFlipHorizontally,
+                    mFlipVertically,
+                    options,
+                    saveUri,
+                    saveCompressFormat,
+                    saveCompressQuality));
+      }
+      mBitmapCroppingWorkerTask.get().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+      setProgressBarVisibility();
+    }
+  }
+
+  @Override
+  public Parcelable onSaveInstanceState() {
+    if (mLoadedImageUri == null && mBitmap == null && mImageResource < 1) {
+      return super.onSaveInstanceState();
+    }
+
+    Bundle bundle = new Bundle();
+    Uri imageUri = mLoadedImageUri;
+    if (mSaveBitmapToInstanceState && imageUri == null && mImageResource < 1) {
+      mSaveInstanceStateBitmapUri =
+          imageUri =
+              BitmapUtils.writeTempStateStoreBitmap(
+                  getContext(), mBitmap, mSaveInstanceStateBitmapUri);
+    }
+    if (imageUri != null && mBitmap != null) {
+      String key = UUID.randomUUID().toString();
+      BitmapUtils.mStateBitmap = new Pair<>(key, new WeakReference<>(mBitmap));
+      bundle.putString("LOADED_IMAGE_STATE_BITMAP_KEY", key);
+    }
+    if (mBitmapLoadingWorkerTask != null) {
+      BitmapLoadingWorkerTask task = mBitmapLoadingWorkerTask.get();
+      if (task != null) {
+        bundle.putParcelable("LOADING_IMAGE_URI", task.getUri());
+      }
+    }
+    bundle.putParcelable("instanceState", super.onSaveInstanceState());
+    bundle.putParcelable("LOADED_IMAGE_URI", imageUri);
+    bundle.putInt("LOADED_IMAGE_RESOURCE", mImageResource);
+    bundle.putInt("LOADED_SAMPLE_SIZE", mLoadedSampleSize);
+    bundle.putInt("DEGREES_ROTATED", mDegreesRotated);
+    bundle.putParcelable("INITIAL_CROP_RECT", mCropOverlayView.getInitialCropWindowRect());
+
+    BitmapUtils.RECT.set(mCropOverlayView.getCropWindowRect());
+
+    mImageMatrix.invert(mImageInverseMatrix);
+    mImageInverseMatrix.mapRect(BitmapUtils.RECT);
+
+    bundle.putParcelable("CROP_WINDOW_RECT", BitmapUtils.RECT);
+    bundle.putString("CROP_SHAPE", mCropOverlayView.getCropShape().name());
+    bundle.putBoolean("CROP_AUTO_ZOOM_ENABLED", mAutoZoomEnabled);
+    bundle.putInt("CROP_MAX_ZOOM", mMaxZoom);
+    bundle.putBoolean("CROP_FLIP_HORIZONTALLY", mFlipHorizontally);
+    bundle.putBoolean("CROP_FLIP_VERTICALLY", mFlipVertically);
+
+    return bundle;
+  }
+
+  @Override
+  public void onRestoreInstanceState(Parcelable state) {
+
+    if (state instanceof Bundle) {
+      Bundle bundle = (Bundle) state;
+
+      // prevent restoring state if already set by outside code
+      if (mBitmapLoadingWorkerTask == null
+          && mLoadedImageUri == null
+          && mBitmap == null
+          && mImageResource == 0) {
+
+        Uri uri = bundle.getParcelable("LOADED_IMAGE_URI");
+        if (uri != null) {
+          String key = bundle.getString("LOADED_IMAGE_STATE_BITMAP_KEY");
+          if (key != null) {
+            Bitmap stateBitmap =
+                BitmapUtils.mStateBitmap != null && BitmapUtils.mStateBitmap.first.equals(key)
+                    ? BitmapUtils.mStateBitmap.second.get()
+                    : null;
+            BitmapUtils.mStateBitmap = null;
+            if (stateBitmap != null && !stateBitmap.isRecycled()) {
+              setBitmap(stateBitmap, 0, uri, bundle.getInt("LOADED_SAMPLE_SIZE"), 0);
+            }
+          }
+          if (mLoadedImageUri == null) {
+            setImageUriAsync(uri);
+          }
+        } else {
+          int resId = bundle.getInt("LOADED_IMAGE_RESOURCE");
+          if (resId > 0) {
+            setImageResource(resId);
+          } else {
+            uri = bundle.getParcelable("LOADING_IMAGE_URI");
+            if (uri != null) {
+              setImageUriAsync(uri);
+            }
+          }
+        }
+
+        mDegreesRotated = mRestoreDegreesRotated = bundle.getInt("DEGREES_ROTATED");
+
+        Rect initialCropRect = bundle.getParcelable("INITIAL_CROP_RECT");
+        if (initialCropRect != null
+            && (initialCropRect.width() > 0 || initialCropRect.height() > 0)) {
+          mCropOverlayView.setInitialCropWindowRect(initialCropRect);
+        }
+
+        RectF cropWindowRect = bundle.getParcelable("CROP_WINDOW_RECT");
+        if (cropWindowRect != null && (cropWindowRect.width() > 0 || cropWindowRect.height() > 0)) {
+          mRestoreCropWindowRect = cropWindowRect;
+        }
+
+        mCropOverlayView.setCropShape(CropShape.valueOf(bundle.getString("CROP_SHAPE")));
+
+        mAutoZoomEnabled = bundle.getBoolean("CROP_AUTO_ZOOM_ENABLED");
+        mMaxZoom = bundle.getInt("CROP_MAX_ZOOM");
+
+        mFlipHorizontally = bundle.getBoolean("CROP_FLIP_HORIZONTALLY");
+        mFlipVertically = bundle.getBoolean("CROP_FLIP_VERTICALLY");
+      }
+
+      super.onRestoreInstanceState(bundle.getParcelable("instanceState"));
+    } else {
+      super.onRestoreInstanceState(state);
+    }
+  }
+
+  @Override
+  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
+    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+
+    if (mBitmap != null) {
+
+      // Bypasses a baffling bug when used within a ScrollView, where heightSize is set to 0.
+      if (heightSize == 0) {
+        heightSize = mBitmap.getHeight();
+      }
+
+      int desiredWidth;
+      int desiredHeight;
+
+      double viewToBitmapWidthRatio = Double.POSITIVE_INFINITY;
+      double viewToBitmapHeightRatio = Double.POSITIVE_INFINITY;
+
+      // Checks if either width or height needs to be fixed
+      if (widthSize < mBitmap.getWidth()) {
+        viewToBitmapWidthRatio = (double) widthSize / (double) mBitmap.getWidth();
+      }
+      if (heightSize < mBitmap.getHeight()) {
+        viewToBitmapHeightRatio = (double) heightSize / (double) mBitmap.getHeight();
+      }
+
+      // If either needs to be fixed, choose smallest ratio and calculate from there
+      if (viewToBitmapWidthRatio != Double.POSITIVE_INFINITY
+          || viewToBitmapHeightRatio != Double.POSITIVE_INFINITY) {
+        if (viewToBitmapWidthRatio <= viewToBitmapHeightRatio) {
+          desiredWidth = widthSize;
+          desiredHeight = (int) (mBitmap.getHeight() * viewToBitmapWidthRatio);
+        } else {
+          desiredHeight = heightSize;
+          desiredWidth = (int) (mBitmap.getWidth() * viewToBitmapHeightRatio);
+        }
+      } else {
+        // Otherwise, the picture is within frame layout bounds. Desired width is simply picture
+        // size
+        desiredWidth = mBitmap.getWidth();
+        desiredHeight = mBitmap.getHeight();
+      }
+
+      int width = getOnMeasureSpec(widthMode, widthSize, desiredWidth);
+      int height = getOnMeasureSpec(heightMode, heightSize, desiredHeight);
+
+      mLayoutWidth = width;
+      mLayoutHeight = height;
+
+      setMeasuredDimension(mLayoutWidth, mLayoutHeight);
+
+    } else {
+      setMeasuredDimension(widthSize, heightSize);
+    }
+  }
+
+  @Override
+  protected void onLayout(boolean changed, int l, int t, int r, int b) {
+
+    super.onLayout(changed, l, t, r, b);
+
+    if (mLayoutWidth > 0 && mLayoutHeight > 0) {
+      // Gets original parameters, and creates the new parameters
+      ViewGroup.LayoutParams origParams = this.getLayoutParams();
+      origParams.width = mLayoutWidth;
+      origParams.height = mLayoutHeight;
+      setLayoutParams(origParams);
+
+      if (mBitmap != null) {
+        applyImageMatrix(r - l, b - t, true, false);
+
+        // after state restore we want to restore the window crop, possible only after widget size
+        // is known
+        if (mRestoreCropWindowRect != null) {
+          if (mRestoreDegreesRotated != mInitialDegreesRotated) {
+            mDegreesRotated = mRestoreDegreesRotated;
+            applyImageMatrix(r - l, b - t, true, false);
+          }
+          mImageMatrix.mapRect(mRestoreCropWindowRect);
+          mCropOverlayView.setCropWindowRect(mRestoreCropWindowRect);
+          handleCropWindowChanged(false, false);
+          mCropOverlayView.fixCurrentCropWindowRect();
+          mRestoreCropWindowRect = null;
+        } else if (mSizeChanged) {
+          mSizeChanged = false;
+          handleCropWindowChanged(false, false);
+        }
+      } else {
+        updateImageBounds(true);
+      }
+    } else {
+      updateImageBounds(true);
+    }
+  }
+
+  /**
+   * Detect size change to handle auto-zoom using {@link #handleCropWindowChanged(boolean, boolean)}
+   * in {@link #layout(int, int, int, int)}.
+   */
+  @Override
+  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+    super.onSizeChanged(w, h, oldw, oldh);
+    mSizeChanged = oldw > 0 && oldh > 0;
+  }
+
+  /**
+   * Handle crop window change to:<br>
+   * 1. Execute auto-zoom-in/out depending on the area covered of cropping window relative to the
+   * available view area.<br>
+   * 2. Slide the zoomed sub-area if the cropping window is outside of the visible view sub-area.
+   * <br>
+   *
+   * @param inProgress is the crop window change is still in progress by the user
+   * @param animate if to animate the change to the image matrix, or set it directly
+   */
+  private void handleCropWindowChanged(boolean inProgress, boolean animate) {
+    int width = getWidth();
+    int height = getHeight();
+    if (mBitmap != null && width > 0 && height > 0) {
+
+      RectF cropRect = mCropOverlayView.getCropWindowRect();
+      if (inProgress) {
+        if (cropRect.left < 0
+            || cropRect.top < 0
+            || cropRect.right > width
+            || cropRect.bottom > height) {
+          applyImageMatrix(width, height, false, false);
+        }
+      } else if (mAutoZoomEnabled || mZoom > 1) {
+        float newZoom = 0;
+        // keep the cropping window covered area to 50%-65% of zoomed sub-area
+        if (mZoom < mMaxZoom
+            && cropRect.width() < width * 0.5f
+            && cropRect.height() < height * 0.5f) {
+          newZoom =
+              Math.min(
+                  mMaxZoom,
+                  Math.min(
+                      width / (cropRect.width() / mZoom / 0.64f),
+                      height / (cropRect.height() / mZoom / 0.64f)));
+        }
+        if (mZoom > 1 && (cropRect.width() > width * 0.65f || cropRect.height() > height * 0.65f)) {
+          newZoom =
+              Math.max(
+                  1,
+                  Math.min(
+                      width / (cropRect.width() / mZoom / 0.51f),
+                      height / (cropRect.height() / mZoom / 0.51f)));
+        }
+        if (!mAutoZoomEnabled) {
+          newZoom = 1;
+        }
+
+        if (newZoom > 0 && newZoom != mZoom) {
+          if (animate) {
+            if (mAnimation == null) {
+              // lazy create animation single instance
+              mAnimation = new CropImageAnimation(mImageView, mCropOverlayView);
+            }
+            // set the state for animation to start from
+            mAnimation.setStartState(mImagePoints, mImageMatrix);
+          }
+
+          mZoom = newZoom;
+
+          applyImageMatrix(width, height, true, animate);
+        }
+      }
+      if (mOnSetCropWindowChangeListener != null && !inProgress) {
+        mOnSetCropWindowChangeListener.onCropWindowChanged();
+      }
+    }
+  }
+
+  /**
+   * Apply matrix to handle the image inside the image view.
+   *
+   * @param width the width of the image view
+   * @param height the height of the image view
+   */
+  private void applyImageMatrix(float width, float height, boolean center, boolean animate) {
+    if (mBitmap != null && width > 0 && height > 0) {
+
+      mImageMatrix.invert(mImageInverseMatrix);
+      RectF cropRect = mCropOverlayView.getCropWindowRect();
+      mImageInverseMatrix.mapRect(cropRect);
+
+      mImageMatrix.reset();
+
+      // move the image to the center of the image view first so we can manipulate it from there
+      mImageMatrix.postTranslate(
+          (width - mBitmap.getWidth()) / 2, (height - mBitmap.getHeight()) / 2);
+      mapImagePointsByImageMatrix();
+
+      // rotate the image the required degrees from center of image
+      if (mDegreesRotated > 0) {
+        mImageMatrix.postRotate(
+            mDegreesRotated,
+            BitmapUtils.getRectCenterX(mImagePoints),
+            BitmapUtils.getRectCenterY(mImagePoints));
+        mapImagePointsByImageMatrix();
+      }
+
+      // scale the image to the image view, image rect transformed to know new width/height
+      float scale =
+          Math.min(
+              width / BitmapUtils.getRectWidth(mImagePoints),
+              height / BitmapUtils.getRectHeight(mImagePoints));
+      if (mScaleType == ScaleType.FIT_CENTER
+          || (mScaleType == ScaleType.CENTER_INSIDE && scale < 1)
+          || (scale > 1 && mAutoZoomEnabled)) {
+        mImageMatrix.postScale(
+            scale,
+            scale,
+            BitmapUtils.getRectCenterX(mImagePoints),
+            BitmapUtils.getRectCenterY(mImagePoints));
+        mapImagePointsByImageMatrix();
+      }
+
+      // scale by the current zoom level
+      float scaleX = mFlipHorizontally ? -mZoom : mZoom;
+      float scaleY = mFlipVertically ? -mZoom : mZoom;
+      mImageMatrix.postScale(
+          scaleX,
+          scaleY,
+          BitmapUtils.getRectCenterX(mImagePoints),
+          BitmapUtils.getRectCenterY(mImagePoints));
+      mapImagePointsByImageMatrix();
+
+      mImageMatrix.mapRect(cropRect);
+
+      if (center) {
+        // set the zoomed area to be as to the center of cropping window as possible
+        mZoomOffsetX =
+            width > BitmapUtils.getRectWidth(mImagePoints)
+                ? 0
+                : Math.max(
+                        Math.min(
+                            width / 2 - cropRect.centerX(), -BitmapUtils.getRectLeft(mImagePoints)),
+                        getWidth() - BitmapUtils.getRectRight(mImagePoints))
+                    / scaleX;
+        mZoomOffsetY =
+            height > BitmapUtils.getRectHeight(mImagePoints)
+                ? 0
+                : Math.max(
+                        Math.min(
+                            height / 2 - cropRect.centerY(), -BitmapUtils.getRectTop(mImagePoints)),
+                        getHeight() - BitmapUtils.getRectBottom(mImagePoints))
+                    / scaleY;
+      } else {
+        // adjust the zoomed area so the crop window rectangle will be inside the area in case it
+        // was moved outside
+        mZoomOffsetX =
+            Math.min(Math.max(mZoomOffsetX * scaleX, -cropRect.left), -cropRect.right + width)
+                / scaleX;
+        mZoomOffsetY =
+            Math.min(Math.max(mZoomOffsetY * scaleY, -cropRect.top), -cropRect.bottom + height)
+                / scaleY;
+      }
+
+      // apply to zoom offset translate and update the crop rectangle to offset correctly
+      mImageMatrix.postTranslate(mZoomOffsetX * scaleX, mZoomOffsetY * scaleY);
+      cropRect.offset(mZoomOffsetX * scaleX, mZoomOffsetY * scaleY);
+      mCropOverlayView.setCropWindowRect(cropRect);
+      mapImagePointsByImageMatrix();
+      mCropOverlayView.invalidate();
+
+      // set matrix to apply
+      if (animate) {
+        // set the state for animation to end in, start animation now
+        mAnimation.setEndState(mImagePoints, mImageMatrix);
+        mImageView.startAnimation(mAnimation);
+      } else {
+        mImageView.setImageMatrix(mImageMatrix);
+      }
+
+      // update the image rectangle in the crop overlay
+      updateImageBounds(false);
+    }
+  }
+
+  /**
+   * Adjust the given image rectangle by image transformation matrix to know the final rectangle of
+   * the image.<br>
+   * To get the proper rectangle it must be first reset to original image rectangle.
+   */
+  private void mapImagePointsByImageMatrix() {
+    mImagePoints[0] = 0;
+    mImagePoints[1] = 0;
+    mImagePoints[2] = mBitmap.getWidth();
+    mImagePoints[3] = 0;
+    mImagePoints[4] = mBitmap.getWidth();
+    mImagePoints[5] = mBitmap.getHeight();
+    mImagePoints[6] = 0;
+    mImagePoints[7] = mBitmap.getHeight();
+    mImageMatrix.mapPoints(mImagePoints);
+    mScaleImagePoints[0] = 0;
+    mScaleImagePoints[1] = 0;
+    mScaleImagePoints[2] = 100;
+    mScaleImagePoints[3] = 0;
+    mScaleImagePoints[4] = 100;
+    mScaleImagePoints[5] = 100;
+    mScaleImagePoints[6] = 0;
+    mScaleImagePoints[7] = 100;
+    mImageMatrix.mapPoints(mScaleImagePoints);
+  }
+
+  /**
+   * Determines the specs for the onMeasure function. Calculates the width or height depending on
+   * the mode.
+   *
+   * @param measureSpecMode The mode of the measured width or height.
+   * @param measureSpecSize The size of the measured width or height.
+   * @param desiredSize The desired size of the measured width or height.
+   * @return The final size of the width or height.
+   */
+  private static int getOnMeasureSpec(int measureSpecMode, int measureSpecSize, int desiredSize) {
+
+    // Measure Width
+    int spec;
+    if (measureSpecMode == MeasureSpec.EXACTLY) {
+      // Must be this size
+      spec = measureSpecSize;
+    } else if (measureSpecMode == MeasureSpec.AT_MOST) {
+      // Can't be bigger than...; match_parent value
+      spec = Math.min(desiredSize, measureSpecSize);
+    } else {
+      // Be whatever you want; wrap_content
+      spec = desiredSize;
+    }
+
+    return spec;
+  }
+
+  /**
+   * Set visibility of crop overlay to hide it when there is no image or specificly set by client.
+   */
+  private void setCropOverlayVisibility() {
+    if (mCropOverlayView != null) {
+      mCropOverlayView.setVisibility(mShowCropOverlay && mBitmap != null ? VISIBLE : INVISIBLE);
+    }
+  }
+
+  /**
+   * Set visibility of progress bar when async loading/cropping is in process and show is enabled.
+   */
+  private void setProgressBarVisibility() {
+    boolean visible =
+        mShowProgressBar
+            && (mBitmap == null && mBitmapLoadingWorkerTask != null
+                || mBitmapCroppingWorkerTask != null);
+    mProgressBar.setVisibility(visible ? VISIBLE : INVISIBLE);
+  }
+
+  /** Update the scale factor between the actual image bitmap and the shown image.<br> */
+  private void updateImageBounds(boolean clear) {
+    if (mBitmap != null && !clear) {
+
+      // Get the scale factor between the actual Bitmap dimensions and the displayed dimensions for
+      // width/height.
+      float scaleFactorWidth =
+          100f * mLoadedSampleSize / BitmapUtils.getRectWidth(mScaleImagePoints);
+      float scaleFactorHeight =
+          100f * mLoadedSampleSize / BitmapUtils.getRectHeight(mScaleImagePoints);
+      mCropOverlayView.setCropWindowLimits(
+          getWidth(), getHeight(), scaleFactorWidth, scaleFactorHeight);
+    }
+
+    // set the bitmap rectangle and update the crop window after scale factor is set
+    mCropOverlayView.setBounds(clear ? null : mImagePoints, getWidth(), getHeight());
+  }
+  // endregion
+
+  // region: Inner class: CropShape
+
+  /**
+   * The possible cropping area shape.<br>
+   * To set square/circle crop shape set aspect ratio to 1:1.
+   */
+  public enum CropShape {
+    RECTANGLE,
+    OVAL
+  }
+  // endregion
+
+  // region: Inner class: ScaleType
+
+  /**
+   * Options for scaling the bounds of cropping image to the bounds of Crop Image View.<br>
+   * Note: Some options are affected by auto-zoom, if enabled.
+   */
+  public enum ScaleType {
+
+    /**
+     * Scale the image uniformly (maintain the image's aspect ratio) to fit in crop image view.<br>
+     * The largest dimension will be equals to crop image view and the second dimension will be
+     * smaller.
+     */
+    FIT_CENTER,
+
+    /**
+     * Center the image in the view, but perform no scaling.<br>
+     * Note: If auto-zoom is enabled and the source image is smaller than crop image view then it
+     * will be scaled uniformly to fit the crop image view.
+     */
+    CENTER,
+
+    /**
+     * Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width
+     * and height) of the image will be equal to or <b>larger</b> than the corresponding dimension
+     * of the view (minus padding).<br>
+     * The image is then centered in the view.
+     */
+    CENTER_CROP,
+
+    /**
+     * Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width
+     * and height) of the image will be equal to or <b>less</b> than the corresponding dimension of
+     * the view (minus padding).<br>
+     * The image is then centered in the view.<br>
+     * Note: If auto-zoom is enabled and the source image is smaller than crop image view then it
+     * will be scaled uniformly to fit the crop image view.
+     */
+    CENTER_INSIDE
+  }
+  // endregion
+
+  // region: Inner class: Guidelines
+
+  /** The possible guidelines showing types. */
+  public enum Guidelines {
+    /** Never show */
+    OFF,
+
+    /** Show when crop move action is live */
+    ON_TOUCH,
+
+    /** Always show */
+    ON
+  }
+  // endregion
+
+  // region: Inner class: RequestSizeOptions
+
+  /** Possible options for handling requested width/height for cropping. */
+  public enum RequestSizeOptions {
+
+    /** No resize/sampling is done unless required for memory management (OOM). */
+    NONE,
+
+    /**
+     * Only sample the image during loading (if image set using URI) so the smallest of the image
+     * dimensions will be between the requested size and x2 requested size.<br>
+     * NOTE: resulting image will not be exactly requested width/height see: <a
+     * href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html">Loading
+     * Large Bitmaps Efficiently</a>.
+     */
+    SAMPLING,
+
+    /**
+     * Resize the image uniformly (maintain the image's aspect ratio) so that both dimensions (width
+     * and height) of the image will be equal to or <b>less</b> than the corresponding requested
+     * dimension.<br>
+     * If the image is smaller than the requested size it will NOT change.
+     */
+    RESIZE_INSIDE,
+
+    /**
+     * Resize the image uniformly (maintain the image's aspect ratio) to fit in the given
+     * width/height.<br>
+     * The largest dimension will be equals to the requested and the second dimension will be
+     * smaller.<br>
+     * If the image is smaller than the requested size it will enlarge it.
+     */
+    RESIZE_FIT,
+
+    /**
+     * Resize the image to fit exactly in the given width/height.<br>
+     * This resize method does NOT preserve aspect ratio.<br>
+     * If the image is smaller than the requested size it will enlarge it.
+     */
+    RESIZE_EXACT
+  }
+  // endregion
+
+  // region: Inner class: OnSetImageUriCompleteListener
+
+  /** Interface definition for a callback to be invoked when the crop overlay is released. */
+  public interface OnSetCropOverlayReleasedListener {
+
+    /**
+     * Called when the crop overlay changed listener is called and inProgress is false.
+     *
+     * @param rect The rect coordinates of the cropped overlay
+     */
+    void onCropOverlayReleased(Rect rect);
+  }
+
+  /** Interface definition for a callback to be invoked when the crop overlay is released. */
+  public interface OnSetCropOverlayMovedListener {
+
+    /**
+     * Called when the crop overlay is moved
+     *
+     * @param rect The rect coordinates of the cropped overlay
+     */
+    void onCropOverlayMoved(Rect rect);
+  }
+
+  /** Interface definition for a callback to be invoked when the crop overlay is released. */
+  public interface OnSetCropWindowChangeListener {
+
+    /** Called when the crop window is changed */
+    void onCropWindowChanged();
+  }
+
+  /** Interface definition for a callback to be invoked when image async loading is complete. */
+  public interface OnSetImageUriCompleteListener {
+
+    /**
+     * Called when a crop image view has completed loading image for cropping.<br>
+     * If loading failed error parameter will contain the error.
+     *
+     * @param view The crop image view that loading of image was complete.
+     * @param uri the URI of the image that was loading
+     * @param error if error occurred during loading will contain the error, otherwise null.
+     */
+    void onSetImageUriComplete(CropImageView view, Uri uri, Exception error);
+  }
+  // endregion
+
+  // region: Inner class: OnGetCroppedImageCompleteListener
+
+  /** Interface definition for a callback to be invoked when image async crop is complete. */
+  public interface OnCropImageCompleteListener {
+
+    /**
+     * Called when a crop image view has completed cropping image.<br>
+     * Result object contains the cropped bitmap, saved cropped image uri, crop points data or the
+     * error occured during cropping.
+     *
+     * @param view The crop image view that cropping of image was complete.
+     * @param result the crop image result data (with cropped image or error)
+     */
+    void onCropImageComplete(CropImageView view, CropResult result);
+  }
+  // endregion
+
+  // region: Inner class: ActivityResult
+
+  /** Result data of crop image. */
+  public static class CropResult {
+
+    /**
+     * The image bitmap of the original image loaded for cropping.<br>
+     * Null if uri used to load image or activity result is used.
+     */
+    private final Bitmap mOriginalBitmap;
+
+    /**
+     * The Android uri of the original image loaded for cropping.<br>
+     * Null if bitmap was used to load image.
+     */
+    private final Uri mOriginalUri;
+
+    /**
+     * The cropped image bitmap result.<br>
+     * Null if save cropped image was executed, no output requested or failure.
+     */
+    private final Bitmap mBitmap;
+
+    /**
+     * The Android uri of the saved cropped image result.<br>
+     * Null if get cropped image was executed, no output requested or failure.
+     */
+    private final Uri mUri;
+
+    /** The error that failed the loading/cropping (null if successful) */
+    private final Exception mError;
+
+    /** The 4 points of the cropping window in the source image */
+    private final float[] mCropPoints;
+
+    /** The rectangle of the cropping window in the source image */
+    private final Rect mCropRect;
+
+    /** The rectangle of the source image dimensions */
+    private final Rect mWholeImageRect;
+
+    /** The final rotation of the cropped image relative to source */
+    private final int mRotation;
+
+    /** sample size used creating the crop bitmap to lower its size */
+    private final int mSampleSize;
+
+    CropResult(
+        Bitmap originalBitmap,
+        Uri originalUri,
+        Bitmap bitmap,
+        Uri uri,
+        Exception error,
+        float[] cropPoints,
+        Rect cropRect,
+        Rect wholeImageRect,
+        int rotation,
+        int sampleSize) {
+      mOriginalBitmap = originalBitmap;
+      mOriginalUri = originalUri;
+      mBitmap = bitmap;
+      mUri = uri;
+      mError = error;
+      mCropPoints = cropPoints;
+      mCropRect = cropRect;
+      mWholeImageRect = wholeImageRect;
+      mRotation = rotation;
+      mSampleSize = sampleSize;
+    }
+
+    /**
+     * The image bitmap of the original image loaded for cropping.<br>
+     * Null if uri used to load image or activity result is used.
+     */
+    public Bitmap getOriginalBitmap() {
+      return mOriginalBitmap;
+    }
+
+    /**
+     * The Android uri of the original image loaded for cropping.<br>
+     * Null if bitmap was used to load image.
+     */
+    public Uri getOriginalUri() {
+      return mOriginalUri;
+    }
+
+    /** Is the result is success or error. */
+    public boolean isSuccessful() {
+      return mError == null;
+    }
+
+    /**
+     * The cropped image bitmap result.<br>
+     * Null if save cropped image was executed, no output requested or failure.
+     */
+    public Bitmap getBitmap() {
+      return mBitmap;
+    }
+
+    /**
+     * The Android uri of the saved cropped image result Null if get cropped image was executed, no
+     * output requested or failure.
+     */
+    public Uri getUri() {
+      return mUri;
+    }
+
+    /** The error that failed the loading/cropping (null if successful) */
+    public Exception getError() {
+      return mError;
+    }
+
+    /** The 4 points of the cropping window in the source image */
+    public float[] getCropPoints() {
+      return mCropPoints;
+    }
+
+    /** The rectangle of the cropping window in the source image */
+    public Rect getCropRect() {
+      return mCropRect;
+    }
+
+    /** The rectangle of the source image dimensions */
+    public Rect getWholeImageRect() {
+      return mWholeImageRect;
+    }
+
+    /** The final rotation of the cropped image relative to source */
+    public int getRotation() {
+      return mRotation;
+    }
+
+    /** sample size used creating the crop bitmap to lower its size */
+    public int getSampleSize() {
+      return mSampleSize;
+    }
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropImageActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageActivity.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageActivity.java
new file mode 100644
--- /dev/null	(date 1726418597234)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageActivity.java	(date 1726418597234)
@@ -0,0 +1,353 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.Manifest;
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import androidx.annotation.NonNull;
+import androidx.core.content.ContextCompat;
+import androidx.appcompat.app.ActionBar;
+import androidx.appcompat.app.AppCompatActivity;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import com.qboxus.binder.R;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Built-in activity for image cropping.<br>
+ * Use {@link CropImage#activity(Uri)} to create a builder to start this activity.
+ */
+public class CropImageActivity extends AppCompatActivity
+    implements CropImageView.OnSetImageUriCompleteListener,
+        CropImageView.OnCropImageCompleteListener {
+
+  /** The crop image view library widget used in the activity */
+  private CropImageView mCropImageView;
+
+  /** Persist URI image to crop URI if specific permissions are required */
+  private Uri mCropImageUri;
+
+  /** the options that were set for the crop image */
+  private CropImageOptions mOptions;
+
+  @Override
+  @SuppressLint("NewApi")
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.crop_image_activity);
+
+    mCropImageView = findViewById(R.id.cropImageView);
+
+    Bundle bundle = getIntent().getBundleExtra(CropImage.CROP_IMAGE_EXTRA_BUNDLE);
+    mCropImageUri = bundle.getParcelable(CropImage.CROP_IMAGE_EXTRA_SOURCE);
+    mOptions = bundle.getParcelable(CropImage.CROP_IMAGE_EXTRA_OPTIONS);
+
+    if (savedInstanceState == null) {
+      if (mCropImageUri == null || mCropImageUri.equals(Uri.EMPTY)) {
+        if (CropImage.isExplicitCameraPermissionRequired(this)) {
+          // request permissions and handle the result in onRequestPermissionsResult()
+          requestPermissions(
+              new String[] {Manifest.permission.CAMERA},
+              CropImage.CAMERA_CAPTURE_PERMISSIONS_REQUEST_CODE);
+        } else {
+          CropImage.startPickImageActivity(this);
+        }
+      } else if (CropImage.isReadExternalStoragePermissionsRequired(this, mCropImageUri)) {
+        // request permissions and handle the result in onRequestPermissionsResult()
+        requestPermissions(
+            new String[] {Manifest.permission.READ_EXTERNAL_STORAGE},
+            CropImage.PICK_IMAGE_PERMISSIONS_REQUEST_CODE);
+      } else {
+        // no permissions required or already grunted, can start crop image activity
+        mCropImageView.setImageUriAsync(mCropImageUri);
+      }
+    }
+
+    ActionBar actionBar = getSupportActionBar();
+    if (actionBar != null) {
+      CharSequence title = mOptions != null &&
+          mOptions.activityTitle != null && mOptions.activityTitle.length() > 0
+              ? mOptions.activityTitle
+              : getResources().getString(R.string.crop_image_activity_title);
+      actionBar.setTitle(title);
+      actionBar.setDisplayHomeAsUpEnabled(true);
+    }
+  }
+
+  @Override
+  protected void onStart() {
+    super.onStart();
+    mCropImageView.setOnSetImageUriCompleteListener(this);
+    mCropImageView.setOnCropImageCompleteListener(this);
+  }
+
+  @Override
+  protected void onStop() {
+    super.onStop();
+    mCropImageView.setOnSetImageUriCompleteListener(null);
+    mCropImageView.setOnCropImageCompleteListener(null);
+  }
+
+  @Override
+  public boolean onCreateOptionsMenu(Menu menu) {
+    getMenuInflater().inflate(R.menu.crop_image_menu, menu);
+
+    if (!mOptions.allowRotation) {
+      menu.removeItem(R.id.crop_image_menu_rotate_left);
+      menu.removeItem(R.id.crop_image_menu_rotate_right);
+    } else if (mOptions.allowCounterRotation) {
+      menu.findItem(R.id.crop_image_menu_rotate_left).setVisible(true);
+    }
+
+    if (!mOptions.allowFlipping) {
+      menu.removeItem(R.id.crop_image_menu_flip);
+    }
+
+    if (mOptions.cropMenuCropButtonTitle != null) {
+      menu.findItem(R.id.crop_image_menu_crop).setTitle(mOptions.cropMenuCropButtonTitle);
+    }
+
+    Drawable cropIcon = null;
+    try {
+      if (mOptions.cropMenuCropButtonIcon != 0) {
+        cropIcon = ContextCompat.getDrawable(this, mOptions.cropMenuCropButtonIcon);
+        menu.findItem(R.id.crop_image_menu_crop).setIcon(cropIcon);
+      }
+    } catch (Exception e) {
+      Log.w("AIC", "Failed to read menu crop drawable", e);
+    }
+
+    if (mOptions.activityMenuIconColor != 0) {
+      updateMenuItemIconColor(
+          menu, R.id.crop_image_menu_rotate_left, mOptions.activityMenuIconColor);
+      updateMenuItemIconColor(
+          menu, R.id.crop_image_menu_rotate_right, mOptions.activityMenuIconColor);
+      updateMenuItemIconColor(menu, R.id.crop_image_menu_flip, mOptions.activityMenuIconColor);
+      if (cropIcon != null) {
+        updateMenuItemIconColor(menu, R.id.crop_image_menu_crop, mOptions.activityMenuIconColor);
+      }
+    }
+    return true;
+  }
+
+  @Override
+  public boolean onOptionsItemSelected(MenuItem item) {
+    if (item.getItemId() == R.id.crop_image_menu_crop) {
+      cropImage();
+      return true;
+    }
+    if (item.getItemId() == R.id.crop_image_menu_rotate_left) {
+      rotateImage(-mOptions.rotationDegrees);
+      return true;
+    }
+    if (item.getItemId() == R.id.crop_image_menu_rotate_right) {
+      rotateImage(mOptions.rotationDegrees);
+      return true;
+    }
+    if (item.getItemId() == R.id.crop_image_menu_flip_horizontally) {
+      mCropImageView.flipImageHorizontally();
+      return true;
+    }
+    if (item.getItemId() == R.id.crop_image_menu_flip_vertically) {
+      mCropImageView.flipImageVertically();
+      return true;
+    }
+    if (item.getItemId() == android.R.id.home) {
+      setResultCancel();
+      return true;
+    }
+    return super.onOptionsItemSelected(item);
+  }
+
+  @Override
+  public void onBackPressed() {
+    super.onBackPressed();
+    setResultCancel();
+  }
+
+  @Override
+  @SuppressLint("NewApi")
+  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+
+    // handle result of pick image chooser
+    super.onActivityResult (requestCode, resultCode, data);
+    if (requestCode == CropImage.PICK_IMAGE_CHOOSER_REQUEST_CODE) {
+      if (resultCode == Activity.RESULT_CANCELED) {
+        // User cancelled the picker. We don't have anything to crop
+        setResultCancel ();
+      }
+
+      if (resultCode == Activity.RESULT_OK) {
+        mCropImageUri = CropImage.getPickImageResultUri (this, data);
+
+        // For API >= 23 we need to check specifically that we have permissions to read external
+        // storage.
+        if (CropImage.isReadExternalStoragePermissionsRequired (this, mCropImageUri)) {
+          // request permissions and handle the result in onRequestPermissionsResult()
+          requestPermissions (
+                  new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},
+                  CropImage.PICK_IMAGE_PERMISSIONS_REQUEST_CODE);
+        } else {
+          // no permissions required or already grunted, can start crop image activity
+          mCropImageView.setImageUriAsync (mCropImageUri);
+        }
+      }
+    }
+  }
+
+  @Override
+  public void onRequestPermissionsResult(
+      int requestCode, @NonNull String permissions[], @NonNull int[] grantResults) {
+    if (requestCode == CropImage.PICK_IMAGE_PERMISSIONS_REQUEST_CODE) {
+      if (mCropImageUri != null
+          && grantResults.length > 0
+          && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+        // required permissions granted, start crop image activity
+        mCropImageView.setImageUriAsync(mCropImageUri);
+      } else {
+        Toast.makeText(this, R.string.crop_image_activity_no_permissions, Toast.LENGTH_LONG).show();
+        setResultCancel();
+      }
+    }
+
+    if (requestCode == CropImage.CAMERA_CAPTURE_PERMISSIONS_REQUEST_CODE) {
+      // Irrespective of whether camera permission was given or not, we show the picker
+      // The picker will not add the camera intent if permission is not available
+      CropImage.startPickImageActivity(this);
+    }
+  }
+
+  @Override
+  public void onSetImageUriComplete(CropImageView view, Uri uri, Exception error) {
+    if (error == null) {
+      if (mOptions.initialCropWindowRectangle != null) {
+        mCropImageView.setCropRect(mOptions.initialCropWindowRectangle);
+      }
+      if (mOptions.initialRotation > -1) {
+        mCropImageView.setRotatedDegrees(mOptions.initialRotation);
+      }
+    } else {
+      setResult(null, error, 1);
+    }
+  }
+
+  @Override
+  public void onCropImageComplete(CropImageView view, CropImageView.CropResult result) {
+    setResult(result.getUri(), result.getError(), result.getSampleSize());
+  }
+
+  // region: Private methods
+
+  /** Execute crop image and save the result tou output uri. */
+  protected void cropImage() {
+    if (mOptions.noOutputImage) {
+      setResult(null, null, 1);
+    } else {
+      Uri outputUri = getOutputUri();
+      mCropImageView.saveCroppedImageAsync(
+          outputUri,
+          mOptions.outputCompressFormat,
+          mOptions.outputCompressQuality,
+          mOptions.outputRequestWidth,
+          mOptions.outputRequestHeight,
+          mOptions.outputRequestSizeOptions);
+    }
+  }
+
+  /** Rotate the image in the crop image view. */
+  protected void rotateImage(int degrees) {
+    mCropImageView.rotateImage(degrees);
+  }
+
+  /**
+   * Get Android uri to save the cropped image into.<br>
+   * Use the given in options or create a temp file.
+   */
+  protected Uri getOutputUri() {
+    Uri outputUri = mOptions.outputUri;
+    if (outputUri == null || outputUri.equals(Uri.EMPTY)) {
+      try {
+        String ext =
+            mOptions.outputCompressFormat == Bitmap.CompressFormat.JPEG
+                ? ".jpg"
+                : mOptions.outputCompressFormat == Bitmap.CompressFormat.PNG ? ".png" : ".webp";
+        outputUri = Uri.fromFile(File.createTempFile("cropped", ext, getCacheDir()));
+      } catch (IOException e) {
+        throw new RuntimeException("Failed to create temp file for output image", e);
+      }
+    }
+    return outputUri;
+  }
+
+  /** Result with cropped image data or error if failed. */
+  protected void setResult(Uri uri, Exception error, int sampleSize) {
+    int resultCode = error == null ? RESULT_OK : CropImage.CROP_IMAGE_ACTIVITY_RESULT_ERROR_CODE;
+    setResult(resultCode, getResultIntent(uri, error, sampleSize));
+    finish();
+  }
+
+  /** Cancel of cropping activity. */
+  protected void setResultCancel() {
+    setResult(RESULT_CANCELED);
+    finish();
+  }
+
+  /** Get intent instance to be used for the result of this activity. */
+  protected Intent getResultIntent(Uri uri, Exception error, int sampleSize) {
+    CropImage.ActivityResult result =
+        new CropImage.ActivityResult(
+            mCropImageView.getImageUri(),
+            uri,
+            error,
+            mCropImageView.getCropPoints(),
+            mCropImageView.getCropRect(),
+            mCropImageView.getRotatedDegrees(),
+            mCropImageView.getWholeImageRect(),
+            sampleSize);
+    Intent intent = new Intent();
+    intent.putExtras(getIntent());
+    intent.putExtra(CropImage.CROP_IMAGE_EXTRA_RESULT, result);
+    return intent;
+  }
+
+  /** Update the color of a specific menu item to the given color. */
+  private void updateMenuItemIconColor(Menu menu, int itemId, int color) {
+    MenuItem menuItem = menu.findItem(itemId);
+    if (menuItem != null) {
+      Drawable menuItemIcon = menuItem.getIcon();
+      if (menuItemIcon != null) {
+        try {
+          menuItemIcon.mutate();
+          menuItemIcon.setColorFilter(color, PorterDuff.Mode.SRC_ATOP);
+          menuItem.setIcon(menuItemIcon);
+        } catch (Exception e) {
+          Log.w("AIC", "Failed to update menu item color", e);
+        }
+      }
+    }
+  }
+  // endregion
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/CropImageOptions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageOptions.java b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageOptions.java
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/CropImageOptions.java	(date 1694964014000)
@@ -0,0 +1,463 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth;
+// inexhaustible as the great rivers.
+// When they come to an end;
+// they begin again;
+// like the days and months;
+// they die and are reborn;
+// like the four seasons."
+//
+// - Sun Tsu;
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.util.TypedValue;
+
+/**
+ * All the possible options that can be set to customize crop image.<br>
+ * Initialized with default values.
+ */
+public class CropImageOptions implements Parcelable {
+
+  public static final Creator<CropImageOptions> CREATOR =
+      new Creator<CropImageOptions>() {
+        @Override
+        public CropImageOptions createFromParcel(Parcel in) {
+          return new CropImageOptions(in);
+        }
+
+        @Override
+        public CropImageOptions[] newArray(int size) {
+          return new CropImageOptions[size];
+        }
+      };
+
+  /** The shape of the cropping window. */
+  public CropImageView.CropShape cropShape;
+
+  /**
+   * An edge of the crop window will snap to the corresponding edge of a specified bounding box when
+   * the crop window edge is less than or equal to this distance (in pixels) away from the bounding
+   * box edge. (in pixels)
+   */
+  public float snapRadius;
+
+  /**
+   * The radius of the touchable area around the handle. (in pixels)<br>
+   * We are basing this value off of the recommended 48dp Rhythm.<br>
+   * See: http://developer.android.com/design/style/metrics-grids.html#48dp-rhythm
+   */
+  public float touchRadius;
+
+  /** whether the guidelines should be on, off, or only showing when resizing. */
+  public CropImageView.Guidelines guidelines;
+
+  /** The initial scale type of the image in the crop image view */
+  public CropImageView.ScaleType scaleType;
+
+  /**
+   * if to show crop overlay UI what contains the crop window UI surrounded by background over the
+   * cropping image.<br>
+   * default: true, may disable for animation or frame transition.
+   */
+  public boolean showCropOverlay;
+
+  /**
+   * if to show progress bar when image async loading/cropping is in progress.<br>
+   * default: true, disable to provide custom progress bar UI.
+   */
+  public boolean showProgressBar;
+
+  /**
+   * if auto-zoom functionality is enabled.<br>
+   * default: true.
+   */
+  public boolean autoZoomEnabled;
+
+  /** if multi-touch should be enabled on the crop box default: false */
+  public boolean multiTouchEnabled;
+
+  /** The max zoom allowed during cropping. */
+  public int maxZoom;
+
+  /**
+   * The initial crop window padding from image borders in percentage of the cropping image
+   * dimensions.
+   */
+  public float initialCropWindowPaddingRatio;
+
+  /** whether the width to height aspect ratio should be maintained or free to change. */
+  public boolean fixAspectRatio;
+
+  /** the X value of the aspect ratio. */
+  public int aspectRatioX;
+
+  /** the Y value of the aspect ratio. */
+  public int aspectRatioY;
+
+  /** the thickness of the guidelines lines in pixels. (in pixels) */
+  public float borderLineThickness;
+
+  /** the color of the guidelines lines */
+  public int borderLineColor;
+
+  /** thickness of the corner line. (in pixels) */
+  public float borderCornerThickness;
+
+  /** the offset of corner line from crop window border. (in pixels) */
+  public float borderCornerOffset;
+
+  /** the length of the corner line away from the corner. (in pixels) */
+  public float borderCornerLength;
+
+  /** the color of the corner line */
+  public int borderCornerColor;
+
+  /** the thickness of the guidelines lines. (in pixels) */
+  public float guidelinesThickness;
+
+  /** the color of the guidelines lines */
+  public int guidelinesColor;
+
+  /**
+   * the color of the overlay background around the crop window cover the image parts not in the
+   * crop window.
+   */
+  public int backgroundColor;
+
+  /** the min width the crop window is allowed to be. (in pixels) */
+  public int minCropWindowWidth;
+
+  /** the min height the crop window is allowed to be. (in pixels) */
+  public int minCropWindowHeight;
+
+  /**
+   * the min width the resulting cropping image is allowed to be, affects the cropping window
+   * limits. (in pixels)
+   */
+  public int minCropResultWidth;
+
+  /**
+   * the min height the resulting cropping image is allowed to be, affects the cropping window
+   * limits. (in pixels)
+   */
+  public int minCropResultHeight;
+
+  /**
+   * the max width the resulting cropping image is allowed to be, affects the cropping window
+   * limits. (in pixels)
+   */
+  public int maxCropResultWidth;
+
+  /**
+   * the max height the resulting cropping image is allowed to be, affects the cropping window
+   * limits. (in pixels)
+   */
+  public int maxCropResultHeight;
+
+  /** the title of the {@link CropImageActivity} */
+  public CharSequence activityTitle;
+
+  /** the color to use for action bar items icons */
+  public int activityMenuIconColor;
+
+  /** the Android Uri to save the cropped image to */
+  public Uri outputUri;
+
+  /** the compression format to use when writing the image */
+  public Bitmap.CompressFormat outputCompressFormat;
+
+  /** the quality (if applicable) to use when writing the image (0 - 100) */
+  public int outputCompressQuality;
+
+  /** the width to resize the cropped image to (see options) */
+  public int outputRequestWidth;
+
+  /** the height to resize the cropped image to (see options) */
+  public int outputRequestHeight;
+
+  /** the resize method to use on the cropped bitmap (see options documentation) */
+  public CropImageView.RequestSizeOptions outputRequestSizeOptions;
+
+  /** if the result of crop image activity should not save the cropped image bitmap */
+  public boolean noOutputImage;
+
+  /** the initial rectangle to set on the cropping image after loading */
+  public Rect initialCropWindowRectangle;
+
+  /** the initial rotation to set on the cropping image after loading (0-360 degrees clockwise) */
+  public int initialRotation;
+
+  /** if to allow (all) rotation during cropping (activity) */
+  public boolean allowRotation;
+
+  /** if to allow (all) flipping during cropping (activity) */
+  public boolean allowFlipping;
+
+  /** if to allow counter-clockwise rotation during cropping (activity) */
+  public boolean allowCounterRotation;
+
+  /** the amount of degrees to rotate clockwise or counter-clockwise */
+  public int rotationDegrees;
+
+  /** whether the image should be flipped horizontally */
+  public boolean flipHorizontally;
+
+  /** whether the image should be flipped vertically */
+  public boolean flipVertically;
+
+  /** optional, the text of the crop menu crop button */
+  public CharSequence cropMenuCropButtonTitle;
+
+  /** optional image resource to be used for crop menu crop icon instead of text */
+  public int cropMenuCropButtonIcon;
+
+  /** Init options with defaults. */
+  public CropImageOptions() {
+
+    DisplayMetrics dm = Resources.getSystem().getDisplayMetrics();
+
+    cropShape = CropImageView.CropShape.RECTANGLE;
+    snapRadius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 3, dm);
+    touchRadius = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 24, dm);
+    guidelines = CropImageView.Guidelines.ON_TOUCH;
+    scaleType = CropImageView.ScaleType.FIT_CENTER;
+    showCropOverlay = true;
+    showProgressBar = true;
+    autoZoomEnabled = true;
+    multiTouchEnabled = false;
+    maxZoom = 4;
+    initialCropWindowPaddingRatio = 0.1f;
+
+    fixAspectRatio = false;
+    aspectRatioX = 1;
+    aspectRatioY = 1;
+
+    borderLineThickness = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 3, dm);
+    borderLineColor = Color.argb(170, 255, 255, 255);
+    borderCornerThickness = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, dm);
+    borderCornerOffset = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 5, dm);
+    borderCornerLength = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 14, dm);
+    borderCornerColor = Color.WHITE;
+
+    guidelinesThickness = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1, dm);
+    guidelinesColor = Color.argb(170, 255, 255, 255);
+    backgroundColor = Color.argb(119, 0, 0, 0);
+
+    minCropWindowWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 42, dm);
+    minCropWindowHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 42, dm);
+    minCropResultWidth = 40;
+    minCropResultHeight = 40;
+    maxCropResultWidth = 99999;
+    maxCropResultHeight = 99999;
+
+    activityTitle = "";
+    activityMenuIconColor = 0;
+
+    outputUri = Uri.EMPTY;
+    outputCompressFormat = Bitmap.CompressFormat.JPEG;
+    outputCompressQuality = 90;
+    outputRequestWidth = 0;
+    outputRequestHeight = 0;
+    outputRequestSizeOptions = CropImageView.RequestSizeOptions.NONE;
+    noOutputImage = false;
+
+    initialCropWindowRectangle = null;
+    initialRotation = -1;
+    allowRotation = true;
+    allowFlipping = true;
+    allowCounterRotation = false;
+    rotationDegrees = 90;
+    flipHorizontally = false;
+    flipVertically = false;
+    cropMenuCropButtonTitle = null;
+
+    cropMenuCropButtonIcon = 0;
+  }
+
+  /** Create object from parcel. */
+  protected CropImageOptions(Parcel in) {
+    cropShape = CropImageView.CropShape.values()[in.readInt()];
+    snapRadius = in.readFloat();
+    touchRadius = in.readFloat();
+    guidelines = CropImageView.Guidelines.values()[in.readInt()];
+    scaleType = CropImageView.ScaleType.values()[in.readInt()];
+    showCropOverlay = in.readByte() != 0;
+    showProgressBar = in.readByte() != 0;
+    autoZoomEnabled = in.readByte() != 0;
+    multiTouchEnabled = in.readByte() != 0;
+    maxZoom = in.readInt();
+    initialCropWindowPaddingRatio = in.readFloat();
+    fixAspectRatio = in.readByte() != 0;
+    aspectRatioX = in.readInt();
+    aspectRatioY = in.readInt();
+    borderLineThickness = in.readFloat();
+    borderLineColor = in.readInt();
+    borderCornerThickness = in.readFloat();
+    borderCornerOffset = in.readFloat();
+    borderCornerLength = in.readFloat();
+    borderCornerColor = in.readInt();
+    guidelinesThickness = in.readFloat();
+    guidelinesColor = in.readInt();
+    backgroundColor = in.readInt();
+    minCropWindowWidth = in.readInt();
+    minCropWindowHeight = in.readInt();
+    minCropResultWidth = in.readInt();
+    minCropResultHeight = in.readInt();
+    maxCropResultWidth = in.readInt();
+    maxCropResultHeight = in.readInt();
+    activityTitle = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
+    activityMenuIconColor = in.readInt();
+    outputUri = in.readParcelable(Uri.class.getClassLoader());
+    outputCompressFormat = Bitmap.CompressFormat.valueOf(in.readString());
+    outputCompressQuality = in.readInt();
+    outputRequestWidth = in.readInt();
+    outputRequestHeight = in.readInt();
+    outputRequestSizeOptions = CropImageView.RequestSizeOptions.values()[in.readInt()];
+    noOutputImage = in.readByte() != 0;
+    initialCropWindowRectangle = in.readParcelable(Rect.class.getClassLoader());
+    initialRotation = in.readInt();
+    allowRotation = in.readByte() != 0;
+    allowFlipping = in.readByte() != 0;
+    allowCounterRotation = in.readByte() != 0;
+    rotationDegrees = in.readInt();
+    flipHorizontally = in.readByte() != 0;
+    flipVertically = in.readByte() != 0;
+    cropMenuCropButtonTitle = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
+    cropMenuCropButtonIcon = in.readInt();
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(cropShape.ordinal());
+    dest.writeFloat(snapRadius);
+    dest.writeFloat(touchRadius);
+    dest.writeInt(guidelines.ordinal());
+    dest.writeInt(scaleType.ordinal());
+    dest.writeByte((byte) (showCropOverlay ? 1 : 0));
+    dest.writeByte((byte) (showProgressBar ? 1 : 0));
+    dest.writeByte((byte) (autoZoomEnabled ? 1 : 0));
+    dest.writeByte((byte) (multiTouchEnabled ? 1 : 0));
+    dest.writeInt(maxZoom);
+    dest.writeFloat(initialCropWindowPaddingRatio);
+    dest.writeByte((byte) (fixAspectRatio ? 1 : 0));
+    dest.writeInt(aspectRatioX);
+    dest.writeInt(aspectRatioY);
+    dest.writeFloat(borderLineThickness);
+    dest.writeInt(borderLineColor);
+    dest.writeFloat(borderCornerThickness);
+    dest.writeFloat(borderCornerOffset);
+    dest.writeFloat(borderCornerLength);
+    dest.writeInt(borderCornerColor);
+    dest.writeFloat(guidelinesThickness);
+    dest.writeInt(guidelinesColor);
+    dest.writeInt(backgroundColor);
+    dest.writeInt(minCropWindowWidth);
+    dest.writeInt(minCropWindowHeight);
+    dest.writeInt(minCropResultWidth);
+    dest.writeInt(minCropResultHeight);
+    dest.writeInt(maxCropResultWidth);
+    dest.writeInt(maxCropResultHeight);
+    TextUtils.writeToParcel(activityTitle, dest, flags);
+    dest.writeInt(activityMenuIconColor);
+    dest.writeParcelable(outputUri, flags);
+    dest.writeString(outputCompressFormat.name());
+    dest.writeInt(outputCompressQuality);
+    dest.writeInt(outputRequestWidth);
+    dest.writeInt(outputRequestHeight);
+    dest.writeInt(outputRequestSizeOptions.ordinal());
+    dest.writeInt(noOutputImage ? 1 : 0);
+    dest.writeParcelable(initialCropWindowRectangle, flags);
+    dest.writeInt(initialRotation);
+    dest.writeByte((byte) (allowRotation ? 1 : 0));
+    dest.writeByte((byte) (allowFlipping ? 1 : 0));
+    dest.writeByte((byte) (allowCounterRotation ? 1 : 0));
+    dest.writeInt(rotationDegrees);
+    dest.writeByte((byte) (flipHorizontally ? 1 : 0));
+    dest.writeByte((byte) (flipVertically ? 1 : 0));
+    TextUtils.writeToParcel(cropMenuCropButtonTitle, dest, flags);
+    dest.writeInt(cropMenuCropButtonIcon);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  /**
+   * Validate all the options are withing valid range.
+   *
+   * @throws IllegalArgumentException if any of the options is not valid
+   */
+  public void validate() {
+    if (maxZoom < 0) {
+      throw new IllegalArgumentException("Cannot set max zoom to a number < 1");
+    }
+    if (touchRadius < 0) {
+      throw new IllegalArgumentException("Cannot set touch radius value to a number <= 0 ");
+    }
+    if (initialCropWindowPaddingRatio < 0 || initialCropWindowPaddingRatio >= 0.5) {
+      throw new IllegalArgumentException(
+          "Cannot set initial crop window padding value to a number < 0 or >= 0.5");
+    }
+    if (aspectRatioX <= 0) {
+      throw new IllegalArgumentException(
+          "Cannot set aspect ratio value to a number less than or equal to 0.");
+    }
+    if (aspectRatioY <= 0) {
+      throw new IllegalArgumentException(
+          "Cannot set aspect ratio value to a number less than or equal to 0.");
+    }
+    if (borderLineThickness < 0) {
+      throw new IllegalArgumentException(
+          "Cannot set line thickness value to a number less than 0.");
+    }
+    if (borderCornerThickness < 0) {
+      throw new IllegalArgumentException(
+          "Cannot set corner thickness value to a number less than 0.");
+    }
+    if (guidelinesThickness < 0) {
+      throw new IllegalArgumentException(
+          "Cannot set guidelines thickness value to a number less than 0.");
+    }
+    if (minCropWindowHeight < 0) {
+      throw new IllegalArgumentException(
+          "Cannot set min crop window height value to a number < 0 ");
+    }
+    if (minCropResultWidth < 0) {
+      throw new IllegalArgumentException("Cannot set min crop result width value to a number < 0 ");
+    }
+    if (minCropResultHeight < 0) {
+      throw new IllegalArgumentException(
+          "Cannot set min crop result height value to a number < 0 ");
+    }
+    if (maxCropResultWidth < minCropResultWidth) {
+      throw new IllegalArgumentException(
+          "Cannot set max crop result width to smaller value than min crop result width");
+    }
+    if (maxCropResultHeight < minCropResultHeight) {
+      throw new IllegalArgumentException(
+          "Cannot set max crop result height to smaller value than min crop result height");
+    }
+    if (outputRequestWidth < 0) {
+      throw new IllegalArgumentException("Cannot set request width value to a number < 0 ");
+    }
+    if (outputRequestHeight < 0) {
+      throw new IllegalArgumentException("Cannot set request height value to a number < 0 ");
+    }
+    if (rotationDegrees < 0 || rotationDegrees > 360) {
+      throw new IllegalArgumentException(
+          "Cannot set rotation degrees value to a number < 0 or > 360");
+    }
+  }
+}
Index: app/src/main/java/com/theartofdev/edmodo/cropper/BitmapCroppingWorkerTask.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapCroppingWorkerTask.java b/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapCroppingWorkerTask.java
new file mode 100644
--- /dev/null	(date 1726418211338)
+++ b/app/src/main/java/com/theartofdev/edmodo/cropper/BitmapCroppingWorkerTask.java	(date 1726418211338)
@@ -0,0 +1,300 @@
+// "Therefore those skilled at the unorthodox
+// are infinite as heaven and earth,
+// inexhaustible as the great rivers.
+// When they come to an end,
+// they begin again,
+// like the days and months;
+// they die and are reborn,
+// like the four seasons."
+//
+// - Sun Tsu,
+// "The Art of War"
+
+package com.theartofdev.edmodo.cropper;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.net.Uri;
+import android.os.AsyncTask;
+
+import java.lang.ref.WeakReference;
+
+/** Task to crop bitmap asynchronously from the UI thread. */
+final class BitmapCroppingWorkerTask
+    extends AsyncTask<Void, Void, BitmapCroppingWorkerTask.Result> {
+
+  // region: Fields and Consts
+
+  /** Use a WeakReference to ensure the ImageView can be garbage collected */
+  private final WeakReference<CropImageView> mCropImageViewReference;
+
+  /** the bitmap to crop */
+  private final Bitmap mBitmap;
+
+  /** The Android URI of the image to load */
+  private final Uri mUri;
+
+  /** The context of the crop image view widget used for loading of bitmap by Android URI */
+  private final Context mContext;
+
+  /** Required cropping 4 points (x0,y0,x1,y1,x2,y2,x3,y3) */
+  private final float[] mCropPoints;
+
+  /** Degrees the image was rotated after loading */
+  private final int mDegreesRotated;
+
+  /** the original width of the image to be cropped (for image loaded from URI) */
+  private final int mOrgWidth;
+
+  /** the original height of the image to be cropped (for image loaded from URI) */
+  private final int mOrgHeight;
+
+  /** is there is fixed aspect ratio for the crop rectangle */
+  private final boolean mFixAspectRatio;
+
+  /** the X aspect ration of the crop rectangle */
+  private final int mAspectRatioX;
+
+  /** the Y aspect ration of the crop rectangle */
+  private final int mAspectRatioY;
+
+  /** required width of the cropping image */
+  private final int mReqWidth;
+
+  /** required height of the cropping image */
+  private final int mReqHeight;
+
+  /** is the image flipped horizontally */
+  private final boolean mFlipHorizontally;
+
+  /** is the image flipped vertically */
+  private final boolean mFlipVertically;
+
+  /** The option to handle requested width/height */
+  private final CropImageView.RequestSizeOptions mReqSizeOptions;
+
+  /** the Android Uri to save the cropped image to */
+  private final Uri mSaveUri;
+
+  /** the compression format to use when writing the image */
+  private final Bitmap.CompressFormat mSaveCompressFormat;
+
+  /** the quality (if applicable) to use when writing the image (0 - 100) */
+  private final int mSaveCompressQuality;
+  // endregion
+
+  BitmapCroppingWorkerTask(
+      CropImageView cropImageView,
+      Bitmap bitmap,
+      float[] cropPoints,
+      int degreesRotated,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      int reqWidth,
+      int reqHeight,
+      boolean flipHorizontally,
+      boolean flipVertically,
+      CropImageView.RequestSizeOptions options,
+      Uri saveUri,
+      Bitmap.CompressFormat saveCompressFormat,
+      int saveCompressQuality) {
+
+    mCropImageViewReference = new WeakReference<>(cropImageView);
+    mContext = cropImageView.getContext();
+    mBitmap = bitmap;
+    mCropPoints = cropPoints;
+    mUri = null;
+    mDegreesRotated = degreesRotated;
+    mFixAspectRatio = fixAspectRatio;
+    mAspectRatioX = aspectRatioX;
+    mAspectRatioY = aspectRatioY;
+    mReqWidth = reqWidth;
+    mReqHeight = reqHeight;
+    mFlipHorizontally = flipHorizontally;
+    mFlipVertically = flipVertically;
+    mReqSizeOptions = options;
+    mSaveUri = saveUri;
+    mSaveCompressFormat = saveCompressFormat;
+    mSaveCompressQuality = saveCompressQuality;
+    mOrgWidth = 0;
+    mOrgHeight = 0;
+  }
+
+  BitmapCroppingWorkerTask(
+      CropImageView cropImageView,
+      Uri uri,
+      float[] cropPoints,
+      int degreesRotated,
+      int orgWidth,
+      int orgHeight,
+      boolean fixAspectRatio,
+      int aspectRatioX,
+      int aspectRatioY,
+      int reqWidth,
+      int reqHeight,
+      boolean flipHorizontally,
+      boolean flipVertically,
+      CropImageView.RequestSizeOptions options,
+      Uri saveUri,
+      Bitmap.CompressFormat saveCompressFormat,
+      int saveCompressQuality) {
+
+    mCropImageViewReference = new WeakReference<>(cropImageView);
+    mContext = cropImageView.getContext();
+    mUri = uri;
+    mCropPoints = cropPoints;
+    mDegreesRotated = degreesRotated;
+    mFixAspectRatio = fixAspectRatio;
+    mAspectRatioX = aspectRatioX;
+    mAspectRatioY = aspectRatioY;
+    mOrgWidth = orgWidth;
+    mOrgHeight = orgHeight;
+    mReqWidth = reqWidth;
+    mReqHeight = reqHeight;
+    mFlipHorizontally = flipHorizontally;
+    mFlipVertically = flipVertically;
+    mReqSizeOptions = options;
+    mSaveUri = saveUri;
+    mSaveCompressFormat = saveCompressFormat;
+    mSaveCompressQuality = saveCompressQuality;
+    mBitmap = null;
+  }
+
+  /** The Android URI that this task is currently loading. */
+  public Uri getUri() {
+    return mUri;
+  }
+
+  /**
+   * Crop image in background.
+   *
+   * @param params ignored
+   * @return the decoded bitmap data
+   */
+  @Override
+  protected Result doInBackground(Void... params) {
+    try {
+      if (!isCancelled()) {
+
+        BitmapUtils.BitmapSampled bitmapSampled;
+        if (mUri != null) {
+          bitmapSampled =
+              BitmapUtils.cropBitmap(
+                  mContext,
+                  mUri,
+                  mCropPoints,
+                  mDegreesRotated,
+                  mOrgWidth,
+                  mOrgHeight,
+                  mFixAspectRatio,
+                  mAspectRatioX,
+                  mAspectRatioY,
+                  mReqWidth,
+                  mReqHeight,
+                  mFlipHorizontally,
+                  mFlipVertically);
+        } else if (mBitmap != null) {
+          bitmapSampled =
+              BitmapUtils.cropBitmapObjectHandleOOM(
+                  mBitmap,
+                  mCropPoints,
+                  mDegreesRotated,
+                  mFixAspectRatio,
+                  mAspectRatioX,
+                  mAspectRatioY,
+                  mFlipHorizontally,
+                  mFlipVertically);
+        } else {
+          return new Result((Bitmap) null, 1);
+        }
+
+        Bitmap bitmap =
+            BitmapUtils.resizeBitmap(bitmapSampled.bitmap, mReqWidth, mReqHeight, mReqSizeOptions);
+
+        if (mSaveUri == null) {
+          return new Result(bitmap, bitmapSampled.sampleSize);
+        } else {
+          BitmapUtils.writeBitmapToUri(
+              mContext, bitmap, mSaveUri, mSaveCompressFormat, mSaveCompressQuality);
+          if (bitmap != null) {
+            bitmap.recycle();
+          }
+          return new Result(mSaveUri, bitmapSampled.sampleSize);
+        }
+      }
+      return null;
+    } catch (Exception e) {
+      return new Result(e, mSaveUri != null);
+    }
+  }
+
+  /**
+   * Once complete, see if ImageView is still around and set bitmap.
+   *
+   * @param result the result of bitmap cropping
+   */
+  @Override
+  protected void onPostExecute(Result result) {
+    if (result != null) {
+      boolean completeCalled = false;
+      if (!isCancelled()) {
+        CropImageView cropImageView = mCropImageViewReference.get();
+        if (cropImageView != null) {
+          completeCalled = true;
+          cropImageView.onImageCroppingAsyncComplete(result);
+        }
+      }
+      if (!completeCalled && result.bitmap != null) {
+        // fast release of unused bitmap
+        result.bitmap.recycle();
+      }
+    }
+  }
+
+  // region: Inner class: Result
+
+  /** The result of BitmapCroppingWorkerTask async loading. */
+  static final class Result {
+
+    /** The cropped bitmap */
+    public final Bitmap bitmap;
+
+    /** The saved cropped bitmap uri */
+    public final Uri uri;
+
+    /** The error that occurred during async bitmap cropping. */
+    final Exception error;
+
+    /** is the cropping request was to get a bitmap or to save it to uri */
+    final boolean isSave;
+
+    /** sample size used creating the crop bitmap to lower its size */
+    final int sampleSize;
+
+    Result(Bitmap bitmap, int sampleSize) {
+      this.bitmap = bitmap;
+      this.uri = null;
+      this.error = null;
+      this.isSave = false;
+      this.sampleSize = sampleSize;
+    }
+
+    Result(Uri uri, int sampleSize) {
+      this.bitmap = null;
+      this.uri = uri;
+      this.error = null;
+      this.isSave = true;
+      this.sampleSize = sampleSize;
+    }
+
+    Result(Exception error, boolean isSave) {
+      this.bitmap = null;
+      this.uri = null;
+      this.error = error;
+      this.isSave = isSave;
+      this.sampleSize = 1;
+    }
+  }
+  // endregion
+}
Index: app/src/main/res/layout/crop_image_activity.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/crop_image_activity.xml b/app/src/main/res/layout/crop_image_activity.xml
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/res/layout/crop_image_activity.xml	(date 1694964014000)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.theartofdev.edmodo.cropper.CropImageView
+    android:id="@+id/cropImageView"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"/>
\ No newline at end of file
Index: app/src/main/res/layout/crop_image_view.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/crop_image_view.xml b/app/src/main/res/layout/crop_image_view.xml
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/res/layout/crop_image_view.xml	(date 1694964014000)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merge xmlns:android="http://schemas.android.com/apk/res/android"
+       xmlns:tools="http://schemas.android.com/tools">
+
+    <ImageView
+        android:id="@+id/ImageView_image"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:adjustViewBounds="true"
+        android:scaleType="centerInside"
+        tools:ignore="contentDescription"/>
+
+    <com.theartofdev.edmodo.cropper.CropOverlayView
+        android:id="@+id/CropOverlayView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:visibility="invisible"/>
+
+    <ProgressBar
+        android:id="@+id/CropProgressBar"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"/>
+
+</merge>
\ No newline at end of file
Index: app/src/main/java/com/zhouyou/view/seekbar/SignSeekBar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/zhouyou/view/seekbar/SignSeekBar.java b/app/src/main/java/com/zhouyou/view/seekbar/SignSeekBar.java
new file mode 100644
--- /dev/null	(date 1726397612318)
+++ b/app/src/main/java/com/zhouyou/view/seekbar/SignSeekBar.java	(date 1726397612318)
@@ -0,0 +1,1222 @@
+/*
+ * Copyright (C) 2017 zhouyou(478319399@qq.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.zhouyou.view.seekbar;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.os.Bundle;
+import android.os.Parcelable;
+//import android.support.annotation.IntDef;
+//import android.support.v4.content.ContextCompat;
+import android.text.Html;
+import android.text.Layout;
+import android.text.Spanned;
+import android.text.StaticLayout;
+import android.text.TextPaint;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.animation.LinearInterpolator;
+
+import com.qboxus.binder.R;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.math.BigDecimal;
+import java.text.NumberFormat;
+
+import androidx.annotation.IntDef;
+import androidx.core.content.ContextCompat;
+
+import static com.zhouyou.view.seekbar.SignSeekBar.TextPosition.BELOW_SECTION_MARK;
+import static com.zhouyou.view.seekbar.SignSeekBar.TextPosition.BOTTOM_SIDES;
+import static com.zhouyou.view.seekbar.SignSeekBar.TextPosition.SIDES;
+
+/**
+ * <p>描述：一个漂亮而强大的Android自定义SeekBar，它有一个带有进度的提示牌 sign:指示牌。</p>
+ * 作者： zhouyou<br>
+ * 日期： 2017/10/10 15:55 <br>
+ * 版本： v1.0<br>
+ */
+public class SignSeekBar extends View {
+    static final int NONE = -1;
+
+    @IntDef ({NONE, SIDES, BOTTOM_SIDES, BELOW_SECTION_MARK})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface TextPosition {
+        int SIDES = 0, BOTTOM_SIDES = 1, BELOW_SECTION_MARK = 2;
+    }
+
+    private float mMin; // min
+    private float mMax; // max
+    private float mProgress; // real time value
+    private boolean isFloatType; // support for float type output
+    private int mTrackSize; // height of right-track(on the right of thumb)
+    private int mSecondTrackSize; // height of left-track(on the left of thumb)
+    private int mThumbRadius; // radius of thumb
+    private int mThumbRadiusOnDragging; // radius of thumb when be dragging
+    private int mTrackColor; // color of right-track
+    private int mSecondTrackColor; // color of left-track
+    private int mThumbColor; // color of thumb
+    private int mSectionCount; // shares of whole progress(max - min)
+    private boolean isShowSectionMark; // show demarcation points or not
+    private boolean isAutoAdjustSectionMark; // auto scroll to the nearest section_mark or not
+    private boolean isShowSectionText; // show section-text or not
+    private int mSectionTextSize; // text size of section-text
+    private int mSectionTextColor; // text color of section-text
+    @TextPosition
+    private int mSectionTextPosition = NONE; // text position of section-text relative to track
+    private int mSectionTextInterval; // the interval of two section-text
+    private boolean isShowThumbText; // show real time progress-text under thumb or not
+    private int mThumbTextSize; // text size of progress-text
+    private int mThumbTextColor; // text color of progress-text
+    private boolean isShowProgressInFloat; // show sign-progress in float or not
+    private boolean isTouchToSeek; // touch anywhere on track to quickly seek
+    private boolean isSeekBySection; // seek by section, the progress may not be linear
+    private long mAnimDuration; // duration of animation
+
+    private int mSignBorderSize; // border size
+    private boolean isShowSignBorder; // show sign border
+    private int mSignBorderColor;// color of border color
+    private int mUnusableColor;// color of border color
+    private int mSignColor;// color of sign
+    private int mSignTextSize; // text size of sign-progress
+    private int mSignTextColor; // text color of sign-progress
+    private int mSignHeight; //sign Height
+    private int mSignWidth; //sign width
+
+    private float mDelta; // max - min
+    private float mSectionValue; // (mDelta / mSectionCount)
+    private float mThumbCenterX; // X coordinate of thumb's center
+    private float mTrackLength; // pixel length of whole track
+    private float mSectionOffset; // pixel length of one section
+    private boolean isThumbOnDragging; // is thumb on dragging or not
+    private int mTextSpace; // space between text and track
+    private boolean triggerSeekBySection;
+
+    private OnProgressChangedListener mProgressListener; // progress changing listener
+    private float mLeft; // space between left of track and left of the view
+    private float mRight; // space between right of track and left of the view
+    private Paint mPaint;
+    private Rect mRectText;
+
+    private boolean isTouchToSeekAnimEnd = true;
+    private float mPreSecValue; // previous SectionValue
+    private SignConfigBuilder mConfigBuilder; // config attributes
+    private String[] mSidesLabels;
+    private boolean isSidesLabels;
+    private float mThumbBgAlpha; //  alpha of thumb shadow
+    private float mThumbRatio; // ratio of thumb shadow
+    private boolean isShowThumbShadow;
+    private boolean isShowSign;
+    private boolean isSignArrowAutofloat;
+
+    private Rect valueSignBounds;
+    private RectF roundRectangleBounds;
+    private int mSignArrowHeight;   //提示框箭头的高度
+    private int mSignArrowWidth;   //提示框箭头的宽度
+    private int mSignRound;      //提示框的圆角大小
+    private int barRoundingRadius = 0;
+    private Point point1;
+    private Point point2;
+    private Point point3;
+    private Paint signPaint;
+    private Paint signborderPaint;
+    private StaticLayout valueTextLayout;
+    private Path trianglePath;
+    private Path triangleboderPath;
+    private String unit;
+    private boolean mReverse;
+    private TextPaint valueTextPaint;  //滑块数值文本
+    private NumberFormat mFormat;
+    private OnValueFormatListener mValueFormatListener;
+
+    public SignSeekBar(Context context) {
+        this(context, null);
+    }
+
+    public SignSeekBar(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public SignSeekBar(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SignSeekBar, defStyleAttr, 0);
+        mMin = a.getFloat(R.styleable.SignSeekBar_ssb_min, 0.0f);
+        mMax = a.getFloat(R.styleable.SignSeekBar_ssb_max, 100.0f);
+        mProgress = a.getFloat(R.styleable.SignSeekBar_ssb_progress, mMin);
+        isFloatType = a.getBoolean(R.styleable.SignSeekBar_ssb_is_float_type, false);
+        mTrackSize = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_track_size, SignUtils.dp2px(2));
+        mTextSpace = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_text_space, SignUtils.dp2px(2));
+        mSecondTrackSize = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_second_track_size, mTrackSize + SignUtils.dp2px(2));
+        mThumbRadius = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_thumb_radius, mSecondTrackSize + SignUtils.dp2px(2));
+        mThumbRadiusOnDragging = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_thumb_radius, mSecondTrackSize * 2);
+        mSignBorderSize = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_border_size, SignUtils.dp2px(1));
+        mSectionCount = a.getInteger(R.styleable.SignSeekBar_ssb_section_count, 10);
+        mTrackColor = a.getColor(R.styleable.SignSeekBar_ssb_track_color, ContextCompat.getColor(context, R.color.colorPrimary));
+        mSecondTrackColor = a.getColor(R.styleable.SignSeekBar_ssb_second_track_color, ContextCompat.getColor(context, R.color.colorAccent));
+        mThumbColor = a.getColor(R.styleable.SignSeekBar_ssb_thumb_color, mSecondTrackColor);
+        isShowSectionText = a.getBoolean(R.styleable.SignSeekBar_ssb_show_section_text, false);
+        mSectionTextSize = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_section_text_size, SignUtils.sp2px(14));
+        mSectionTextColor = a.getColor(R.styleable.SignSeekBar_ssb_section_text_color, mTrackColor);
+        isSeekBySection = a.getBoolean(R.styleable.SignSeekBar_ssb_seek_by_section, false);
+        int pos = a.getInteger(R.styleable.SignSeekBar_ssb_section_text_position, NONE);
+        if (pos == 0) {
+            mSectionTextPosition = SIDES;
+        } else if (pos == 1) {
+            mSectionTextPosition = TextPosition.BOTTOM_SIDES;
+        } else if (pos == 2) {
+            mSectionTextPosition = TextPosition.BELOW_SECTION_MARK;
+        } else {
+            mSectionTextPosition = NONE;
+        }
+        mSectionTextInterval = a.getInteger(R.styleable.SignSeekBar_ssb_section_text_interval, 1);
+        isShowThumbText = a.getBoolean(R.styleable.SignSeekBar_ssb_show_thumb_text, false);
+        mThumbTextSize = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_thumb_text_size, SignUtils.sp2px(14));
+        mThumbTextColor = a.getColor(R.styleable.SignSeekBar_ssb_thumb_text_color, mSecondTrackColor);
+        mSignColor = a.getColor(R.styleable.SignSeekBar_ssb_sign_color, mSecondTrackColor);
+        mSignBorderColor = a.getColor(R.styleable.SignSeekBar_ssb_sign_border_color, mSecondTrackColor);
+        mUnusableColor = a.getColor(R.styleable.SignSeekBar_ssb_unusable_color, Color.GRAY);
+        mSignTextSize = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_text_size, SignUtils.sp2px(14));
+        mSignHeight = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_height, SignUtils.dp2px(32));
+        mSignWidth = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_width, SignUtils.dp2px(72));
+        mSignArrowHeight = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_arrow_height, SignUtils.dp2px(3));
+        mSignArrowWidth = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_arrow_width, SignUtils.dp2px(5));
+        mSignRound = a.getDimensionPixelSize(R.styleable.SignSeekBar_ssb_sign_round, SignUtils.dp2px(3));
+        mSignTextColor = a.getColor(R.styleable.SignSeekBar_ssb_sign_text_color, Color.WHITE);
+        isShowSectionMark = a.getBoolean(R.styleable.SignSeekBar_ssb_show_section_mark, false);
+        isAutoAdjustSectionMark = a.getBoolean(R.styleable.SignSeekBar_ssb_auto_adjust_section_mark, false);
+        isShowProgressInFloat = a.getBoolean(R.styleable.SignSeekBar_ssb_show_progress_in_float, false);
+        int duration = a.getInteger(R.styleable.SignSeekBar_ssb_anim_duration, -1);
+        mAnimDuration = duration < 0 ? 200 : duration;
+        isTouchToSeek = a.getBoolean(R.styleable.SignSeekBar_ssb_touch_to_seek, false);
+        isShowSignBorder = a.getBoolean(R.styleable.SignSeekBar_ssb_sign_show_border, false);
+
+        int labelsResId = a.getResourceId(R.styleable.SignSeekBar_ssb_sides_labels, 0);
+        mThumbBgAlpha = a.getFloat(R.styleable.SignSeekBar_ssb_thumb_bg_alpha, 0.2f);
+        mThumbRatio = a.getFloat(R.styleable.SignSeekBar_ssb_thumb_ratio, 0.7f);
+        isShowThumbShadow = a.getBoolean(R.styleable.SignSeekBar_ssb_show_thumb_shadow, false);
+        isShowSign = a.getBoolean(R.styleable.SignSeekBar_ssb_show_sign, false);
+        isSignArrowAutofloat = a.getBoolean(R.styleable.SignSeekBar_ssb_sign_arrow_autofloat, true);
+        a.recycle();
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setStrokeCap(Paint.Cap.ROUND);
+        mPaint.setTextAlign(Paint.Align.CENTER);
+
+        mRectText = new Rect();
+        if (labelsResId > 0) {
+            mSidesLabels = getResources().getStringArray(labelsResId);
+        }
+        isSidesLabels = mSidesLabels != null && mSidesLabels.length > 0;
+
+        //init sign
+        roundRectangleBounds = new RectF();
+        valueSignBounds = new Rect();
+
+        point1 = new Point();
+        point2 = new Point();
+        point3 = new Point();
+
+        trianglePath = new Path();
+        trianglePath.setFillType(Path.FillType.EVEN_ODD);
+
+        triangleboderPath = new Path();
+
+        init();
+
+        initConfigByPriority();
+    }
+
+    private void init() {
+        signPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        signPaint.setStyle(Paint.Style.FILL);
+        signPaint.setAntiAlias(true);
+        signPaint.setColor(mSignColor);
+
+        signborderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        signborderPaint.setStyle(Paint.Style.STROKE);
+        signborderPaint.setStrokeWidth(mSignBorderSize);
+        signborderPaint.setColor(mSignBorderColor);
+        signborderPaint.setAntiAlias(true);
+
+        valueTextPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
+        valueTextPaint.setStyle(Paint.Style.FILL);
+        valueTextPaint.setTextSize(mSignTextSize);
+        valueTextPaint.setColor(mSignTextColor);
+    }
+
+    private void initConfigByPriority() {
+        if (mMin == mMax) {
+            mMin = 0.0f;
+            mMax = 100.0f;
+        }
+        if (mMin > mMax) {
+            float tmp = mMax;
+            mMax = mMin;
+            mMin = tmp;
+        }
+        if (mProgress < mMin) {
+            mProgress = mMin;
+        }
+        if (mProgress > mMax) {
+            mProgress = mMax;
+        }
+        if (mSecondTrackSize < mTrackSize) {
+            mSecondTrackSize = mTrackSize + SignUtils.dp2px(2);
+        }
+        if (mThumbRadius <= mSecondTrackSize) {
+            mThumbRadius = mSecondTrackSize + SignUtils.dp2px(2);
+        }
+        if (mThumbRadiusOnDragging <= mSecondTrackSize) {
+            mThumbRadiusOnDragging = mSecondTrackSize * 2;
+        }
+        if (mSectionCount <= 0) {
+            mSectionCount = 10;
+        }
+        mDelta = mMax - mMin;
+        mSectionValue = mDelta / mSectionCount;
+
+        if (mSectionValue < 1) {
+            isFloatType = true;
+        }
+        if (isFloatType) {
+            isShowProgressInFloat = true;
+        }
+        if (mSectionTextPosition != NONE) {
+            isShowSectionText = true;
+        }
+        if (isShowSectionText) {
+            if (mSectionTextPosition == NONE) {
+                mSectionTextPosition = TextPosition.SIDES;
+            }
+            if (mSectionTextPosition == TextPosition.BELOW_SECTION_MARK) {
+                isShowSectionMark = true;
+            }
+        }
+        if (mSectionTextInterval < 1) {
+            mSectionTextInterval = 1;
+        }
+        if (isAutoAdjustSectionMark && !isShowSectionMark) {
+            isAutoAdjustSectionMark = false;
+        }
+        if (isSeekBySection) {
+            mPreSecValue = mMin;
+            if (mProgress != mMin) {
+                mPreSecValue = mSectionValue;
+            }
+            isShowSectionMark = true;
+            isAutoAdjustSectionMark = true;
+            isTouchToSeek = false;
+        }
+
+        setProgress(mProgress);
+
+        mThumbTextSize = isFloatType || isSeekBySection || (isShowSectionText && mSectionTextPosition ==
+                TextPosition.BELOW_SECTION_MARK) ? mSectionTextSize : mThumbTextSize;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        int height = mThumbRadiusOnDragging * 2; // 默认高度为拖动时thumb圆的直径
+        if (isShowThumbText) {
+            mPaint.setTextSize(mThumbTextSize);
+            mPaint.getTextBounds("j", 0, 1, mRectText); // “j”是字母和阿拉伯数字中最高的
+            height += mRectText.height() + mTextSpace; // 如果显示实时进度，则原来基础上加上进度文字高度和间隔
+        }
+        if (isShowSectionText && mSectionTextPosition >= TextPosition.BOTTOM_SIDES) { // 如果Section值在track之下显示，比较取较大值
+            //测量节点文字的高度，如果有lable，测量真实的lable高度，如果没有表示显示的进度是数字，就用“j”代替测量高度
+            String measuretext = isSidesLabels ? mSidesLabels[0] : "j";
+            mPaint.setTextSize(mSectionTextSize);
+            mPaint.getTextBounds(measuretext, 0, measuretext.length(), mRectText);
+            height = Math.max(height, mThumbRadiusOnDragging * 2 + mRectText.height() + mTextSpace);
+        }
+        if (isShowSign) {
+        }
+        height += mSignHeight;//加上提示框的高度
+        if (isShowSignBorder) height += mSignBorderSize;//加上提示框边框高度
+        setMeasuredDimension(resolveSize(getSuggestedMinimumWidth(), widthMeasureSpec), height);
+
+        mLeft = getPaddingLeft() + mThumbRadiusOnDragging;
+        mRight = getMeasuredWidth() - getPaddingRight() - mThumbRadiusOnDragging;
+
+        if (isShowSectionText) {
+            mPaint.setTextSize(mSectionTextSize);
+
+            if (mSectionTextPosition == TextPosition.SIDES) {
+                String text = getMinText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                mLeft += (mRectText.width() + mTextSpace);
+
+                text = getMaxText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                mRight -= (mRectText.width() + mTextSpace);
+            } else if (mSectionTextPosition >= TextPosition.BOTTOM_SIDES) {
+                String text = isSidesLabels ? mSidesLabels[0] : getMinText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                float max = Math.max(mThumbRadiusOnDragging, mRectText.width() / 2f);
+                mLeft = getPaddingLeft() + max + mTextSpace;
+
+                text = isSidesLabels ? mSidesLabels[mSidesLabels.length - 1] : getMaxText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                max = Math.max(mThumbRadiusOnDragging, mRectText.width() / 2f);
+                mRight = getMeasuredWidth() - getPaddingRight() - max - mTextSpace;
+            }
+        } else if (isShowThumbText && mSectionTextPosition == NONE) {
+            mPaint.setTextSize(mThumbTextSize);
+
+            String text = getMinText();
+            mPaint.getTextBounds(text, 0, text.length(), mRectText);
+            float max = Math.max(mThumbRadiusOnDragging, mRectText.width() / 2f);
+            mLeft = getPaddingLeft() + max + mTextSpace;
+
+            text = getMaxText();
+            mPaint.getTextBounds(text, 0, text.length(), mRectText);
+            max = Math.max(mThumbRadiusOnDragging, mRectText.width() / 2f);
+            mRight = getMeasuredWidth() - getPaddingRight() - max - mTextSpace;
+        }
+
+        if (isShowSign && !isSignArrowAutofloat) {//提示框 三角指示是否自动移动
+            mLeft = Math.max(mLeft, getPaddingLeft() + mSignWidth / 2 + mSignBorderSize);
+            mRight = Math.min(mRight, getMeasuredWidth() - getPaddingRight() - mSignWidth / 2 - mSignBorderSize);
+        }
+
+        mTrackLength = mRight - mLeft;
+        mSectionOffset = mTrackLength * 1f / mSectionCount;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        float xLeft = getPaddingLeft();
+        float xRight = getMeasuredWidth() - getPaddingRight();
+        float yTop = getPaddingTop() + mThumbRadiusOnDragging;
+        if (isShowSign) {//加上提示框高度
+            yTop += mSignHeight;
+        }
+        if (isShowSignBorder) {//加上提示框边框高度
+            yTop += mSignBorderSize;
+        }
+        if (isShowSign && !isSignArrowAutofloat) {//是否浮动显示提示框三角指示，默认浮动，否则居中显示
+            xLeft += (mSignWidth / 2 + mSignBorderSize);
+            xRight -= (mSignWidth / 2 + mSignBorderSize);
+        }
+        // draw sectionText SIDES or BOTTOM_SIDES
+        if (isShowSectionText) {
+            mPaint.setTextSize(mSectionTextSize);
+            mPaint.setColor(isEnabled() ? mSectionTextColor : mUnusableColor);
+
+            if (mSectionTextPosition == TextPosition.SIDES) {
+                float y_ = yTop + mRectText.height() / 2f;
+
+                //String text = getMinText();
+                String text = isSidesLabels ? mSidesLabels[0] : getMinText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                canvas.drawText(text, xLeft + mRectText.width() / 2f, y_, mPaint);
+                xLeft += mRectText.width() + mTextSpace;
+
+                //text = getMaxText();
+                text = isSidesLabels && mSidesLabels.length > 1 ? mSidesLabels[mSidesLabels.length - 1] : getMaxText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                canvas.drawText(text, xRight - mRectText.width() / 2f, y_, mPaint);
+                xRight -= (mRectText.width() + mTextSpace);
+
+            } else if (mSectionTextPosition >= TextPosition.BOTTOM_SIDES) {
+                float y_ = yTop + mThumbRadiusOnDragging + mTextSpace;
+
+                // String text = getMinText();
+                String text = isSidesLabels ? mSidesLabels[0] : getMinText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                y_ += mRectText.height();
+                xLeft = mLeft;
+                if (mSectionTextPosition == TextPosition.BOTTOM_SIDES) {
+                    canvas.drawText(text, xLeft, y_, mPaint);
+                }
+
+                //text = getMaxText();
+                text = isSidesLabels && mSidesLabels.length > 1 ? mSidesLabels[mSidesLabels.length - 1] : getMaxText();
+                mPaint.getTextBounds(text, 0, text.length(), mRectText);
+                xRight = mRight;
+                if (mSectionTextPosition == TextPosition.BOTTOM_SIDES) {
+                    canvas.drawText(text, xRight, y_, mPaint);
+                }
+            }
+        } else if (isShowThumbText && mSectionTextPosition == NONE) {
+            xLeft = mLeft;
+            xRight = mRight;
+        }
+
+        if ((!isShowSectionText && !isShowThumbText) || mSectionTextPosition == TextPosition.SIDES) {
+            xLeft += mThumbRadiusOnDragging;
+            xRight -= mThumbRadiusOnDragging;
+        }
+
+        boolean isShowTextBelowSectionMark = isShowSectionText && mSectionTextPosition ==
+                TextPosition.BELOW_SECTION_MARK;
+        //boolean conditionInterval = mSectionCount % 2 == 0;
+        boolean conditionInterval = true;
+
+        // draw sectionMark & sectionText BELOW_SECTION_MARK
+        if (isShowTextBelowSectionMark || isShowSectionMark) {
+            drawMark(canvas, xLeft, yTop, isShowTextBelowSectionMark, conditionInterval);
+        }
+
+        if (!isThumbOnDragging) {
+            mThumbCenterX = mTrackLength / mDelta * (mProgress - mMin) + xLeft;
+        }
+
+        // draw thumbText
+        if (isShowThumbText && !isThumbOnDragging && isTouchToSeekAnimEnd) {
+            drawThumbText(canvas, yTop);
+        }
+
+        // draw track
+        mPaint.setColor(mSecondTrackColor);
+        mPaint.setStrokeWidth(mSecondTrackSize);
+        canvas.drawLine(xLeft, yTop, mThumbCenterX, yTop, mPaint);
+
+        // draw second track
+        mPaint.setColor(mTrackColor);
+        mPaint.setStrokeWidth(mTrackSize);
+        canvas.drawLine(mThumbCenterX, yTop, xRight, yTop, mPaint);
+
+        // draw thumb
+        mPaint.setColor(mThumbColor);
+        //draw thumb shadow
+        if (isShowThumbShadow) {
+            canvas.drawCircle(mThumbCenterX, yTop, isThumbOnDragging ? mThumbRadiusOnDragging * mThumbRatio : mThumbRadius * mThumbRatio, mPaint);
+            mPaint.setColor(getColorWithAlpha(mThumbColor, mThumbBgAlpha));
+        }
+        //Paint paint = new Paint();
+        //Shader shader = new RadialGradient(mThumbCenterX, yTop, isThumbOnDragging ? mThumbRadiusOnDragging : mThumbRadius, mThumbColor, getColorWithAlpha(mThumbColor, mThumbBgAlpha), Shader.TileMode.CLAMP);
+        //paint.setShader(shader);
+        canvas.drawCircle(mThumbCenterX, yTop, isThumbOnDragging ? mThumbRadiusOnDragging : mThumbRadius, mPaint);
+
+        //draw progress text
+        //drawProgressText(canvas);
+
+        //draw sign
+        if (!isShowSign) return;
+        drawValueSign(canvas, mSignHeight, (int) mThumbCenterX);
+    }
+
+    //draw mark
+    private void drawMark(Canvas canvas, float xLeft, float yTop, boolean isShowTextBelowSectionMark, boolean conditionInterval) {
+        float r = (mThumbRadiusOnDragging - SignUtils.dp2px(2)) / 2f;
+        float junction = mTrackLength / mDelta * Math.abs(mProgress - mMin) + mLeft; // 交汇点
+        mPaint.setTextSize(mSectionTextSize);
+        mPaint.getTextBounds("0123456789", 0, "0123456789".length(), mRectText); // compute solid height
+
+        float x_;
+        float y_ = yTop + mRectText.height() + mThumbRadiusOnDragging + mTextSpace;
+
+        for (int i = 0; i <= mSectionCount; i++) {
+            x_ = xLeft + i * mSectionOffset;
+            mPaint.setColor(x_ <= junction ? mSecondTrackColor : mTrackColor);
+            // sectionMark
+            canvas.drawCircle(x_, yTop, r, mPaint);
+
+            // sectionText belows section
+            if (isShowTextBelowSectionMark) {
+                float m = mMin + mSectionValue * i;
+                //不可用，除了当前节点之外的其它节点用不可用颜色表示
+
+                //Log.i("test",mProgress+"========"+m);
+                //mPaint.setColor(isEnabled()?mSectionTextColor:mUnusableColor);
+                mPaint.setColor(isEnabled() ? mSectionTextColor : Math.abs(mProgress - m) <= 0 ? mSectionTextColor : mUnusableColor);
+                if (mSectionTextInterval > 1) {
+                    if (conditionInterval && i % mSectionTextInterval == 0) {
+                        if (isSidesLabels) {
+                            canvas.drawText(mSidesLabels[i], x_, y_, mPaint);
+                        } else {
+                            canvas.drawText(isFloatType ? float2String(m) : (int) m + "", x_, y_, mPaint);
+                        }
+                    }
+                } else {
+                    if (conditionInterval && i % mSectionTextInterval == 0) {
+                        if (isSidesLabels && i / mSectionTextInterval <= mSidesLabels.length) {
+                            canvas.drawText(mSidesLabels[i / mSectionTextInterval], x_, y_, mPaint);
+                        } else {
+                            canvas.drawText(isFloatType ? float2String(m) : (int) m + "", x_, y_, mPaint);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    //draw thumb text
+    private void drawThumbText(Canvas canvas, float yTop) {
+        mPaint.setColor(mThumbTextColor);
+        mPaint.setTextSize(mThumbTextSize);
+        mPaint.getTextBounds("0123456789", 0, "0123456789".length(), mRectText); // compute solid height
+        float y_ = yTop + mRectText.height() + mThumbRadiusOnDragging + mTextSpace;
+
+        if (isFloatType || (isShowProgressInFloat && mSectionTextPosition == TextPosition.BOTTOM_SIDES &&
+                mProgress != mMin && mProgress != mMax)) {
+            float progress = getProgressFloat();
+            String value = String.valueOf(progress);
+            if (mFormat != null) {
+                value = mFormat.format(progress);
+            }
+            if (value != null && unit != null && !unit.isEmpty()) {
+                if (!mReverse) {
+                    value += String.format("%s", unit);
+                } else {
+                    value = String.format("%s", unit) + value;
+                }
+            }
+            if (mValueFormatListener != null) value = mValueFormatListener.format(progress);
+            drawSignText(canvas, value, mThumbCenterX, y_, mPaint);
+        } else {
+            int progress = getProgress();
+            String value = String.valueOf(progress);
+            if (mFormat != null) {
+                value = mFormat.format(progress);
+            }
+            if (value != null && unit != null && !unit.isEmpty()) {
+                if (!mReverse) {
+                    value += String.format("%s", unit);
+                } else {
+                    value = String.format("%s", unit) + value;
+                }
+            }
+            if (mValueFormatListener != null) value = mValueFormatListener.format(progress);
+            drawSignText(canvas, value, mThumbCenterX, y_, mPaint);
+        }
+    }
+
+    public void drawSignText(Canvas canvas, String text, float x, float y, Paint paint) {
+        canvas.drawText(text, x, y, paint);
+    }
+
+    //draw value sign
+    private void drawValueSign(Canvas canvas, int valueSignSpaceHeight, int valueSignCenter) {
+        valueSignBounds.set(valueSignCenter - mSignWidth / 2, getPaddingTop(), valueSignCenter + mSignWidth / 2, mSignHeight - mSignArrowHeight + getPaddingTop());
+
+        int bordersize = isShowSignBorder ? mSignBorderSize : 0;
+        // Move if not fit horizontal
+        if (valueSignBounds.left < getPaddingLeft()) {
+            int difference = -valueSignBounds.left + getPaddingLeft() + bordersize;
+            roundRectangleBounds.set(valueSignBounds.left + difference, valueSignBounds.top, valueSignBounds.right +
+                    difference, valueSignBounds.bottom);
+        } else if (valueSignBounds.right > getMeasuredWidth() - getPaddingRight()) {
+            int difference = valueSignBounds.right - getMeasuredWidth() + getPaddingRight() + bordersize;
+            roundRectangleBounds.set(valueSignBounds.left - difference, valueSignBounds.top, valueSignBounds.right -
+                    difference, valueSignBounds.bottom);
+        } else {
+            roundRectangleBounds.set(valueSignBounds.left, valueSignBounds.top, valueSignBounds.right,
+                    valueSignBounds.bottom);
+        }
+
+        canvas.drawRoundRect(roundRectangleBounds, mSignRound, mSignRound, signPaint);
+        if (isShowSignBorder) {
+            roundRectangleBounds.top = roundRectangleBounds.top + mSignBorderSize / 2;
+            canvas.drawRoundRect(roundRectangleBounds, mSignRound, mSignRound, signborderPaint);
+        }
+
+        // Draw arrow
+        barRoundingRadius = isThumbOnDragging ? mThumbRadiusOnDragging : mThumbRadius;
+        int difference = 0;
+        if (valueSignCenter - mSignArrowWidth / 2 < barRoundingRadius + getPaddingLeft() + mTextSpace + bordersize) {
+            difference = barRoundingRadius - valueSignCenter + getPaddingLeft() + bordersize + mTextSpace;
+        } else if (valueSignCenter + mSignArrowWidth / 2 > getMeasuredWidth() - barRoundingRadius - getPaddingRight() - mTextSpace - bordersize) {
+            difference = (getMeasuredWidth() - barRoundingRadius) - valueSignCenter - getPaddingRight() - bordersize - mTextSpace;
+        }
+
+        point1.set(valueSignCenter - mSignArrowWidth / 2 + difference, valueSignSpaceHeight - mSignArrowHeight + getPaddingTop());
+        point2.set(valueSignCenter + mSignArrowWidth / 2 + difference, valueSignSpaceHeight - mSignArrowHeight + getPaddingTop());
+        point3.set(valueSignCenter + difference, valueSignSpaceHeight + getPaddingTop());
+
+        drawTriangle(canvas, point1, point2, point3, signPaint);
+        if (isShowSignBorder) {
+            drawTriangleBoder(canvas, point1, point2, point3, signborderPaint);
+        }
+
+        createValueTextLayout();
+        // Draw value text
+        if (valueTextLayout != null) {
+            canvas.translate(roundRectangleBounds.left, roundRectangleBounds.top + roundRectangleBounds.height() / 2 - valueTextLayout.getHeight() / 2);
+            valueTextLayout.draw(canvas);
+        }
+    }
+
+    private void drawTriangle(Canvas canvas, Point point1, Point point2, Point point3, Paint paint) {
+        trianglePath.reset();
+        trianglePath.moveTo(point1.x, point1.y);
+        trianglePath.lineTo(point2.x, point2.y);
+        trianglePath.lineTo(point3.x, point3.y);
+        trianglePath.lineTo(point1.x, point1.y);
+        trianglePath.close();
+
+        canvas.drawPath(trianglePath, paint);
+    }
+
+    /**
+     * 将三角形的一条顶边用颜色给覆盖掉
+     */
+    private void drawTriangleBoder(Canvas canvas, Point point1, Point point2, Point point3, Paint paint) {
+        triangleboderPath.reset();
+        triangleboderPath.moveTo(point1.x, point1.y);
+        triangleboderPath.lineTo(point2.x, point2.y);
+        paint.setColor(signPaint.getColor());
+        float value = mSignBorderSize / 6;
+        paint.setStrokeWidth(mSignBorderSize + 1f);
+        canvas.drawPath(triangleboderPath, paint);
+        triangleboderPath.reset();
+        paint.setStrokeWidth(mSignBorderSize);
+        triangleboderPath.moveTo(point1.x - value, point1.y - value);
+        triangleboderPath.lineTo(point3.x, point3.y);
+        triangleboderPath.lineTo(point2.x + value, point2.y - value);
+        paint.setColor(mSignBorderColor);
+        canvas.drawPath(triangleboderPath, paint);
+    }
+
+    /**
+     * 设置单位
+     */
+    public void setUnit(String unit) {
+        this.unit = unit;
+        createValueTextLayout();
+        invalidate();
+        requestLayout();
+    }
+
+    public void setProgressWithUnit(float progress, String unitHtml) {
+        setProgress(progress);
+        this.unit = unitHtml;
+        createValueTextLayout();
+        invalidate();
+        requestLayout();
+    }
+
+    private void createValueTextLayout() {
+        String value = "";
+        if (isShowProgressInFloat) {
+            float progress = getProgressFloat();
+            value = String.valueOf(progress);
+            if (mFormat != null) {
+                value = mFormat.format(progress);
+            }
+        } else {
+            int progress = getProgress();
+            value = String.valueOf(progress);
+            if (mFormat != null) {
+                value = mFormat.format(progress);
+            }
+        }
+        if (mValueFormatListener == null) {
+            if (value != null && unit != null && !unit.isEmpty()) {
+                if (!mReverse) {
+                    value += String.format(" <small>%s</small> ", unit);
+                    //value += String.format("%s", unit);
+                } else {
+                    value = String.format(" %s ", unit) + value;
+                }
+            }
+        } else {
+            value = mValueFormatListener.format(Float.parseFloat(value));
+        }
+        Spanned spanned = Html.fromHtml(value);
+        valueTextLayout = new StaticLayout(spanned, valueTextPaint, mSignWidth, Layout.Alignment.ALIGN_CENTER, 1, 0, false);
+    }
+
+    //draw progress text
+    private void drawProgressText(Canvas canvas) {
+        String value = isShowProgressInFloat ? String.valueOf(getProgressFloat()) : String.valueOf(getProgress());
+        //String text = value != null ? formatter.format(value) : valueSegmentText;
+        if (value != null && unit != null && !unit.isEmpty())
+            value += String.format("%s", unit);
+        float mCircle_r = isThumbOnDragging ? mThumbRadiusOnDragging : mThumbRadius;
+        Paint mPartTextPaint = mPaint;
+        mPartTextPaint.setColor(Color.BLACK);
+        mPartTextPaint.setTextSize(25);
+        //如果想精确的把文字画在圆圈中心，请使用基于Paint.Align.LEFT完整公式计算方法
+        drawCircleText(canvas, mPartTextPaint, mThumbCenterX, getPaddingTop() + mThumbRadiusOnDragging, mCircle_r, value);
+    }
+
+    /**
+     * 精确画圆圈中心文字（通用方法），其中文字的高度是最难计算适配的，采用此方法，可以完美解决
+     *
+     * @param canvas  画板
+     * @param paint   画笔panit
+     * @param centerX 圆圈中心X坐标
+     * @param centerY 圆圈中心Y坐标
+     * @param radius  半径
+     * @param text    显示的文本
+     */
+    private void drawCircleText(Canvas canvas, Paint paint, float centerX, float centerY, float radius, String text) {
+        paint.setTextAlign(Paint.Align.LEFT);
+        Rect bounds = new Rect();
+        paint.getTextBounds(text, 0, text.length(), bounds);
+        Paint.FontMetricsInt fontMetrics = paint.getFontMetricsInt();
+        float baseline = centerY - radius + (2 * radius - fontMetrics.bottom + fontMetrics.top) / 2 - fontMetrics.top;
+        canvas.drawText(text, centerX - radius + radius - bounds.width() / 2, baseline, paint);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        post(new Runnable() {
+            @Override
+            public void run() {
+                requestLayout();
+            }
+        });
+    }
+
+    float dx;
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (!isEnabled()) return false;
+        switch (event.getActionMasked()) {
+            case MotionEvent.ACTION_DOWN:
+                getParent().requestDisallowInterceptTouchEvent(true);
+
+                isThumbOnDragging = isThumbTouched(event);
+                if (isThumbOnDragging) {
+                    if (isSeekBySection && !triggerSeekBySection) {
+                        triggerSeekBySection = true;
+                    }
+                    invalidate();
+                } else if (isTouchToSeek && isTrackTouched(event)) {
+                    isThumbOnDragging = true;
+                    mThumbCenterX = event.getX();
+                    if (mThumbCenterX < mLeft) {
+                        mThumbCenterX = mLeft;
+                    }
+                    if (mThumbCenterX > mRight) {
+                        mThumbCenterX = mRight;
+                    }
+                    mProgress = (mThumbCenterX - mLeft) * mDelta / mTrackLength + mMin;
+                    invalidate();
+                }
+
+                dx = mThumbCenterX - event.getX();
+
+                break;
+            case MotionEvent.ACTION_MOVE:
+                if (isThumbOnDragging) {
+                    mThumbCenterX = event.getX() + dx;
+                    if (mThumbCenterX < mLeft) {
+                        mThumbCenterX = mLeft;
+                    }
+                    if (mThumbCenterX > mRight) {
+                        mThumbCenterX = mRight;
+                    }
+                    mProgress = (mThumbCenterX - mLeft) * mDelta / mTrackLength + mMin;
+                    invalidate();
+
+                    if (mProgressListener != null) {
+                        mProgressListener.onProgressChanged(this, getProgress(), getProgressFloat(), true);
+                    }
+                }
+
+                break;
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL:
+                getParent().requestDisallowInterceptTouchEvent(false);
+
+                if (isAutoAdjustSectionMark) {
+                    if (isTouchToSeek) {
+                        postDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                isTouchToSeekAnimEnd = false;
+                                autoAdjustSection();
+                            }
+                        }, isThumbOnDragging ? 0 : 300);
+                    } else {
+                        autoAdjustSection();
+                    }
+                } else if (isThumbOnDragging || isTouchToSeek) {
+                    animate()
+                            .setDuration(mAnimDuration)
+                            .setStartDelay(!isThumbOnDragging && isTouchToSeek ? 300 : 0)
+                            .setListener(new AnimatorListenerAdapter() {
+                                @Override
+                                public void onAnimationEnd(Animator animation) {
+                                    isThumbOnDragging = false;
+                                    invalidate();
+
+                                    if (mProgressListener != null) {
+                                        mProgressListener.onProgressChanged(SignSeekBar.this,
+                                                getProgress(), getProgressFloat(), true);
+                                    }
+                                }
+
+                                @Override
+                                public void onAnimationCancel(Animator animation) {
+                                    isThumbOnDragging = false;
+                                    invalidate();
+                                }
+                            })
+                            .start();
+                }
+
+                if (mProgressListener != null) {
+                    mProgressListener.getProgressOnActionUp(this, getProgress(), getProgressFloat());
+                }
+
+                break;
+        }
+
+        return isThumbOnDragging || isTouchToSeek || super.onTouchEvent(event);
+    }
+
+    /**
+     * 计算新的透明度颜色
+     *
+     * @param color 旧颜色
+     * @param ratio 透明度系数
+     */
+    public int getColorWithAlpha(int color, float ratio) {
+        int newColor = 0;
+        int alpha = Math.round(Color.alpha(color) * ratio);
+        int r = Color.red(color);
+        int g = Color.green(color);
+        int b = Color.blue(color);
+        newColor = Color.argb(alpha, r, g, b);
+        return newColor;
+    }
+
+    /**
+     * Detect effective touch of thumb
+     */
+    private boolean isThumbTouched(MotionEvent event) {
+        if (!isEnabled())
+            return false;
+        float mCircleR = isThumbOnDragging ? mThumbRadiusOnDragging : mThumbRadius;
+        float x = mTrackLength / mDelta * (mProgress - mMin) + mLeft;
+        float y = getMeasuredHeight() / 2f;
+        return (event.getX() - x) * (event.getX() - x) + (event.getY() - y) * (event.getY() - y)
+                <= (mLeft + mCircleR) * (mLeft + mCircleR);
+    }
+
+    /**
+     * Detect effective touch of track
+     */
+    private boolean isTrackTouched(MotionEvent event) {
+        return isEnabled() && event.getX() >= getPaddingLeft() && event.getX() <= getMeasuredWidth() - getPaddingRight()
+                && event.getY() >= getPaddingTop() && event.getY() <= getMeasuredHeight() - getPaddingBottom();
+    }
+
+    /**
+     * Auto scroll to the nearest section mark
+     */
+    private void autoAdjustSection() {
+        int i;
+        //计算最近节点位置，mSectionCount：节点个数，mSectionOffset：两个节点间隔距离，mThumbCenterX：滑块中心点位置
+        float x = 0;
+        for (i = 0; i <= mSectionCount; i++) {
+            x = i * mSectionOffset + mLeft;
+            if (x <= mThumbCenterX && mThumbCenterX - x <= mSectionOffset) {
+                break;
+            }
+        }
+
+        BigDecimal bigDecimal = BigDecimal.valueOf(mThumbCenterX);
+        //BigDecimal setScale保留1位小数，四舍五入，2.35变成2.4
+        float x_ = bigDecimal.setScale(1, BigDecimal.ROUND_HALF_UP).floatValue();
+        boolean onSection = x_ == x; // 就在section处，不作valueAnim，优化性能
+
+        AnimatorSet animatorSet = new AnimatorSet();
+        ValueAnimator valueAnim = null;
+        if (!onSection) {
+            if (mThumbCenterX - x <= mSectionOffset / 2f) {
+                valueAnim = ValueAnimator.ofFloat(mThumbCenterX, x);
+            } else {
+                valueAnim = ValueAnimator.ofFloat(mThumbCenterX, (i + 1) * mSectionOffset + mLeft);
+            }
+            valueAnim.setInterpolator(new LinearInterpolator());
+            valueAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                @Override
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    mThumbCenterX = (float) animation.getAnimatedValue();
+                    mProgress = (mThumbCenterX - mLeft) * mDelta / mTrackLength + mMin;
+                    invalidate();
+
+                    if (mProgressListener != null) {
+                        mProgressListener.onProgressChanged(SignSeekBar.this, getProgress(), getProgressFloat(), true);
+                    }
+                }
+            });
+        }
+        if (!onSection) {
+            animatorSet.setDuration(mAnimDuration).playTogether(valueAnim);
+        }
+        animatorSet.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                mProgress = (mThumbCenterX - mLeft) * mDelta / mTrackLength + mMin;
+                isThumbOnDragging = false;
+                isTouchToSeekAnimEnd = true;
+                invalidate();
+
+                if (mProgressListener != null) {
+                    mProgressListener.getProgressOnFinally(SignSeekBar.this, getProgress(), getProgressFloat(), true);
+                }
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                mProgress = (mThumbCenterX - mLeft) * mDelta / mTrackLength + mMin;
+                isThumbOnDragging = false;
+                isTouchToSeekAnimEnd = true;
+                invalidate();
+            }
+        });
+        animatorSet.start();
+    }
+
+    private String getMinText() {
+        return isFloatType ? float2String(mMin) : String.valueOf((int) mMin);
+    }
+
+    private String getMaxText() {
+        return isFloatType ? float2String(mMax) : String.valueOf((int) mMax);
+    }
+
+    public float getMin() {
+        return mMin;
+    }
+
+    public float getMax() {
+        return mMax;
+    }
+
+    public void setProgress(float progress) {
+        mProgress = progress;
+        if (mProgressListener != null) {
+            mProgressListener.onProgressChanged(this, getProgress(), getProgressFloat(), false);
+            mProgressListener.getProgressOnFinally(this, getProgress(), getProgressFloat(), false);
+        }
+        postInvalidate();
+    }
+
+    public int getProgress() {
+        if (isSeekBySection && triggerSeekBySection) {
+            float half = mSectionValue / 2;
+
+            if (mProgress >= mPreSecValue) { // increasing
+                if (mProgress >= mPreSecValue + half) {
+                    mPreSecValue += mSectionValue;
+                    return Math.round(mPreSecValue);
+                } else {
+                    return Math.round(mPreSecValue);
+                }
+            } else { // reducing
+                if (mProgress >= mPreSecValue - half) {
+                    return Math.round(mPreSecValue);
+                } else {
+                    mPreSecValue -= mSectionValue;
+                    return Math.round(mPreSecValue);
+                }
+            }
+        }
+
+        return Math.round(mProgress);
+    }
+
+    public float getProgressFloat() {
+        return formatFloat(mProgress);
+    }
+
+    public void setOnProgressChangedListener(OnProgressChangedListener onProgressChangedListener) {
+        mProgressListener = onProgressChangedListener;
+    }
+
+    public void setValueFormatListener(OnValueFormatListener valueFormatListener) {
+        mValueFormatListener = valueFormatListener;
+    }
+
+    void config(SignConfigBuilder builder) {
+        mMin = builder.min;
+        mMax = builder.max;
+        mProgress = builder.progress;
+        isFloatType = builder.floatType;
+        mTrackSize = builder.trackSize;
+        mSecondTrackSize = builder.secondTrackSize;
+        mThumbRadius = builder.thumbRadius;
+        mThumbRadiusOnDragging = builder.thumbRadiusOnDragging;
+        mTrackColor = builder.trackColor;
+        mSecondTrackColor = builder.secondTrackColor;
+        mThumbColor = builder.thumbColor;
+        mSectionCount = builder.sectionCount;
+        isShowSectionMark = builder.showSectionMark;
+        isAutoAdjustSectionMark = builder.autoAdjustSectionMark;
+        isShowSectionText = builder.showSectionText;
+        mSectionTextSize = builder.sectionTextSize;
+        mSectionTextColor = builder.sectionTextColor;
+        mSectionTextPosition = builder.sectionTextPosition;
+        mSectionTextInterval = builder.sectionTextInterval;
+        isShowThumbText = builder.showThumbText;
+        mThumbTextSize = builder.thumbTextSize;
+        mThumbTextColor = builder.thumbTextColor;
+        isShowProgressInFloat = builder.showProgressInFloat;
+        mAnimDuration = builder.animDuration;
+        isTouchToSeek = builder.touchToSeek;
+        isSeekBySection = builder.seekBySection;
+        mSidesLabels = mConfigBuilder.bottomSidesLabels;
+        isSidesLabels = mSidesLabels != null && mSidesLabels.length > 0;
+        mThumbBgAlpha = mConfigBuilder.thumbBgAlpha;
+        mThumbRatio = mConfigBuilder.thumbRatio;
+        isShowThumbShadow = mConfigBuilder.showThumbShadow;
+        unit = mConfigBuilder.unit;
+        mReverse = mConfigBuilder.reverse;
+        mFormat = mConfigBuilder.format;
+        mSignColor = builder.signColor;
+        mSignTextSize = builder.signTextSize;
+        mSignTextColor = builder.signTextColor;
+        isShowSign = builder.showSign;
+        mSignArrowWidth = builder.signArrowWidth;
+        mSignArrowHeight = builder.signArrowHeight;
+        mSignRound = builder.signRound;
+        mSignHeight = builder.signHeight;
+        mSignWidth = builder.signWidth;
+        isShowSignBorder = builder.showSignBorder;
+        mSignBorderSize = builder.signBorderSize;
+        mSignBorderColor = builder.signBorderColor;
+        isSignArrowAutofloat = builder.signArrowAutofloat;
+
+        init();
+        initConfigByPriority();
+        createValueTextLayout();
+        if (mProgressListener != null) {
+            mProgressListener.onProgressChanged(this, getProgress(), getProgressFloat(), false);
+            mProgressListener.getProgressOnFinally(this, getProgress(), getProgressFloat(), false);
+        }
+
+        mConfigBuilder = null;
+
+        requestLayout();
+    }
+
+    public SignConfigBuilder getConfigBuilder() {
+        if (mConfigBuilder == null) {
+            mConfigBuilder = new SignConfigBuilder(this);
+        }
+        mConfigBuilder.min = mMin;
+        mConfigBuilder.max = mMax;
+        mConfigBuilder.progress = mProgress;
+        mConfigBuilder.floatType = isFloatType;
+        mConfigBuilder.trackSize = mTrackSize;
+        mConfigBuilder.secondTrackSize = mSecondTrackSize;
+        mConfigBuilder.thumbRadius = mThumbRadius;
+        mConfigBuilder.thumbRadiusOnDragging = mThumbRadiusOnDragging;
+        mConfigBuilder.trackColor = mTrackColor;
+        mConfigBuilder.secondTrackColor = mSecondTrackColor;
+        mConfigBuilder.thumbColor = mThumbColor;
+        mConfigBuilder.sectionCount = mSectionCount;
+        mConfigBuilder.showSectionMark = isShowSectionMark;
+        mConfigBuilder.autoAdjustSectionMark = isAutoAdjustSectionMark;
+        mConfigBuilder.showSectionText = isShowSectionText;
+        mConfigBuilder.sectionTextSize = mSectionTextSize;
+        mConfigBuilder.sectionTextColor = mSectionTextColor;
+        mConfigBuilder.sectionTextPosition = mSectionTextPosition;
+        mConfigBuilder.sectionTextInterval = mSectionTextInterval;
+        mConfigBuilder.showThumbText = isShowThumbText;
+        mConfigBuilder.thumbTextSize = mThumbTextSize;
+        mConfigBuilder.thumbTextColor = mThumbTextColor;
+        mConfigBuilder.showProgressInFloat = isShowProgressInFloat;
+        mConfigBuilder.animDuration = mAnimDuration;
+        mConfigBuilder.touchToSeek = isTouchToSeek;
+        mConfigBuilder.seekBySection = isSeekBySection;
+        mConfigBuilder.bottomSidesLabels = mSidesLabels;
+        mConfigBuilder.thumbBgAlpha = mThumbBgAlpha;
+        mConfigBuilder.thumbRatio = mThumbRatio;
+        mConfigBuilder.showThumbShadow = isShowThumbShadow;
+        mConfigBuilder.unit = unit;
+        mConfigBuilder.reverse = mReverse;
+        mConfigBuilder.format = mFormat;
+        mConfigBuilder.signColor = mSignColor;
+        mConfigBuilder.signTextSize = mSignTextSize;
+        mConfigBuilder.signTextColor = mSignTextColor;
+        mConfigBuilder.showSign = isShowSign;
+        mConfigBuilder.signArrowHeight = mSignArrowHeight;
+        mConfigBuilder.signArrowWidth = mSignArrowWidth;
+        mConfigBuilder.signRound = mSignRound;
+        mConfigBuilder.signHeight = mSignHeight;
+        mConfigBuilder.signWidth = mSignWidth;
+        mConfigBuilder.showSignBorder = isShowSignBorder;
+        mConfigBuilder.signBorderSize = mSignBorderSize;
+        mConfigBuilder.signBorderColor = mSignBorderColor;
+        mConfigBuilder.signArrowAutofloat = isSignArrowAutofloat;
+
+        return mConfigBuilder;
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        Bundle bundle = new Bundle();
+        bundle.putParcelable("save_instance", super.onSaveInstanceState());
+        bundle.putFloat("progress", mProgress);
+        return bundle;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        if (state instanceof Bundle) {
+            Bundle bundle = (Bundle) state;
+            mProgress = bundle.getFloat("progress");
+            super.onRestoreInstanceState(bundle.getParcelable("save_instance"));
+            setProgress(mProgress);
+            return;
+        }
+        super.onRestoreInstanceState(state);
+    }
+
+    private String float2String(float value) {
+        return String.valueOf(formatFloat(value));
+    }
+
+    private float formatFloat(float value) {
+        BigDecimal bigDecimal = BigDecimal.valueOf(value);
+        return bigDecimal.setScale(1, BigDecimal.ROUND_HALF_UP).floatValue();
+    }
+
+    /**
+     * Listen to progress onChanged, onActionUp, onFinally
+     */
+    public interface OnProgressChangedListener {
+
+        void onProgressChanged(SignSeekBar signSeekBar, int progress, float progressFloat, boolean fromUser);
+
+        void getProgressOnActionUp(SignSeekBar signSeekBar, int progress, float progressFloat);
+
+        void getProgressOnFinally(SignSeekBar signSeekBar, int progress, float progressFloat, boolean fromUser);
+    }
+
+    public interface OnValueFormatListener {
+        String format(float progress);
+    }
+}
Index: app/src/main/res/menu/crop_image_menu.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/menu/crop_image_menu.xml b/app/src/main/res/menu/crop_image_menu.xml
new file mode 100644
--- /dev/null	(date 1694964014000)
+++ b/app/src/main/res/menu/crop_image_menu.xml	(date 1694964014000)
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/crop_image_menu_rotate_left"
+        android:icon="@drawable/crop_image_menu_rotate_left"
+        android:title="@string/crop_image_menu_rotate_left"
+        android:visible="false"
+        app:showAsAction="ifRoom"/>
+    <item
+        android:id="@+id/crop_image_menu_rotate_right"
+        android:icon="@drawable/crop_image_menu_rotate_right"
+        android:title="@string/crop_image_menu_rotate_right"
+        app:showAsAction="ifRoom"/>
+    <item
+        android:id="@+id/crop_image_menu_flip"
+        android:icon="@drawable/crop_image_menu_flip"
+        android:title="@string/crop_image_menu_flip"
+        app:showAsAction="ifRoom">
+        <menu>
+            <item
+                android:id="@+id/crop_image_menu_flip_horizontally"
+                android:title="@string/crop_image_menu_flip_horizontally"/>
+            <item
+                android:id="@+id/crop_image_menu_flip_vertically"
+                android:title="@string/crop_image_menu_flip_vertically"/>
+        </menu>
+    </item>
+    <item
+        android:id="@+id/crop_image_menu_crop"
+        android:title="@string/crop_image_menu_crop"
+        app:showAsAction="always"/>
+
+</menu>
\ No newline at end of file
Index: app/src/main/java/com/zhouyou/view/seekbar/SignUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/zhouyou/view/seekbar/SignUtils.java b/app/src/main/java/com/zhouyou/view/seekbar/SignUtils.java
new file mode 100644
--- /dev/null	(date 1584942681000)
+++ b/app/src/main/java/com/zhouyou/view/seekbar/SignUtils.java	(date 1584942681000)
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2017 zhouyou(478319399@qq.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.zhouyou.view.seekbar;
+
+import android.content.res.Resources;
+import android.os.Environment;
+import android.util.TypedValue;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.Properties;
+/**
+ * <p>描述：工具类 单位转换</p>
+ * 作者： zhouyou<br>
+ * 日期： 2017/10/10 16:16 <br>
+ * 版本： v1.0<br>
+ */
+public class SignUtils {
+    private static final File BUILD_PROP_FILE = new File(Environment.getRootDirectory(), "build.prop");
+    private static Properties sBuildProperties;
+    private static final Object sBuildPropertiesLock = new Object();
+
+    private static Properties getBuildProperties() {
+        synchronized (sBuildPropertiesLock) {
+            if (sBuildProperties == null) {
+                sBuildProperties = new Properties();
+                try {
+                    sBuildProperties.load(new FileInputStream(BUILD_PROP_FILE));
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return sBuildProperties;
+    }
+
+    static int dp2px(int dp) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp,
+                Resources.getSystem().getDisplayMetrics());
+    }
+
+    static int sp2px(int sp) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, sp,
+                Resources.getSystem().getDisplayMetrics());
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/zhouyou/view/seekbar/SignConfigBuilder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/zhouyou/view/seekbar/SignConfigBuilder.java b/app/src/main/java/com/zhouyou/view/seekbar/SignConfigBuilder.java
new file mode 100644
--- /dev/null	(date 1726398052508)
+++ b/app/src/main/java/com/zhouyou/view/seekbar/SignConfigBuilder.java	(date 1726398052508)
@@ -0,0 +1,508 @@
+/*
+ * Copyright (C) 2017 zhouyou(478319399@qq.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.zhouyou.view.seekbar;
+
+import java.text.NumberFormat;
+
+import androidx.annotation.ColorInt;
+import androidx.annotation.IntRange;
+
+/**
+ * <p>描述：config SignSeekBar's attributes</p>
+ * 作者： zhouyou<br>
+ * 日期： 2017/10/10 16:15 <br>
+ * 版本： v1.0<br>
+ */
+public class SignConfigBuilder {
+    float min;
+    float max;
+    float progress;
+    boolean floatType;
+    int trackSize;
+    int secondTrackSize;
+    int thumbRadius;
+    int thumbRadiusOnDragging;
+    int trackColor;
+    int secondTrackColor;
+    int thumbColor;
+    int sectionCount;
+    boolean showSectionMark;
+    boolean autoAdjustSectionMark;
+    boolean showSectionText;
+    int sectionTextSize;
+    int sectionTextColor;
+    @SignSeekBar.TextPosition
+    int sectionTextPosition;
+    int sectionTextInterval;
+    boolean showThumbText;
+    int thumbTextSize;
+    int thumbTextColor;
+    boolean showProgressInFloat;
+    long animDuration;
+    boolean touchToSeek;
+    boolean seekBySection;
+    int signColor;
+    int signTextSize;
+    int signTextColor;
+    boolean showSign;
+    String[] bottomSidesLabels;
+    float thumbBgAlpha; //  alpha of thumb shadow
+    float thumbRatio; // ratio of thumb shadow
+    boolean showThumbShadow;
+    SignSeekBar mSignSeekBar;
+    String unit;
+    int signArrowHeight;
+    int signArrowWidth;
+    int signRound;
+    int signHeight; //sign Height
+    int signWidth; //sign width
+    int signBorderSize; // border size
+    boolean showSignBorder; // show sign border
+    boolean signArrowAutofloat;
+    int signBorderColor;// color of border color
+    NumberFormat format;
+    boolean reverse;
+
+    SignConfigBuilder(SignSeekBar signSeekBar) {
+        mSignSeekBar = signSeekBar;
+    }
+
+    public void build() {
+        mSignSeekBar.config(this);
+    }
+
+    public SignConfigBuilder min(float min) {
+        this.min = min;
+        this.progress = min;
+        return this;
+    }
+
+    public SignConfigBuilder max(float max) {
+        this.max = max;
+        return this;
+    }
+
+    public SignConfigBuilder progress(float progress) {
+        this.progress = progress;
+        return this;
+    }
+
+    public SignConfigBuilder floatType() {
+        this.floatType = true;
+        return this;
+    }
+
+    public SignConfigBuilder trackSize(int dp) {
+        this.trackSize = SignUtils.dp2px(dp);
+        return this;
+    }
+
+    public SignConfigBuilder secondTrackSize(int dp) {
+        this.secondTrackSize = SignUtils.dp2px(dp);
+        return this;
+    }
+
+    public SignConfigBuilder thumbRadius(int dp) {
+        this.thumbRadius = SignUtils.dp2px(dp);
+        return this;
+    }
+
+    public SignConfigBuilder thumbRadiusOnDragging(int dp) {
+        this.thumbRadiusOnDragging = SignUtils.dp2px(dp);
+        return this;
+    }
+
+    public SignConfigBuilder trackColor(@ColorInt int color) {
+        this.trackColor = color;
+        this.sectionTextColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder secondTrackColor(@ColorInt int color) {
+        this.secondTrackColor = color;
+        this.thumbColor = color;
+        this.thumbTextColor = color;
+        this.signColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder thumbColor(@ColorInt int color) {
+        this.thumbColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder sectionCount(@IntRange (from = 1) int count) {
+        this.sectionCount = count;
+        return this;
+    }
+
+    public SignConfigBuilder showSectionMark() {
+        this.showSectionMark = true;
+        return this;
+    }
+
+    public SignConfigBuilder autoAdjustSectionMark() {
+        this.autoAdjustSectionMark = true;
+        return this;
+    }
+
+    public SignConfigBuilder showSectionText() {
+        this.showSectionText = true;
+        return this;
+    }
+
+    public SignConfigBuilder sectionTextSize(int sp) {
+        this.sectionTextSize = SignUtils.sp2px(sp);
+        return this;
+    }
+
+    public SignConfigBuilder sectionTextColor(@ColorInt int color) {
+        this.sectionTextColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder sectionTextPosition(@SignSeekBar.TextPosition int position) {
+        this.sectionTextPosition = position;
+        return this;
+    }
+
+    public SignConfigBuilder sectionTextInterval(@IntRange(from = 1) int interval) {
+        this.sectionTextInterval = interval;
+        return this;
+    }
+
+    public SignConfigBuilder showThumbText() {
+        this.showThumbText = true;
+        return this;
+    }
+
+    public SignConfigBuilder thumbTextSize(int sp) {
+        this.thumbTextSize = SignUtils.sp2px(sp);
+        return this;
+    }
+
+    public SignConfigBuilder thumbTextColor(@ColorInt int color) {
+        thumbTextColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder showProgressInFloat() {
+        this.showProgressInFloat = true;
+        return this;
+    }
+
+    public SignConfigBuilder animDuration(long duration) {
+        animDuration = duration;
+        return this;
+    }
+
+    public SignConfigBuilder touchToSeek() {
+        this.touchToSeek = true;
+        return this;
+    }
+
+    public SignConfigBuilder seekBySection() {
+        this.seekBySection = true;
+        return this;
+    }
+
+
+    public SignConfigBuilder bottomSidesLabels(String[] bottomSidesLabels) {
+        this.bottomSidesLabels = bottomSidesLabels;
+        return this;
+    }
+
+    public SignConfigBuilder thumbBgAlpha(float thumbBgAlpha) {
+        this.thumbBgAlpha = thumbBgAlpha;
+        return this;
+    }
+
+    public SignConfigBuilder thumbRatio(float thumbRatio) {
+        this.thumbRatio = thumbRatio;
+        return this;
+    }
+
+    public SignConfigBuilder showThumbShadow(boolean showThumbShadow) {
+        this.showThumbShadow = showThumbShadow;
+        return this;
+    }
+
+    public SignConfigBuilder signColor(@ColorInt int color) {
+        this.signColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder signTextSize(int sp) {
+        this.signTextSize = SignUtils.sp2px(sp);
+        return this;
+    }
+
+    public SignConfigBuilder signTextColor(@ColorInt int color) {
+        this.signTextColor = color;
+        return this;
+    }
+
+    public SignConfigBuilder showSign() {
+        this.showSign = true;
+        return this;
+    }
+
+    public SignConfigBuilder signArrowHeight(int signArrowHeight) {
+        this.signArrowHeight = signArrowHeight;
+        return this;
+    }
+
+    public SignConfigBuilder signArrowWidth(int signArrowWidth) {
+        this.signArrowWidth = signArrowWidth;
+        return this;
+    }
+
+    public SignConfigBuilder signRound(int signRound) {
+        this.signRound = signRound;
+        return this;
+    }
+
+    public SignConfigBuilder signHeight(int signHeight) {
+        this.signHeight = signHeight;
+        return this;
+    }
+
+    public SignConfigBuilder signWidth(int signWidth) {
+        this.signWidth = signWidth;
+        return this;
+    }
+
+    public SignConfigBuilder signBorderSize(int signBorderSize) {
+        this.signBorderSize = signBorderSize;
+        return this;
+    }
+
+    public SignConfigBuilder showSignBorder(boolean showSignBorder) {
+        this.showSignBorder = showSignBorder;
+        return this;
+    }
+
+    public SignConfigBuilder signBorderColor(int signBorderColor) {
+        this.signBorderColor = signBorderColor;
+        return this;
+    }
+
+    public SignConfigBuilder signArrowAutofloat(boolean signArrowAutofloat) {
+        this.signArrowAutofloat = signArrowAutofloat;
+        return this;
+    }
+
+    public float getMin() {
+        return min;
+    }
+
+    public float getMax() {
+        return max;
+    }
+
+    public float getProgress() {
+        return progress;
+    }
+
+    public boolean isFloatType() {
+        return floatType;
+    }
+
+    public int getTrackSize() {
+        return trackSize;
+    }
+
+    public int getSecondTrackSize() {
+        return secondTrackSize;
+    }
+
+    public int getThumbRadius() {
+        return thumbRadius;
+    }
+
+    public int getThumbRadiusOnDragging() {
+        return thumbRadiusOnDragging;
+    }
+
+    public int getTrackColor() {
+        return trackColor;
+    }
+
+    public int getSecondTrackColor() {
+        return secondTrackColor;
+    }
+
+    public int getThumbColor() {
+        return thumbColor;
+    }
+
+    public int getSectionCount() {
+        return sectionCount;
+    }
+
+    public boolean isShowSectionMark() {
+        return showSectionMark;
+    }
+
+    public boolean isAutoAdjustSectionMark() {
+        return autoAdjustSectionMark;
+    }
+
+    public boolean isShowSectionText() {
+        return showSectionText;
+    }
+
+    public int getSectionTextSize() {
+        return sectionTextSize;
+    }
+
+    public int getSectionTextColor() {
+        return sectionTextColor;
+    }
+
+    public int getSectionTextPosition() {
+        return sectionTextPosition;
+    }
+
+    public int getSectionTextInterval() {
+        return sectionTextInterval;
+    }
+
+    public boolean isShowThumbText() {
+        return showThumbText;
+    }
+
+    public int getThumbTextSize() {
+        return thumbTextSize;
+    }
+
+    public int getThumbTextColor() {
+        return thumbTextColor;
+    }
+
+    public boolean isShowProgressInFloat() {
+        return showProgressInFloat;
+    }
+
+    public long getAnimDuration() {
+        return animDuration;
+    }
+
+    public boolean isTouchToSeek() {
+        return touchToSeek;
+    }
+
+    public boolean isSeekBySection() {
+        return seekBySection;
+    }
+
+    public String[] getBottomSidesLabels() {
+        return bottomSidesLabels;
+    }
+
+    public float getThumbBgAlpha() {
+        return thumbBgAlpha;
+    }
+
+    public float getThumbRatio() {
+        return thumbRatio;
+    }
+
+    public boolean isShowThumbShadow() {
+        return showThumbShadow;
+    }
+
+    public SignConfigBuilder setUnit(String unit) {
+        this.unit = unit;
+        return this;
+    }
+
+    public int getSignColor() {
+        return signColor;
+    }
+
+    public int getSignTextSize() {
+        return signTextSize;
+    }
+
+    public int getSignTextColor() {
+        return signTextColor;
+    }
+
+
+    public boolean isshowSign() {
+        return showSign;
+    }
+
+    public String getUnit() {
+        return unit;
+    }
+
+    public int getSignArrowHeight() {
+        return signArrowHeight;
+    }
+
+    public int getSignArrowWidth() {
+        return signArrowWidth;
+    }
+
+    public int getSignRound() {
+        return signRound;
+    }
+
+    public int getSignHeight() {
+        return signHeight;
+    }
+
+    public int getSignWidth() {
+        return signWidth;
+    }
+
+    public int getSignBorderSize() {
+        return signBorderSize;
+    }
+
+    public boolean isShowSignBorder() {
+        return showSignBorder;
+    }
+
+    public int getSignBorderColor() {
+        return signBorderColor;
+    }
+
+    public boolean isSignArrowAutofloat() {
+        return signArrowAutofloat;
+    }
+
+    public SignConfigBuilder format(NumberFormat format) {
+        this.format = format;
+        return this;
+    }
+
+    public NumberFormat getFormat() {
+        return format;
+    }
+
+    public boolean isReverse() {
+        return reverse;
+    }
+
+    public SignConfigBuilder reverse() {
+        this.reverse = true;
+        return this;
+    }
+}
Index: app/src/main/java/com/github/aakira/expandablelayout/Utils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/Utils.java b/app/src/main/java/com/github/aakira/expandablelayout/Utils.java
new file mode 100644
--- /dev/null	(date 1726419765490)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/Utils.java	(date 1726419765490)
@@ -0,0 +1,66 @@
+package com.github.aakira.expandablelayout;
+
+import android.animation.TimeInterpolator;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.AnticipateInterpolator;
+import android.view.animation.AnticipateOvershootInterpolator;
+import android.view.animation.BounceInterpolator;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.LinearInterpolator;
+import android.view.animation.OvershootInterpolator;
+
+import androidx.annotation.IntRange;
+import androidx.interpolator.view.animation.FastOutLinearInInterpolator;
+import androidx.interpolator.view.animation.FastOutSlowInInterpolator;
+import androidx.interpolator.view.animation.LinearOutSlowInInterpolator;
+
+public class Utils {
+
+    public static final int ACCELERATE_DECELERATE_INTERPOLATOR = 0;
+    public static final int ACCELERATE_INTERPOLATOR = 1;
+    public static final int ANTICIPATE_INTERPOLATOR = 2;
+    public static final int ANTICIPATE_OVERSHOOT_INTERPOLATOR = 3;
+    public static final int BOUNCE_INTERPOLATOR = 4;
+    public static final int DECELERATE_INTERPOLATOR = 5;
+    public static final int FAST_OUT_LINEAR_IN_INTERPOLATOR = 6;
+    public static final int FAST_OUT_SLOW_IN_INTERPOLATOR = 7;
+    public static final int LINEAR_INTERPOLATOR = 8;
+    public static final int LINEAR_OUT_SLOW_IN_INTERPOLATOR = 9;
+    public static final int OVERSHOOT_INTERPOLATOR = 10;
+
+    /**
+     * Creates interpolator.
+     *
+     * @param interpolatorType
+     * @return
+     */
+    public static TimeInterpolator createInterpolator(@IntRange (from = 0, to = 10) final int interpolatorType) {
+        switch (interpolatorType) {
+            case ACCELERATE_DECELERATE_INTERPOLATOR:
+                return new AccelerateDecelerateInterpolator();
+            case ACCELERATE_INTERPOLATOR:
+                return new AccelerateInterpolator();
+            case ANTICIPATE_INTERPOLATOR:
+                return new AnticipateInterpolator();
+            case ANTICIPATE_OVERSHOOT_INTERPOLATOR:
+                return new AnticipateOvershootInterpolator();
+            case BOUNCE_INTERPOLATOR:
+                return new BounceInterpolator();
+            case DECELERATE_INTERPOLATOR:
+                return new DecelerateInterpolator();
+            case FAST_OUT_LINEAR_IN_INTERPOLATOR:
+                return new FastOutLinearInInterpolator ();
+            case FAST_OUT_SLOW_IN_INTERPOLATOR:
+                return new FastOutSlowInInterpolator ();
+            case LINEAR_INTERPOLATOR:
+                return new LinearInterpolator();
+            case LINEAR_OUT_SLOW_IN_INTERPOLATOR:
+                return new LinearOutSlowInInterpolator ();
+            case OVERSHOOT_INTERPOLATOR:
+                return new OvershootInterpolator();
+            default:
+                return new LinearInterpolator();
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableSavedState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableSavedState.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableSavedState.java
new file mode 100644
--- /dev/null	(date 1473722736000)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableSavedState.java	(date 1473722736000)
@@ -0,0 +1,54 @@
+package com.github.aakira.expandablelayout;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.view.View;
+
+public class ExpandableSavedState extends View.BaseSavedState {
+    private int size;
+    private float weight;
+
+    ExpandableSavedState(Parcelable superState) {
+        super(superState);
+    }
+
+    private ExpandableSavedState(Parcel in) {
+        super(in);
+        this.size = in.readInt();
+        this.weight = in.readFloat();
+    }
+
+    public int getSize() {
+        return this.size;
+    }
+
+    public void setSize(int size) {
+        this.size = size;
+    }
+
+    public float getWeight() {
+        return this.weight;
+    }
+
+    public void setWeight(float weight) {
+        this.weight = weight;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flags) {
+        super.writeToParcel(out, flags);
+        out.writeInt(this.size);
+        out.writeFloat(this.weight);
+    }
+
+    public static final Creator<ExpandableSavedState> CREATOR =
+            new Creator<ExpandableSavedState>() {
+                public ExpandableSavedState createFromParcel(Parcel in) {
+                    return new ExpandableSavedState(in);
+                }
+
+                public ExpandableSavedState[] newArray(int size) {
+                    return new ExpandableSavedState[size];
+                }
+            };
+}
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayout.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayout.java
new file mode 100644
--- /dev/null	(date 1726419717958)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayout.java	(date 1726419717958)
@@ -0,0 +1,116 @@
+package com.github.aakira.expandablelayout;
+
+import android.animation.TimeInterpolator;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+public interface ExpandableLayout {
+
+    /**
+     * Duration of expand animation
+     */
+    int DEFAULT_DURATION = 300;
+    /**
+     * Visibility of the layout when the layout attaches
+     */
+    boolean DEFAULT_EXPANDED = false;
+    /**
+     * Orientation of child views
+     */
+    int HORIZONTAL = 0;
+    /**
+     * Orientation of child views
+     */
+    int VERTICAL = 1;
+
+    /**
+     * Orientation of layout
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef ({HORIZONTAL, VERTICAL})
+    @interface Orientation {
+    }
+
+    /**
+     * Starts animation the state of the view to the inverse of its current state.
+     */
+    void toggle();
+
+    /**
+     * Starts animation the state of the view to the inverse of its current state.
+     *
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    void toggle(final long duration, @Nullable final TimeInterpolator interpolator);
+
+    /**
+     * Starts expand animation.
+     */
+    void expand();
+
+    /**
+     * Starts expand animation.
+     *
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    void expand(final long duration, @Nullable final TimeInterpolator interpolator);
+
+    /**
+     * Starts collapse animation.
+     */
+    void collapse();
+
+    /**
+     * Starts collapse animation.
+     *
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    void collapse(final long duration, @Nullable final TimeInterpolator interpolator);
+
+    /**
+     * Sets the expandable layout listener.
+     *
+     * @param listener ExpandableLayoutListener
+     */
+    void setListener(@NonNull final ExpandableLayoutListener listener);
+
+    /**
+     * Sets the length of the animation.
+     * The default duration is 300 milliseconds.
+     *
+     * @param duration
+     */
+    void setDuration(final int duration);
+
+    /**
+     * Sets state of expanse.
+     *
+     * @param expanded The layout is visible if expanded is true
+     */
+    void setExpanded(final boolean expanded);
+
+    /**
+     * Gets state of expanse.
+     *
+     * @return true if the layout is visible
+     */
+    boolean isExpanded();
+
+    /**
+     * The time interpolator used in calculating the elapsed fraction of this animation. The
+     * interpolator determines whether the animation runs with linear or non-linear motion,
+     * such as acceleration and deceleration.
+     * The default value is  {@link android.view.animation.AccelerateDecelerateInterpolator}
+     *
+     * @param interpolator
+     */
+    void setInterpolator(@NonNull final TimeInterpolator interpolator);
+}
\ No newline at end of file
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle b/build.gradle
--- a/build.gradle	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/build.gradle	(date 1726419191152)
@@ -12,11 +12,13 @@
         jcenter()
         mavenCentral()
         maven {url 'https://jcenter.bintray.com'}
+        maven { url 'https://jitpack.io' }
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:7.1.3'
         classpath 'com.google.gms:google-services:4.3.14'
         classpath 'com.google.firebase:firebase-crashlytics-gradle:2.9.2'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
     }
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListenerAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListenerAdapter.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListenerAdapter.java
new file mode 100644
--- /dev/null	(date 1473722736000)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListenerAdapter.java	(date 1473722736000)
@@ -0,0 +1,45 @@
+package com.github.aakira.expandablelayout;
+
+public abstract class ExpandableLayoutListenerAdapter implements ExpandableLayoutListener {
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onAnimationStart() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onAnimationEnd() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPreOpen() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPreClose() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onOpened() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onClosed() {
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/chaos/view/DefaultMovementMethod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/chaos/view/DefaultMovementMethod.java b/app/src/main/java/com/chaos/view/DefaultMovementMethod.java
new file mode 100644
--- /dev/null	(date 1613633776000)
+++ b/app/src/main/java/com/chaos/view/DefaultMovementMethod.java	(date 1613633776000)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2018 Chaos
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.chaos.view;
+
+import android.text.Selection;
+import android.text.Spannable;
+import android.text.method.MovementMethod;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.widget.TextView;
+
+/**
+ * For disable arrow key
+ *
+ * @author Chaos
+ *         31/03/2018
+ */
+class DefaultMovementMethod implements MovementMethod {
+
+    private static DefaultMovementMethod sInstance;
+
+    public static MovementMethod getInstance() {
+        if (sInstance == null) {
+            sInstance = new DefaultMovementMethod();
+        }
+
+        return sInstance;
+    }
+
+    private DefaultMovementMethod() {
+    }
+
+    @Override
+    public void initialize(TextView widget, Spannable text) {
+        // It will mark the IMM as openable
+        Selection.setSelection(text, 0);
+    }
+
+    @Override
+    public boolean onKeyDown(TextView widget, Spannable text, int keyCode, KeyEvent event) {
+        return false;
+    }
+
+    @Override
+    public boolean onKeyUp(TextView widget, Spannable text, int keyCode, KeyEvent event) {
+        return false;
+    }
+
+    @Override
+    public boolean onKeyOther(TextView view, Spannable text, KeyEvent event) {
+        return false;
+    }
+
+    @Override
+    public void onTakeFocus(TextView widget, Spannable text, int direction) {
+
+    }
+
+    @Override
+    public boolean onTrackballEvent(TextView widget, Spannable text, MotionEvent event) {
+        return false;
+    }
+
+    @Override
+    public boolean onTouchEvent(TextView widget, Spannable text, MotionEvent event) {
+        return false;
+    }
+
+    @Override
+    public boolean onGenericMotionEvent(TextView widget, Spannable text, MotionEvent event) {
+        return false;
+    }
+
+    @Override
+    public boolean canSelectArbitrarily() {
+        return false;
+    }
+}
Index: app/src/main/java/com/appyvet/materialrangebar/Bar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/appyvet/materialrangebar/Bar.java b/app/src/main/java/com/appyvet/materialrangebar/Bar.java
new file mode 100644
--- /dev/null	(date 1586853518000)
+++ b/app/src/main/java/com/appyvet/materialrangebar/Bar.java	(date 1586853518000)
@@ -0,0 +1,461 @@
+/*
+ * Copyright 2013, Edmodo, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in compliance with the License.
+ * You may obtain a copy of the License in the LICENSE file, or at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.appyvet.materialrangebar;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import androidx.annotation.Nullable;
+import android.util.TypedValue;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This class represents the underlying gray bar in the RangeBar (without the
+ * thumbs).
+ */
+public class Bar {
+
+    // Member Variables ////////////////////////////////////////////////////////
+
+    private final Resources mRes;
+
+    private final Paint mBarPaint;
+
+    private final Paint mTickPaint;
+    private Paint mLabelPaint;
+
+    // Left-coordinate of the horizontal bar.
+    private final float mLeftX;
+
+    private final float mRightX;
+
+    private final float mY;
+
+    private int mNumSegments;
+
+    private float mTickDistance;
+
+    private final float mTickHeight;
+
+    private int mTickLabelColor;
+
+    private int mTickLabelSelectedColor;
+
+    private CharSequence[] mTickTopLabels;
+
+    private CharSequence[] mTickBottomLabels;
+
+    private String mTickDefaultLabel;
+
+    private float mTickLabelSize;
+
+    private int mTickDefaultColor;
+
+    private List<Integer> mTickColors = new ArrayList<>();
+
+    // Constructor /////////////////////////////////////////////////////////////
+
+    /**
+     * Bar constructor
+     *
+     * @param ctx          the context
+     * @param x            the start x co-ordinate
+     * @param y            the y co-ordinate
+     * @param length       the length of the bar in px
+     * @param tickCount    the number of ticks on the bar
+     * @param tickHeight   the height of each tick
+     * @param barWeight    the weight of the bar
+     * @param barColor     the color of the bar
+     * @param isBarRounded if the bar has rounded edges or not
+     */
+    public Bar(Context ctx,
+               float x,
+               float y,
+               float length,
+               int tickCount,
+               float tickHeight,
+               float barWeight,
+               int barColor,
+               boolean isBarRounded) {
+        mRes = ctx.getResources();
+
+        mLeftX = x;
+        mRightX = x + length;
+        mY = y;
+
+        mNumSegments = tickCount - 1;
+        mTickDistance = length / mNumSegments;
+        mTickHeight = tickHeight;
+        // Initialize the paint.
+        mBarPaint = new Paint();
+        mBarPaint.setColor(barColor);
+        mBarPaint.setStrokeWidth(barWeight);
+        mBarPaint.setAntiAlias(true);
+        if (isBarRounded) {
+            mBarPaint.setStrokeCap(Paint.Cap.ROUND);
+        }
+        mTickPaint = new Paint();
+        mTickPaint.setStrokeWidth(barWeight);
+        mTickPaint.setAntiAlias(true);
+    }
+
+    /**
+     * Bar constructor
+     *
+     * @param ctx              the context
+     * @param x                the start x co-ordinate
+     * @param y                the y co-ordinate
+     * @param length           the length of the bar in px
+     * @param tickCount        the number of ticks on the bar
+     * @param tickHeight       the height of each tick
+     * @param tickDefaultColor the color of all ticks
+     * @param barWeight        the weight of the bar
+     * @param barColor         the color of the bar
+     * @param isBarRounded     if the bar has rounded edges or not
+     */
+    public Bar(Context ctx,
+               float x,
+               float y,
+               float length,
+               int tickCount,
+               float tickHeight,
+               int tickDefaultColor,
+               float barWeight,
+               int barColor,
+               boolean isBarRounded) {
+        this(ctx, x, y, length, tickCount, tickHeight, barWeight, barColor, isBarRounded);
+
+        mTickDefaultColor = tickDefaultColor;
+        mTickPaint.setColor(tickDefaultColor);
+    }
+
+    /**
+     * Bar constructor
+     *
+     * @param ctx              the context
+     * @param x                the start x co-ordinate
+     * @param y                the y co-ordinate
+     * @param length           the length of the bar in px
+     * @param tickCount        the number of ticks on the bar
+     * @param tickHeight       the height of each tick
+     * @param barWeight        the weight of the bar
+     * @param barColor         the color of the bar
+     * @param isBarRounded     if the bar has rounded edges or not
+     * @param tickLabelColor   the color of each tick's label
+     * @param tickTopLabels    the top label of each tick
+     * @param tickBottomLabels the top label of each tick
+     */
+    public Bar(Context ctx,
+               float x,
+               float y,
+               float length,
+               int tickCount,
+               float tickHeight,
+               float barWeight,
+               int barColor,
+               boolean isBarRounded,
+               int tickLabelColor,
+               int tickLabelSelectedColor,
+               CharSequence[] tickTopLabels,
+               CharSequence[] tickBottomLabels,
+               String tickDefaultLabel,
+               float tickLabelSize) {
+        this(ctx, x, y, length, tickCount, tickHeight, barWeight, barColor, isBarRounded);
+
+        if (tickTopLabels != null || tickBottomLabels != null) {
+            // Creates the paint and sets the Paint values
+            mLabelPaint = new Paint();
+            mLabelPaint.setColor(tickLabelColor);
+            mLabelPaint.setAntiAlias(true);
+            mTickLabelColor = tickLabelColor;
+            mTickLabelSelectedColor = tickLabelSelectedColor;
+            mTickTopLabels = tickTopLabels;
+            mTickBottomLabels = tickBottomLabels;
+            mTickDefaultLabel = tickDefaultLabel;
+            mTickLabelSize = tickLabelSize;
+        }
+    }
+
+    /**
+     * Bar constructor
+     *
+     * @param ctx              the context
+     * @param x                the start x co-ordinate
+     * @param y                the y co-ordinate
+     * @param length           the length of the bar in px
+     * @param tickCount        the number of ticks on the bar
+     * @param tickHeight       the height of each tick
+     * @param tickDefaultColor the default color of all ticks
+     * @param barWeight        the weight of the bar
+     * @param barColor         the color of the bar
+     * @param isBarRounded     if the bar has rounded edges or not
+     * @param tickLabelColor   the color of each tick's label
+     * @param tickTopLabels    the top label of each tick
+     * @param tickBottomLabels the top label of each tick
+     */
+    public Bar(Context ctx,
+               float x,
+               float y,
+               float length,
+               int tickCount,
+               float tickHeight,
+               int tickDefaultColor,
+               float barWeight,
+               int barColor,
+               boolean isBarRounded,
+               int tickLabelColor,
+               int tickLabelSelectedColor,
+               CharSequence[] tickTopLabels,
+               CharSequence[] tickBottomLabels,
+               String tickDefaultLabel,
+               float tickLabelSize) {
+        this(ctx, x, y, length, tickCount, tickHeight, barWeight, barColor, isBarRounded, tickLabelColor, tickLabelSelectedColor, tickTopLabels, tickBottomLabels, tickDefaultLabel, tickLabelSize);
+        mTickDefaultColor = tickDefaultColor;
+        mTickPaint.setColor(tickDefaultColor);
+    }
+
+    /**
+     * Bar constructor
+     *
+     * @param ctx              the context
+     * @param x                the start x co-ordinate
+     * @param y                the y co-ordinate
+     * @param length           the length of the bar in px
+     * @param tickCount        the number of ticks on the bar
+     * @param tickHeight       the height of each tick
+     * @param tickDefaultColor defualt tick color
+     * @param tickColors       the colors of each tick
+     * @param barWeight        the weight of the bar
+     * @param barColor         the color of the bar
+     * @param isBarRounded     if the bar has rounded edges or not
+     * @param tickLabelColor   the color of each tick's label
+     * @param tickTopLabels    the top label of each tick
+     * @param tickBottomLabels the top label of each tick
+     */
+    public Bar(Context ctx,
+               float x,
+               float y,
+               float length,
+               int tickCount,
+               float tickHeight,
+               int tickDefaultColor,
+               List<Integer> tickColors,
+               float barWeight,
+               int barColor,
+               boolean isBarRounded,
+               int tickLabelColor,
+               int tickLabelSelectedColor,
+               CharSequence[] tickTopLabels,
+               CharSequence[] tickBottomLabels,
+               String tickDefaultLabel,
+               float tickLabelSize) {
+
+        this(ctx, x, y, length, tickCount, tickHeight, barWeight, barColor, isBarRounded, tickLabelColor, tickLabelSelectedColor, tickTopLabels, tickBottomLabels, tickDefaultLabel, tickLabelSize);
+
+        mTickDefaultColor = tickDefaultColor;
+        mTickColors = tickColors;
+    }
+    // Package-Private Methods /////////////////////////////////////////////////
+
+    /**
+     * Draws the bar on the given Canvas.
+     *
+     * @param canvas Canvas to draw on; should be the Canvas passed into {#link
+     *               View#onDraw()}
+     */
+    public void draw(Canvas canvas) {
+        canvas.drawLine(mLeftX, mY, mRightX, mY, mBarPaint);
+    }
+
+    /**
+     * Get the x-coordinate of the left edge of the bar.
+     *
+     * @return x-coordinate of the left edge of the bar
+     */
+    public float getLeftX() {
+        return mLeftX;
+    }
+
+    /**
+     * Get the x-coordinate of the right edge of the bar.
+     *
+     * @return x-coordinate of the right edge of the bar
+     */
+    public float getRightX() {
+        return mRightX;
+    }
+
+    /**
+     * Gets the x-coordinate of the nearest tick to the given x-coordinate.
+     *
+     * @param thumb the thumb to find the nearest tick for
+     * @return the x-coordinate of the nearest tick
+     */
+    public float getNearestTickCoordinate(PinView thumb) {
+
+        final int nearestTickIndex = getNearestTickIndex(thumb);
+
+        return mLeftX + (nearestTickIndex * mTickDistance);
+    }
+
+    /**
+     * Gets the zero-based index of the nearest tick to the given thumb.
+     *
+     * @param thumb the Thumb to find the nearest tick for
+     * @return the zero-based index of the nearest tick
+     */
+    public int getNearestTickIndex(PinView thumb) {
+
+        int tickIndex = (int) ((thumb.getX() - mLeftX + mTickDistance / 2f) / mTickDistance);
+
+        if (tickIndex > mNumSegments) {
+            tickIndex = mNumSegments;
+        } else if (tickIndex < 0) {
+            tickIndex = 0;
+        }
+        return tickIndex;
+    }
+
+    public float getTickX(int tickIndex) {
+        return mLeftX + (mRightX - mLeftX) / mNumSegments * tickIndex;
+    }
+
+
+    /**
+     * Set the number of ticks that will appear in the RangeBar.
+     *
+     * @param tickCount the number of ticks
+     */
+    public void setTickCount(int tickCount) {
+
+        final float barLength = mRightX - mLeftX;
+
+        mNumSegments = tickCount - 1;
+        mTickDistance = barLength / mNumSegments;
+    }
+
+    private String getTickLabel(int index, CharSequence[] labels) {
+        if (index >= labels.length) {
+            return mTickDefaultLabel;
+        }
+
+        return labels[index].toString();
+    }
+
+    private String getTickTopLabel(int index) {
+        return getTickLabel(index, mTickTopLabels);
+    }
+
+    private String getTickBottomLabel(int index) {
+        return getTickLabel(index, mTickBottomLabels);
+    }
+
+    // Private Methods /////////////////////////////////////////////////////////
+
+    /**
+     * Draws the tick marks on the bar.
+     *
+     * @param canvas Canvas to draw on; should be the Canvas passed into {#link
+     *               View#onDraw()}
+     */
+    public void drawTicks(Canvas canvas, float pinRadius, PinView rightThumb) {
+        drawTicks(canvas, pinRadius, rightThumb, null);
+    }
+
+    public void drawTicks(Canvas canvas, float pinRadius, PinView rightThumb, @Nullable PinView leftThumb) {
+        boolean paintLabel = false;
+        if (mLabelPaint != null) {
+            paintLabel = true;
+            final int textSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, mTickLabelSize,
+                    mRes.getDisplayMetrics());
+            mLabelPaint.setTextSize(textSize);
+        }
+
+        // Loop through and draw each tick (except final tick).
+        for (int i = 0; i < mNumSegments; i++) {
+            final float x = i * mTickDistance + mLeftX;
+            canvas.drawCircle(x, mY, mTickHeight, getTick(i));
+
+            if (paintLabel) {
+                if (mTickTopLabels != null)
+                    drawTickLabel(canvas, getTickTopLabel(i), x, pinRadius, i == 0, false, true, rightThumb, leftThumb);
+
+                if (mTickBottomLabels != null)
+                    drawTickLabel(canvas, getTickBottomLabel(i), x, pinRadius, i == 0, false, false, rightThumb, leftThumb);
+            }
+        }
+        // Draw final tick. We draw the final tick outside the loop to avoid any
+        // rounding discrepancies.
+        canvas.drawCircle(mRightX, mY, mTickHeight, getTick(mNumSegments));
+
+        // Draw final tick's label outside the loop
+        if (paintLabel) {
+            if (mTickTopLabels != null)
+                drawTickLabel(canvas, getTickTopLabel(mNumSegments), mRightX, pinRadius, false, true, true, rightThumb, leftThumb);
+
+            if (mTickBottomLabels != null)
+                drawTickLabel(canvas, getTickBottomLabel(mNumSegments), mRightX, pinRadius, false, true, false, rightThumb, leftThumb);
+        }
+    }
+
+    private void drawTickLabel(Canvas canvas, final String label, float x, float pinRadius,
+                               boolean first, boolean last, boolean isTop, PinView rightThumb, @Nullable PinView leftThumb) {
+
+        Rect labelBounds = new Rect();
+        mLabelPaint.getTextBounds(label, 0, label.length(), labelBounds);
+        float xPos = x - labelBounds.width() / 2;
+
+        if (first) {
+            xPos += mTickHeight;
+        } else if (last) {
+            xPos -= mTickHeight;
+        }
+
+        boolean isSelected = rightThumb.getX() == x;
+
+        if (!isSelected && leftThumb != null) {
+            isSelected = leftThumb.getX() == x;
+        }
+
+        if (isSelected) {
+            mLabelPaint.setColor(mTickLabelSelectedColor);
+        } else {
+            mLabelPaint.setColor(mTickLabelColor);
+        }
+
+        float yPos;
+        if (isTop) {
+            yPos = mY - labelBounds.height() - pinRadius;
+        } else {
+            yPos = mY + labelBounds.height() + pinRadius;
+        }
+
+        canvas.drawText(label, xPos, yPos, mLabelPaint);
+    }
+
+    private Paint getTick(int index) {
+
+        if (mTickColors != null && index < mTickColors.size()) {
+            mTickPaint.setColor(mTickColors.get(index));
+        } else {
+            mTickPaint.setColor(mTickDefaultColor);
+        }
+
+        return mTickPaint;
+    }
+}
Index: app/src/main/java/com/chaos/view/PinView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/chaos/view/PinView.java b/app/src/main/java/com/chaos/view/PinView.java
new file mode 100644
--- /dev/null	(date 1726416763214)
+++ b/app/src/main/java/com/chaos/view/PinView.java	(date 1726416763214)
@@ -0,0 +1,1158 @@
+/*
+ * Copyright 2017 Chaos Leong
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.chaos.view;
+
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.text.InputFilter;
+import android.text.TextPaint;
+import android.text.TextUtils;
+import android.text.method.MovementMethod;
+import android.text.method.TransformationMethod;
+import android.util.AttributeSet;
+import android.view.ActionMode;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.animation.DecelerateInterpolator;
+import android.view.inputmethod.EditorInfo;
+
+import com.qboxus.binder.R;
+
+import androidx.annotation.ColorInt;
+import androidx.annotation.DrawableRes;
+import androidx.annotation.Nullable;
+import androidx.annotation.Px;
+import androidx.appcompat.widget.AppCompatEditText;
+import androidx.core.content.res.ResourcesCompat;
+import androidx.core.view.ViewCompat;
+
+/**
+ * Provides a widget for enter PIN/OTP/password etc.
+ *
+ * @author Chaos Leong
+ * 01/04/2017
+ */
+public class PinView extends AppCompatEditText {
+
+    private static final String TAG = "PinView";
+
+    private static final boolean DBG = false;
+
+    private static final int BLINK = 500;
+
+    private static final int DEFAULT_COUNT = 4;
+
+    private static final InputFilter[] NO_FILTERS = new InputFilter[0];
+
+    private static final int[] HIGHLIGHT_STATES = new int[]{
+            android.R.attr.state_selected};
+
+    private static final int VIEW_TYPE_RECTANGLE = 0;
+    private static final int VIEW_TYPE_LINE = 1;
+    private static final int VIEW_TYPE_NONE = 2;
+
+    private int mViewType;
+
+    private int mPinItemCount;
+
+    private int mPinItemWidth;
+    private int mPinItemHeight;
+    private int mPinItemRadius;
+    private int mPinItemSpacing;
+
+    private final Paint mPaint;
+    private final TextPaint mAnimatorTextPaint = new TextPaint();
+
+    private ColorStateList mLineColor;
+    private int mCurLineColor = Color.BLACK;
+    private int mLineWidth;
+
+    private final Rect mTextRect = new Rect();
+    private final RectF mItemBorderRect = new RectF();
+    private final RectF mItemLineRect = new RectF();
+    private final Path mPath = new Path();
+    private final PointF mItemCenterPoint = new PointF();
+
+    private ValueAnimator mDefaultAddAnimator;
+    private boolean isAnimationEnable = false;
+    private boolean isPasswordHidden;
+
+    private Blink mBlink;
+    private boolean isCursorVisible;
+    private boolean drawCursor;
+    private float mCursorHeight;
+    private int mCursorWidth;
+    private int mCursorColor;
+
+    private int mItemBackgroundResource;
+    private Drawable mItemBackground;
+
+    private boolean mHideLineWhenFilled;
+
+    private String mTransformed;
+
+    public PinView(Context context) {
+        this(context, null);
+    }
+
+    public PinView(Context context, @Nullable AttributeSet attrs) {
+        this(context, attrs, R.attr.pinViewStyle);
+    }
+
+    public PinView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+
+        final Resources res = getResources();
+
+        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        mPaint.setStyle(Paint.Style.STROKE);
+
+        mAnimatorTextPaint.set(getPaint());
+
+        final Resources.Theme theme = context.getTheme();
+
+        TypedArray a = theme.obtainStyledAttributes(attrs, R.styleable.PinView, defStyleAttr, 0);
+
+        mViewType = a.getInt(R.styleable.PinView_viewType, VIEW_TYPE_RECTANGLE);
+        mPinItemCount = a.getInt(R.styleable.PinView_itemCount, DEFAULT_COUNT);
+        mPinItemHeight = (int) a.getDimension(R.styleable.PinView_itemHeight,
+                res.getDimensionPixelSize(R.dimen.pv_pin_view_item_size));
+        mPinItemWidth = (int) a.getDimension(R.styleable.PinView_itemWidth,
+                res.getDimensionPixelSize(R.dimen.pv_pin_view_item_size));
+        mPinItemSpacing = a.getDimensionPixelSize(R.styleable.PinView_itemSpacing,
+                res.getDimensionPixelSize(R.dimen.pv_pin_view_item_spacing));
+        mPinItemRadius = (int) a.getDimension(R.styleable.PinView_itemRadius, 0);
+        mLineWidth = (int) a.getDimension(R.styleable.PinView_lineWidth,
+                res.getDimensionPixelSize(R.dimen.pv_pin_view_item_line_width));
+        mLineColor = a.getColorStateList(R.styleable.PinView_lineColor);
+        isCursorVisible = a.getBoolean(R.styleable.PinView_android_cursorVisible, true);
+        mCursorColor = a.getColor(R.styleable.PinView_cursorColor, getCurrentTextColor());
+        mCursorWidth = a.getDimensionPixelSize(R.styleable.PinView_cursorWidth,
+                res.getDimensionPixelSize(R.dimen.pv_pin_view_cursor_width));
+
+        mItemBackground = a.getDrawable(R.styleable.PinView_android_itemBackground);
+        mHideLineWhenFilled = a.getBoolean(R.styleable.PinView_hideLineWhenFilled, false);
+
+        a.recycle();
+
+        if (mLineColor != null) {
+            mCurLineColor = mLineColor.getDefaultColor();
+        }
+        updateCursorHeight();
+
+        checkItemRadius();
+
+        setMaxLength(mPinItemCount);
+        mPaint.setStrokeWidth(mLineWidth);
+        setupAnimator();
+
+        setTransformationMethod(null);
+        disableSelectionMenu();
+
+        // preserve the legacy behavior: isPasswordHidden controlled by inputType
+        isPasswordHidden = isPasswordInputType(getInputType());
+    }
+
+    // preserve the legacy behavior: isPasswordHidden controlled by inputType
+    @Override
+    public void setInputType(int type) {
+        super.setInputType(type);
+        isPasswordHidden = isPasswordInputType(getInputType());
+    }
+
+    /**
+     * new behavior: reveal or hide the pins programmatically
+     *
+     * @param hidden True to hide, false to reveal the text
+     */
+    public void setPasswordHidden(boolean hidden) {
+        isPasswordHidden = hidden;
+        requestLayout();
+    }
+
+    /**
+     * new behavior: reveal or hide the pins programmatically
+     *
+     * @returns True if the pins are currently hidden
+     */
+    public boolean isPasswordHidden() {
+        return isPasswordHidden;
+    }
+
+    @Override
+    public void setTypeface(Typeface tf, int style) {
+        super.setTypeface(tf, style);
+    }
+
+    @Override
+    public void setTypeface(Typeface tf) {
+        super.setTypeface(tf);
+        if (mAnimatorTextPaint != null) {
+            mAnimatorTextPaint.set(getPaint());
+        }
+    }
+
+    private void setMaxLength(int maxLength) {
+        if (maxLength >= 0) {
+            setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxLength)});
+        } else {
+            setFilters(NO_FILTERS);
+        }
+    }
+
+    private void setupAnimator() {
+        mDefaultAddAnimator = ValueAnimator.ofFloat(0.5f, 1f);
+        mDefaultAddAnimator.setDuration(150);
+        mDefaultAddAnimator.setInterpolator(new DecelerateInterpolator());
+        mDefaultAddAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator animation) {
+                float scale = (Float) animation.getAnimatedValue();
+                int alpha = (int) (255 * scale);
+                mAnimatorTextPaint.setTextSize(getTextSize() * scale);
+                mAnimatorTextPaint.setAlpha(alpha);
+                postInvalidate();
+            }
+        });
+    }
+
+    private void checkItemRadius() {
+        if (mViewType == VIEW_TYPE_LINE) {
+            float halfOfLineWidth = ((float) mLineWidth) / 2;
+            if (mPinItemRadius > halfOfLineWidth) {
+                throw new IllegalArgumentException("The itemRadius can not be greater than lineWidth when viewType is line");
+            }
+        } else if (mViewType == VIEW_TYPE_RECTANGLE) {
+            float halfOfItemWidth = ((float) mPinItemWidth) / 2;
+            if (mPinItemRadius > halfOfItemWidth) {
+                throw new IllegalArgumentException("The itemRadius can not be greater than itemWidth");
+            }
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
+        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+
+        int width;
+        int height;
+
+        int boxHeight = mPinItemHeight;
+
+        if (widthMode == MeasureSpec.EXACTLY) {
+            // Parent has told us how big to be. So be it.
+            width = widthSize;
+        } else {
+            int boxesWidth = (mPinItemCount - 1) * mPinItemSpacing + mPinItemCount * mPinItemWidth;
+            width = boxesWidth + ViewCompat.getPaddingEnd(this) + ViewCompat.getPaddingStart(this);
+            if (mPinItemSpacing == 0) {
+                width -= (mPinItemCount - 1) * mLineWidth;
+            }
+        }
+
+        if (heightMode == MeasureSpec.EXACTLY) {
+            // Parent has told us how big to be. So be it.
+            height = heightSize;
+        } else {
+            height = boxHeight + getPaddingTop() + getPaddingBottom();
+        }
+
+        setMeasuredDimension(width, height);
+    }
+
+    @Override
+    protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) {
+        if (start != text.length()) {
+            moveSelectionToEnd();
+        }
+
+        makeBlink();
+
+        if (isAnimationEnable) {
+            final boolean isAdd = lengthAfter - lengthBefore > 0;
+            if (isAdd) {
+                if (mDefaultAddAnimator != null) {
+                    mDefaultAddAnimator.end();
+                    mDefaultAddAnimator.start();
+                }
+            }
+        }
+
+        TransformationMethod transformation = getTransformationMethod();
+        if (transformation == null) {
+            mTransformed = getText().toString();
+        } else {
+            mTransformed = transformation.getTransformation(getText(), this).toString();
+        }
+    }
+
+    @Override
+    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
+        super.onFocusChanged(focused, direction, previouslyFocusedRect);
+
+        if (focused) {
+            moveSelectionToEnd();
+            makeBlink();
+        }
+    }
+
+    @Override
+    protected void onSelectionChanged(int selStart, int selEnd) {
+        super.onSelectionChanged(selStart, selEnd);
+
+        if (selEnd != getText().length()) {
+            moveSelectionToEnd();
+        }
+    }
+
+    private void moveSelectionToEnd() {
+        setSelection(getText().length());
+    }
+
+    @Override
+    protected void drawableStateChanged() {
+        super.drawableStateChanged();
+
+        if (mLineColor == null || mLineColor.isStateful()) {
+            updateColors();
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        canvas.save();
+
+        updatePaints();
+        drawPinView(canvas);
+
+        canvas.restore();
+    }
+
+    private void updatePaints() {
+        mPaint.setColor(mCurLineColor);
+        mPaint.setStyle(Paint.Style.STROKE);
+        mPaint.setStrokeWidth(mLineWidth);
+        getPaint().setColor(getCurrentTextColor());
+    }
+
+    private void drawPinView(Canvas canvas) {
+        int highlightIdx = getText().length();
+        for (int i = 0; i < mPinItemCount; i++) {
+            boolean highlight = isFocused() && highlightIdx == i;
+            mPaint.setColor(highlight ? getLineColorForState(HIGHLIGHT_STATES) : mCurLineColor);
+
+            updateItemRectF(i);
+            updateCenterPoint();
+
+            canvas.save();
+            if (mViewType == VIEW_TYPE_RECTANGLE) {
+                updatePinBoxPath(i);
+                canvas.clipPath(mPath);
+            }
+            drawItemBackground(canvas, highlight);
+            canvas.restore();
+
+            if (highlight) {
+                drawCursor(canvas);
+            }
+
+            if (mViewType == VIEW_TYPE_RECTANGLE) {
+                drawPinBox(canvas, i);
+            } else if (mViewType == VIEW_TYPE_LINE) {
+                drawPinLine(canvas, i);
+            }
+
+            if (DBG) {
+                drawAnchorLine(canvas);
+            }
+
+            if (mTransformed.length() > i) {
+                if (getTransformationMethod() == null && isPasswordHidden) {
+                    drawCircle(canvas, i);
+                } else {
+                    drawText(canvas, i);
+                }
+            } else if (!TextUtils.isEmpty(getHint()) && getHint().length() == mPinItemCount) {
+                drawHint(canvas, i);
+            }
+        }
+
+        // highlight the next item
+        if (isFocused() && getText().length() != mPinItemCount && mViewType == VIEW_TYPE_RECTANGLE) {
+            int index = getText().length();
+            updateItemRectF(index);
+            updateCenterPoint();
+            updatePinBoxPath(index);
+            mPaint.setColor(getLineColorForState(HIGHLIGHT_STATES));
+            drawPinBox(canvas, index);
+        }
+    }
+
+    private int getLineColorForState(int... states) {
+        return mLineColor != null ? mLineColor.getColorForState(states, mCurLineColor) : mCurLineColor;
+    }
+
+    private void drawItemBackground(Canvas canvas, boolean highlight) {
+        if (mItemBackground == null) {
+            return;
+        }
+        float delta = (float) mLineWidth / 2;
+        int left = Math.round(mItemBorderRect.left - delta);
+        int top = Math.round(mItemBorderRect.top - delta);
+        int right = Math.round(mItemBorderRect.right + delta);
+        int bottom = Math.round(mItemBorderRect.bottom + delta);
+
+        mItemBackground.setBounds(left, top, right, bottom);
+        mItemBackground.setState(highlight ? HIGHLIGHT_STATES : getDrawableState());
+        mItemBackground.draw(canvas);
+    }
+
+    private void updatePinBoxPath(int i) {
+        boolean drawRightCorner = false;
+        boolean drawLeftCorner = false;
+        if (mPinItemSpacing != 0) {
+            drawLeftCorner = drawRightCorner = true;
+        } else {
+            if (i == 0 && i != mPinItemCount - 1) {
+                drawLeftCorner = true;
+            }
+            if (i == mPinItemCount - 1 && i != 0) {
+                drawRightCorner = true;
+            }
+        }
+        updateRoundRectPath(mItemBorderRect, mPinItemRadius, mPinItemRadius, drawLeftCorner, drawRightCorner);
+    }
+
+    private void drawPinBox(Canvas canvas, int i) {
+        if (mHideLineWhenFilled && i < getText().length()) {
+            return;
+        }
+        canvas.drawPath(mPath, mPaint);
+    }
+
+    private void drawPinLine(Canvas canvas, int i) {
+        if (mHideLineWhenFilled && i < getText().length()) {
+            return;
+        }
+        boolean l, r;
+        l = r = true;
+        if (mPinItemSpacing == 0 && mPinItemCount > 1) {
+            if (i == 0) {
+                // draw only left round
+                r = false;
+            } else if (i == mPinItemCount - 1) {
+                // draw only right round
+                l = false;
+            } else {
+                // draw rect
+                l = r = false;
+            }
+        }
+        mPaint.setStyle(Paint.Style.FILL);
+        mPaint.setStrokeWidth(((float) mLineWidth) / 10);
+        float halfLineWidth = ((float) mLineWidth) / 2;
+        mItemLineRect.set(
+                mItemBorderRect.left - halfLineWidth,
+                mItemBorderRect.bottom - halfLineWidth,
+                mItemBorderRect.right + halfLineWidth,
+                mItemBorderRect.bottom + halfLineWidth);
+
+        updateRoundRectPath(mItemLineRect, mPinItemRadius, mPinItemRadius, l, r);
+        canvas.drawPath(mPath, mPaint);
+    }
+
+    private void drawCursor(Canvas canvas) {
+        if (drawCursor) {
+            float cx = mItemCenterPoint.x;
+            float cy = mItemCenterPoint.y;
+            float x = cx;
+            float y = cy - mCursorHeight / 2;
+
+            int color = mPaint.getColor();
+            float width = mPaint.getStrokeWidth();
+            mPaint.setColor(mCursorColor);
+            mPaint.setStrokeWidth(mCursorWidth);
+
+            canvas.drawLine(x, y, x, y + mCursorHeight, mPaint);
+
+            mPaint.setColor(color);
+            mPaint.setStrokeWidth(width);
+        }
+    }
+
+    private void updateRoundRectPath(RectF rectF, float rx, float ry, boolean l, boolean r) {
+        updateRoundRectPath(rectF, rx, ry, l, r, r, l);
+    }
+
+    private void updateRoundRectPath(RectF rectF, float rx, float ry,
+                                     boolean tl, boolean tr, boolean br, boolean bl) {
+        mPath.reset();
+
+        float l = rectF.left;
+        float t = rectF.top;
+        float r = rectF.right;
+        float b = rectF.bottom;
+
+        float w = r - l;
+        float h = b - t;
+
+        float lw = w - 2 * rx;// line width
+        float lh = h - 2 * ry;// line height
+
+        mPath.moveTo(l, t + ry);
+
+        if (tl) {
+            mPath.rQuadTo(0, -ry, rx, -ry);// top-left corner
+        } else {
+            mPath.rLineTo(0, -ry);
+            mPath.rLineTo(rx, 0);
+        }
+
+        mPath.rLineTo(lw, 0);
+
+        if (tr) {
+            mPath.rQuadTo(rx, 0, rx, ry);// top-right corner
+        } else {
+            mPath.rLineTo(rx, 0);
+            mPath.rLineTo(0, ry);
+        }
+
+        mPath.rLineTo(0, lh);
+
+        if (br) {
+            mPath.rQuadTo(0, ry, -rx, ry);// bottom-right corner
+        } else {
+            mPath.rLineTo(0, ry);
+            mPath.rLineTo(-rx, 0);
+        }
+
+        mPath.rLineTo(-lw, 0);
+
+        if (bl) {
+            mPath.rQuadTo(-rx, 0, -rx, -ry);// bottom-left corner
+        } else {
+            mPath.rLineTo(-rx, 0);
+            mPath.rLineTo(0, -ry);
+        }
+
+        mPath.rLineTo(0, -lh);
+
+        mPath.close();
+    }
+
+    private void updateItemRectF(int i) {
+        float halfLineWidth = ((float) mLineWidth) / 2;
+        float left = getScrollX() + ViewCompat.getPaddingStart(this) + i * (mPinItemSpacing + mPinItemWidth) + halfLineWidth;
+        if (mPinItemSpacing == 0 && i > 0) {
+            left = left - (mLineWidth) * i;
+        }
+        float right = left + mPinItemWidth - mLineWidth;
+        float top = getScrollY() + getPaddingTop() + halfLineWidth;
+        float bottom = top + mPinItemHeight - mLineWidth;
+
+        mItemBorderRect.set(left, top, right, bottom);
+    }
+
+    private void drawText(Canvas canvas, int i) {
+        Paint paint = getPaintByIndex(i);
+        // 1, Rect(4, -39, 20, 0)
+        // 您, Rect(2, -47, 51, 3)
+        // *, Rect(0, -39, 23, -16)
+        // =, Rect(4, -26, 26, -10)
+        // -, Rect(1, -19, 14, -14)
+        // +, Rect(2, -32, 29, -3)
+        drawTextAtBox(canvas, paint, mTransformed, i);
+    }
+
+    private void drawHint(Canvas canvas, int i) {
+        Paint paint = getPaintByIndex(i);
+        paint.setColor(getCurrentHintTextColor());
+        drawTextAtBox(canvas, paint, getHint(), i);
+    }
+
+    private void drawTextAtBox(Canvas canvas, Paint paint, CharSequence text, int charAt) {
+        paint.getTextBounds(text.toString(), charAt, charAt + 1, mTextRect);
+        float cx = mItemCenterPoint.x;
+        float cy = mItemCenterPoint.y;
+        float x = cx - Math.abs((float) mTextRect.width()) / 2 - mTextRect.left;
+        float y = cy + Math.abs((float) mTextRect.height()) / 2 - mTextRect.bottom;// always center vertical
+        canvas.drawText(text, charAt, charAt + 1, x, y, paint);
+    }
+
+    private void drawCircle(Canvas canvas, int i) {
+        Paint paint = getPaintByIndex(i);
+        float cx = mItemCenterPoint.x;
+        float cy = mItemCenterPoint.y;
+        canvas.drawCircle(cx, cy, paint.getTextSize() / 2, paint);
+    }
+
+    private Paint getPaintByIndex(int i) {
+        if (isAnimationEnable && i == getText().length() - 1) {
+            mAnimatorTextPaint.setColor(getPaint().getColor());
+            return mAnimatorTextPaint;
+        } else {
+            return getPaint();
+        }
+    }
+
+    /**
+     * For seeing the font position
+     */
+    private void drawAnchorLine(Canvas canvas) {
+        float cx = mItemCenterPoint.x;
+        float cy = mItemCenterPoint.y;
+        mPaint.setStrokeWidth(1);
+        cx -= mPaint.getStrokeWidth() / 2;
+        cy -= mPaint.getStrokeWidth() / 2;
+
+        mPath.reset();
+        mPath.moveTo(cx, mItemBorderRect.top);
+        mPath.lineTo(cx, mItemBorderRect.top + Math.abs(mItemBorderRect.height()));
+        canvas.drawPath(mPath, mPaint);
+
+        mPath.reset();
+        mPath.moveTo(mItemBorderRect.left, cy);
+        mPath.lineTo(mItemBorderRect.left + Math.abs(mItemBorderRect.width()), cy);
+        canvas.drawPath(mPath, mPaint);
+
+        mPath.reset();
+
+        mPaint.setStrokeWidth(mLineWidth);
+    }
+
+    private void updateColors() {
+        boolean inval = false;
+
+        int color;
+        if (mLineColor != null) {
+            color = mLineColor.getColorForState(getDrawableState(), 0);
+        } else {
+            color = getCurrentTextColor();
+        }
+
+        if (color != mCurLineColor) {
+            mCurLineColor = color;
+            inval = true;
+        }
+
+        if (inval) {
+            invalidate();
+        }
+    }
+
+    private void updateCenterPoint() {
+        float cx = mItemBorderRect.left + Math.abs(mItemBorderRect.width()) / 2;
+        float cy = mItemBorderRect.top + Math.abs(mItemBorderRect.height()) / 2;
+        mItemCenterPoint.set(cx, cy);
+    }
+
+    private static boolean isPasswordInputType(int inputType) {
+        final int variation =
+                inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION);
+        return variation
+                == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)
+                || variation
+                == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_WEB_PASSWORD)
+                || variation
+                == (EditorInfo.TYPE_CLASS_NUMBER | EditorInfo.TYPE_NUMBER_VARIATION_PASSWORD);
+    }
+
+    @Override
+    protected MovementMethod getDefaultMovementMethod() {
+        // we don't need arrow key.
+        return DefaultMovementMethod.getInstance();
+    }
+
+    /**
+     * Sets the line color for all the states (normal, selected,
+     * focused) to be this color.
+     *
+     * @param color A color value in the form 0xAARRGGBB.
+     *              Do not pass a resource ID. To get a color value from a resource ID, call
+     *              {@link androidx.core.content.ContextCompat#getColor(Context, int) getColor}.
+     * @attr ref R.styleable#PinView_lineColor
+     * @see #setLineColor(ColorStateList)
+     * @see #getLineColors()
+     */
+    public void setLineColor(@ColorInt int color) {
+        mLineColor = ColorStateList.valueOf(color);
+        updateColors();
+    }
+
+    /**
+     * Sets the line color.
+     *
+     * @attr ref R.styleable#PinView_lineColor
+     * @see #setLineColor(int)
+     * @see #getLineColors()
+     */
+    public void setLineColor(ColorStateList colors) {
+        if (colors == null) {
+            throw new NullPointerException();
+        }
+
+        mLineColor = colors;
+        updateColors();
+    }
+
+    /**
+     * Gets the line colors for the different states (normal, selected, focused) of the PinView.
+     *
+     * @attr ref R.styleable#PinView_lineColor
+     * @see #setLineColor(ColorStateList)
+     * @see #setLineColor(int)
+     */
+    public ColorStateList getLineColors() {
+        return mLineColor;
+    }
+
+    /**
+     * <p>Return the current color selected for normal line.</p>
+     *
+     * @return Returns the current item's line color.
+     */
+    @ColorInt
+    public int getCurrentLineColor() {
+        return mCurLineColor;
+    }
+
+    /**
+     * Sets the line width.
+     *
+     * @attr ref R.styleable#PinView_lineWidth
+     * @see #getLineWidth()
+     */
+    public void setLineWidth(@Px int borderWidth) {
+        mLineWidth = borderWidth;
+        checkItemRadius();
+        requestLayout();
+    }
+
+    /**
+     * @return Returns the width of the item's line.
+     * @see #setLineWidth(int)
+     */
+    public int getLineWidth() {
+        return mLineWidth;
+    }
+
+    /**
+     * Sets the count of items.
+     *
+     * @attr ref R.styleable#PinView_itemCount
+     * @see #getItemCount()
+     */
+    public void setItemCount(int count) {
+        mPinItemCount = count;
+        setMaxLength(count);
+        requestLayout();
+    }
+
+    /**
+     * @return Returns the count of items.
+     * @see #setItemCount(int)
+     */
+    public int getItemCount() {
+        return mPinItemCount;
+    }
+
+    /**
+     * Sets the radius of square.
+     *
+     * @attr ref R.styleable#PinView_itemRadius
+     * @see #getItemRadius()
+     */
+    public void setItemRadius(@Px int itemRadius) {
+        mPinItemRadius = itemRadius;
+        checkItemRadius();
+        requestLayout();
+    }
+
+    /**
+     * @return Returns the radius of square.
+     * @see #setItemRadius(int)
+     */
+    public int getItemRadius() {
+        return mPinItemRadius;
+    }
+
+    /**
+     * Specifies extra space between two items.
+     *
+     * @attr ref R.styleable#PinView_itemSpacing
+     * @see #getItemSpacing()
+     */
+    public void setItemSpacing(@Px int itemSpacing) {
+        mPinItemSpacing = itemSpacing;
+        requestLayout();
+    }
+
+    /**
+     * @return Returns the spacing between two items.
+     * @see #setItemSpacing(int)
+     */
+    @Px
+    public int getItemSpacing() {
+        return mPinItemSpacing;
+    }
+
+    /**
+     * Sets the height of item.
+     *
+     * @attr ref R.styleable#PinView_itemHeight
+     * @see #getItemHeight()
+     */
+    public void setItemHeight(@Px int itemHeight) {
+        mPinItemHeight = itemHeight;
+        updateCursorHeight();
+        requestLayout();
+    }
+
+    /**
+     * @return Returns the height of item.
+     * @see #setItemHeight(int)
+     */
+    public int getItemHeight() {
+        return mPinItemHeight;
+    }
+
+    /**
+     * Sets the width of item.
+     *
+     * @attr ref R.styleable#PinView_itemWidth
+     * @see #getItemWidth()
+     */
+    public void setItemWidth(@Px int itemWidth) {
+        mPinItemWidth = itemWidth;
+        checkItemRadius();
+        requestLayout();
+    }
+
+    /**
+     * @return Returns the width of item.
+     * @see #setItemWidth(int)
+     */
+    public int getItemWidth() {
+        return mPinItemWidth;
+    }
+
+    /**
+     * Specifies whether the text animation should be enabled or disabled.
+     * By the default, the animation is disabled.
+     *
+     * @param enable True to start animation when adding text, false to transition immediately
+     */
+    public void setAnimationEnable(boolean enable) {
+        isAnimationEnable = enable;
+    }
+
+    /**
+     * Specifies whether the line (border) should be hidden or visible when text entered.
+     * By the default, this flag is false and the line is always drawn.
+     *
+     * @param hideLineWhenFilled true to hide line on a position where text entered,
+     *                           false to always show line
+     * @attr ref R.styleable#PinView_hideLineWhenFilled
+     */
+    public void setHideLineWhenFilled(boolean hideLineWhenFilled) {
+        this.mHideLineWhenFilled = hideLineWhenFilled;
+    }
+
+    @Override
+    public void setTextSize(float size) {
+        super.setTextSize(size);
+        updateCursorHeight();
+    }
+
+    @Override
+    public void setTextSize(int unit, float size) {
+        super.setTextSize(unit, size);
+        updateCursorHeight();
+    }
+
+    //region ItemBackground
+    /**
+     * Set the item background to a given resource. The resource should refer to
+     * a Drawable object or 0 to remove the item background.
+     *
+     * @param resId The identifier of the resource.
+     * @attr ref R.styleable#PinView_android_itemBackground
+     */
+    public void setItemBackgroundResources(@DrawableRes int resId) {
+        if (resId != 0 && mItemBackgroundResource != resId) {
+            return;
+        }
+        mItemBackground = ResourcesCompat.getDrawable(getResources(), resId, getContext().getTheme());
+        setItemBackground(mItemBackground);
+        mItemBackgroundResource = resId;
+    }
+
+    /**
+     * Sets the item background color for this view.
+     *
+     * @param color the color of the item background
+     */
+    public void setItemBackgroundColor(@ColorInt int color) {
+        if (mItemBackground instanceof ColorDrawable) {
+            ((ColorDrawable) mItemBackground.mutate()).setColor(color);
+            mItemBackgroundResource = 0;
+        } else {
+            setItemBackground(new ColorDrawable(color));
+        }
+    }
+
+    /**
+     * Set the item background to a given Drawable, or remove the background.
+     *
+     * @param background The Drawable to use as the item background, or null to remove the
+     *                   item background
+     */
+    public void setItemBackground(Drawable background) {
+        mItemBackgroundResource = 0;
+        mItemBackground = background;
+        invalidate();
+    }
+    //endregion
+
+    //region Cursor
+
+    /**
+     * Sets the width (in pixels) of cursor.
+     *
+     * @attr ref R.styleable#PinView_cursorWidth
+     * @see #getCursorWidth()
+     */
+    public void setCursorWidth(@Px int width) {
+        mCursorWidth = width;
+        if (isCursorVisible()) {
+            invalidateCursor(true);
+        }
+    }
+
+    /**
+     * @return Returns the width (in pixels) of cursor.
+     * @see #setCursorWidth(int)
+     */
+    public int getCursorWidth() {
+        return mCursorWidth;
+    }
+
+    /**
+     * Sets the cursor color.
+     *
+     * @param color A color value in the form 0xAARRGGBB.
+     *              Do not pass a resource ID. To get a color value from a resource ID, call
+     *              {@link androidx.core.content.ContextCompat#getColor(Context, int) getColor}.
+     * @attr ref R.styleable#PinView_cursorColor
+     * @see #getCursorColor()
+     */
+    public void setCursorColor(@ColorInt int color) {
+        mCursorColor = color;
+        if (isCursorVisible()) {
+            invalidateCursor(true);
+        }
+    }
+
+    /**
+     * Gets the cursor color.
+     *
+     * @return Return current cursor color.
+     * @see #setCursorColor(int)
+     */
+    public int getCursorColor() {
+        return mCursorColor;
+    }
+
+    @Override
+    public void setCursorVisible(boolean visible) {
+        if (isCursorVisible != visible) {
+            isCursorVisible = visible;
+            invalidateCursor(isCursorVisible);
+            makeBlink();
+        }
+    }
+
+    @Override
+    public boolean isCursorVisible() {
+        return isCursorVisible;
+    }
+
+    @Override
+    public void onScreenStateChanged(int screenState) {
+        super.onScreenStateChanged(screenState);
+        switch (screenState) {
+            case View.SCREEN_STATE_ON:
+                resumeBlink();
+                break;
+            case View.SCREEN_STATE_OFF:
+                suspendBlink();
+                break;
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        resumeBlink();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        suspendBlink();
+    }
+
+    private boolean shouldBlink() {
+        return isCursorVisible() && isFocused();
+    }
+
+    private void makeBlink() {
+        if (shouldBlink()) {
+            if (mBlink == null) {
+                mBlink = new Blink();
+            }
+            removeCallbacks(mBlink);
+            drawCursor = false;
+            postDelayed(mBlink, BLINK);
+        } else {
+            if (mBlink != null) {
+                removeCallbacks(mBlink);
+            }
+        }
+    }
+
+    private void suspendBlink() {
+        if (mBlink != null) {
+            mBlink.cancel();
+            invalidateCursor(false);
+        }
+    }
+
+    private void resumeBlink() {
+        if (mBlink != null) {
+            mBlink.uncancel();
+            makeBlink();
+        }
+    }
+
+    private void invalidateCursor(boolean showCursor) {
+        if (drawCursor != showCursor) {
+            drawCursor = showCursor;
+            invalidate();
+        }
+    }
+
+    private void updateCursorHeight() {
+        int delta = 2 * dpToPx(2);
+        mCursorHeight = mPinItemHeight - getTextSize() > delta ? getTextSize() + delta : getTextSize();
+    }
+
+    private class Blink implements Runnable {
+        private boolean mCancelled;
+
+        @Override
+        public void run() {
+            if (mCancelled) {
+                return;
+            }
+
+            removeCallbacks(this);
+
+            if (shouldBlink()) {
+                invalidateCursor(!drawCursor);
+                postDelayed(this, BLINK);
+            }
+        }
+
+        private void cancel() {
+            if (!mCancelled) {
+                removeCallbacks(this);
+                mCancelled = true;
+            }
+        }
+
+        void uncancel() {
+            mCancelled = false;
+        }
+    }
+    //endregion
+
+    //region Selection Menu
+    private void disableSelectionMenu() {
+        setCustomSelectionActionModeCallback(new DefaultActionModeCallback());
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            setCustomInsertionActionModeCallback(new DefaultActionModeCallback() {
+                @Override
+                public boolean onCreateActionMode(ActionMode mode, Menu menu) {
+                    menu.removeItem(android.R.id.autofill);
+                    return true;
+                }
+            });
+        }
+    }
+
+    @Override
+    public boolean isSuggestionsEnabled() {
+        return false;
+    }
+    //endregion
+
+    private int dpToPx(float dp) {
+        return (int) (dp * getResources().getDisplayMetrics().density + 0.5f);
+    }
+
+    private static class DefaultActionModeCallback implements ActionMode.Callback {
+
+        @Override
+        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
+            return false;
+        }
+
+        @Override
+        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
+            return false;
+        }
+
+        @Override
+        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
+            return false;
+        }
+
+        @Override
+        public void onDestroyActionMode(ActionMode mode) {
+
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableWeightLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableWeightLayout.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableWeightLayout.java
new file mode 100644
--- /dev/null	(date 1726419765496)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableWeightLayout.java	(date 1726419765496)
@@ -0,0 +1,388 @@
+package com.github.aakira.expandablelayout;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.TimeInterpolator;
+import android.animation.ValueAnimator;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.os.Build;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.view.ViewTreeObserver;
+import android.view.animation.LinearInterpolator;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+
+import com.qboxus.binder.R;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+public class ExpandableWeightLayout extends RelativeLayout implements ExpandableLayout {
+
+    private int duration;
+    private TimeInterpolator interpolator = new LinearInterpolator();
+    private boolean defaultExpanded;
+
+    private ExpandableLayoutListener listener;
+    private ExpandableSavedState savedState;
+    private boolean isExpanded;
+    private float layoutWeight = 0.0f;
+    private boolean isArranged = false;
+    private boolean isCalculatedSize = false;
+    private boolean isAnimating = false;
+    private ViewTreeObserver.OnGlobalLayoutListener mGlobalLayoutListener;
+
+    public ExpandableWeightLayout(final Context context) {
+        this(context, null);
+    }
+
+    public ExpandableWeightLayout(final Context context, final AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ExpandableWeightLayout(final Context context, final AttributeSet attrs,
+                                  final int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init(context, attrs, defStyleAttr);
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public ExpandableWeightLayout(final Context context, final AttributeSet attrs,
+                                  final int defStyleAttr, final int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+        init(context, attrs, defStyleAttr);
+    }
+
+    private void init(final Context context, final AttributeSet attrs, final int defStyleAttr) {
+        final TypedArray a = context.obtainStyledAttributes(
+                attrs, R.styleable.expandableLayout, defStyleAttr, 0);
+        duration = a.getInteger(R.styleable.expandableLayout_ael_duration, DEFAULT_DURATION);
+        defaultExpanded = a.getBoolean(R.styleable.expandableLayout_ael_expanded, DEFAULT_EXPANDED);
+        final int interpolatorType = a.getInteger(R.styleable.expandableLayout_ael_interpolator,
+                Utils.LINEAR_INTERPOLATOR);
+        a.recycle();
+        interpolator = Utils.createInterpolator(interpolatorType);
+        isExpanded = defaultExpanded;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        // Check this layout using the attribute of weight
+        if (!(getLayoutParams() instanceof LinearLayout.LayoutParams)) {
+            throw new AssertionError("You must arrange in LinearLayout.");
+        }
+        if (0 >= getCurrentWeight()) throw new AssertionError("You must set a weight than 0.");
+
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        if (!isCalculatedSize) {
+            layoutWeight = getCurrentWeight();
+            isCalculatedSize = true;
+        }
+
+        if (isArranged) return;
+        setWeight(defaultExpanded ? layoutWeight : 0);
+        isArranged = true;
+
+        if (savedState == null) return;
+        setWeight(savedState.getWeight());
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        final Parcelable parcelable = super.onSaveInstanceState();
+
+        final ExpandableSavedState ss = new ExpandableSavedState(parcelable);
+        ss.setWeight(getCurrentWeight());
+        return ss;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(final Parcelable state) {
+        if (!(state instanceof ExpandableSavedState)) {
+            super.onRestoreInstanceState(state);
+            return;
+        }
+        final ExpandableSavedState ss = (ExpandableSavedState) state;
+        super.onRestoreInstanceState(ss.getSuperState());
+        savedState = ss;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setListener(@NonNull ExpandableLayoutListener listener) {
+        this.listener = listener;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle() {
+        toggle(duration, interpolator);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle(final long duration, @Nullable final TimeInterpolator interpolator) {
+        if (0 < getCurrentWeight()) {
+            collapse(duration, interpolator);
+        } else {
+            expand(duration, interpolator);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void expand() {
+        if (isAnimating) return;
+
+        createExpandAnimator(0, layoutWeight, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void expand(final long duration, @Nullable final TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0) {
+            isExpanded = true;
+            setWeight(layoutWeight);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentWeight(), layoutWeight, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void collapse() {
+        if (isAnimating) return;
+
+        createExpandAnimator(getCurrentWeight(), 0, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void collapse(final long duration, @Nullable final TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0) {
+            isExpanded = false;
+            setWeight(0);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentWeight(), 0, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setDuration(@NonNull final int duration) {
+        if (duration < 0) {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                    duration);
+        }
+        this.duration = duration;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setExpanded(boolean expanded) {
+        final float currentWeight = getCurrentWeight();
+        if ((expanded && (currentWeight == layoutWeight))
+                || (!expanded && currentWeight == 0)) return;
+
+        isExpanded = expanded;
+        setWeight(expanded ? layoutWeight : 0);
+        requestLayout();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isExpanded() {
+        return isExpanded;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setInterpolator(@NonNull final TimeInterpolator interpolator) {
+        this.interpolator = interpolator;
+    }
+
+    /**
+     * Sets weight of expandable layout.
+     *
+     * @param expandWeight expand to this weight by {@link #expand()}
+     */
+    public void setExpandWeight(final float expandWeight) {
+        layoutWeight = expandWeight;
+    }
+
+    /**
+     * Gets current weight of expandable layout.
+     *
+     * @return weight
+     */
+    public float getCurrentWeight() {
+        return ((LinearLayout.LayoutParams) getLayoutParams()).weight;
+    }
+
+    /**
+     * @param weight
+     *
+     * @see #move(float, long, TimeInterpolator)
+     */
+    public void move(float weight) {
+        move(weight, duration, interpolator);
+    }
+
+    /**
+     * Change to weight.
+     * Sets 0 to duration if you want to move immediately.
+     *
+     * @param weight
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    public void move(float weight, long duration, @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0L) {
+            isExpanded = weight > 0;
+            setWeight(weight);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentWeight(), weight, duration, interpolator).start();
+    }
+
+    /**
+     * Creates value animator.
+     * Expand the layout if @param.to is bigger than @param.from.
+     * Collapse the layout if @param.from is bigger than @param.to.
+     *
+     * @param from
+     * @param to
+     * @param duration
+     * @param interpolator TimeInterpolator
+     *
+     * @return
+     */
+    private ValueAnimator createExpandAnimator(final float from, final float to, final long duration,
+                                               @Nullable final TimeInterpolator interpolator) {
+        final ValueAnimator valueAnimator = ValueAnimator.ofFloat(from, to);
+        valueAnimator.setDuration(duration);
+        valueAnimator.setInterpolator(interpolator == null ? this.interpolator : interpolator);
+        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(final ValueAnimator animation) {
+                setWeight((float) animation.getAnimatedValue());
+                requestLayout();
+            }
+        });
+        valueAnimator.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+                isAnimating = true;
+
+                if (listener == null) return;
+
+                listener.onAnimationStart();
+                if (layoutWeight == to) {
+                    listener.onPreOpen();
+                    return;
+                }
+                if (0 == to) {
+                    listener.onPreClose();
+                }
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                isAnimating = false;
+                isExpanded = to > 0;
+
+                if (listener == null) return;
+
+                listener.onAnimationEnd();
+                if (to == layoutWeight) {
+                    listener.onOpened();
+                    return;
+                }
+                if (to == 0) {
+                    listener.onClosed();
+                }
+            }
+        });
+        return valueAnimator;
+    }
+
+    private void setWeight(final float weight) {
+        ((LinearLayout.LayoutParams) getLayoutParams()).weight = weight;
+    }
+
+    /**
+     * Notify listeners
+     */
+    private void notifyListeners() {
+        if (listener == null) return;
+
+        listener.onAnimationStart();
+        if (isExpanded) {
+            listener.onPreOpen();
+        } else {
+            listener.onPreClose();
+        }
+        mGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(mGlobalLayoutListener);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(mGlobalLayoutListener);
+                }
+
+                listener.onAnimationEnd();
+                if (isExpanded) {
+                    listener.onOpened();
+                } else {
+                    listener.onClosed();
+                }
+            }
+        };
+        getViewTreeObserver().addOnGlobalLayoutListener(mGlobalLayoutListener);
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableLinearLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLinearLayout.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLinearLayout.java
new file mode 100644
--- /dev/null	(date 1726419717951)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLinearLayout.java	(date 1726419717951)
@@ -0,0 +1,568 @@
+package com.github.aakira.expandablelayout;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.TimeInterpolator;
+import android.animation.ValueAnimator;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.os.Build;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.view.animation.LinearInterpolator;
+import android.widget.LinearLayout;
+
+import com.qboxus.binder.R;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+public class ExpandableLinearLayout extends LinearLayout implements ExpandableLayout {
+
+    private int duration;
+    private TimeInterpolator interpolator = new LinearInterpolator();
+    /**
+     * Default state of expanse
+     *
+     * @see #defaultChildIndex
+     * @see #defaultPosition
+     */
+    private boolean defaultExpanded;
+    /**
+     * You cannot define {@link #defaultExpanded}, {@link #defaultChildIndex}
+     * and {@link #defaultPosition} at the same time.
+     * {@link #defaultPosition} has priority over {@link #defaultExpanded}
+     * and {@link #defaultChildIndex} if you set them at the same time.
+     * <p/>
+     * <p/>
+     * Priority
+     * {@link #defaultPosition} > {@link #defaultChildIndex} > {@link #defaultExpanded}
+     */
+    private int defaultChildIndex;
+    private int defaultPosition;
+    /**
+     * The close position is width from left of layout if orientation is horizontal.
+     * The close position is height from top of layout if orientation is vertical.
+     */
+    private int closePosition = 0;
+
+    private ExpandableLayoutListener listener;
+    private ExpandableSavedState savedState;
+    private boolean isExpanded;
+    private int layoutSize = 0;
+    private boolean inRecyclerView = false;
+    private boolean isArranged = false;
+    private boolean isCalculatedSize = false;
+    private boolean isAnimating = false;
+    /**
+     * State of expanse in recycler view.
+     */
+    private boolean recyclerExpanded = false;
+    /**
+     * view size of children
+     **/
+    private List<Integer> childSizeList = new ArrayList<>();
+    private ViewTreeObserver.OnGlobalLayoutListener mGlobalLayoutListener;
+
+    public ExpandableLinearLayout(final Context context) {
+        this(context, null);
+    }
+
+    public ExpandableLinearLayout(final Context context, final AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ExpandableLinearLayout(final Context context, final AttributeSet attrs,
+                                  final int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init(context, attrs, defStyleAttr);
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public ExpandableLinearLayout(final Context context, final AttributeSet attrs,
+                                  final int defStyleAttr, final int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+        init(context, attrs, defStyleAttr);
+    }
+
+    private void init(final Context context, final AttributeSet attrs, final int defStyleAttr) {
+        final TypedArray a = context.obtainStyledAttributes(
+                attrs, R.styleable.expandableLayout, defStyleAttr, 0);
+        duration = a.getInteger(R.styleable.expandableLayout_ael_duration, DEFAULT_DURATION);
+        defaultExpanded = a.getBoolean(R.styleable.expandableLayout_ael_expanded, DEFAULT_EXPANDED);
+        defaultChildIndex = a.getInteger(R.styleable.expandableLayout_ael_defaultChildIndex,
+                Integer.MAX_VALUE);
+        defaultPosition = a.getDimensionPixelSize(R.styleable.expandableLayout_ael_defaultPosition,
+                Integer.MIN_VALUE);
+        final int interpolatorType = a.getInteger(R.styleable.expandableLayout_ael_interpolator,
+                Utils.LINEAR_INTERPOLATOR);
+        a.recycle();
+        interpolator = Utils.createInterpolator(interpolatorType);
+        isExpanded = defaultExpanded;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        if (!isCalculatedSize) {
+            // calculate a size of children
+            childSizeList.clear();
+            final int childCount = getChildCount();
+
+            if (childCount > 0) {
+                int sumSize = 0;
+                View view;
+                LayoutParams params;
+                for (int i = 0; i < childCount; i++) {
+                    view = getChildAt(i);
+                    params = (LayoutParams) view.getLayoutParams();
+
+                    if (0 < i) {
+                        sumSize = childSizeList.get(i - 1);
+                    }
+                    childSizeList.add(
+                            (isVertical()
+                                    ? view.getMeasuredHeight() + params.topMargin + params.bottomMargin
+                                    : view.getMeasuredWidth() + params.leftMargin + params.rightMargin
+                            ) + sumSize);
+                }
+                layoutSize = childSizeList.get(childCount - 1) +
+                        (isVertical()
+                                ? getPaddingTop() + getPaddingBottom()
+                                : getPaddingLeft() + getPaddingRight()
+                        );
+                isCalculatedSize = true;
+            } else {
+                throw new IllegalStateException("The expandableLinearLayout must have at least one child");
+            }
+        }
+
+        if (isArranged) return;
+
+        // adjust default position if a user set a value.
+        if (!defaultExpanded) {
+            setLayoutSize(closePosition);
+        }
+        if (inRecyclerView) {
+            setLayoutSize(recyclerExpanded ? layoutSize : closePosition);
+        }
+        final int childNumbers = childSizeList.size();
+        if (childNumbers > defaultChildIndex && childNumbers > 0) {
+            moveChild(defaultChildIndex, 0, null);
+        }
+        if (defaultPosition > 0 && layoutSize >= defaultPosition && layoutSize > 0) {
+            move(defaultPosition, 0, null);
+        }
+        isArranged = true;
+
+        if (savedState == null) return;
+        setLayoutSize(savedState.getSize());
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        final Parcelable parcelable = super.onSaveInstanceState();
+        final ExpandableSavedState ss = new ExpandableSavedState(parcelable);
+        ss.setSize(getCurrentPosition());
+        return ss;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(final Parcelable state) {
+        if (!(state instanceof ExpandableSavedState)) {
+            super.onRestoreInstanceState(state);
+            return;
+        }
+
+        final ExpandableSavedState ss = (ExpandableSavedState) state;
+        super.onRestoreInstanceState(ss.getSuperState());
+        savedState = ss;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setListener(@NonNull ExpandableLayoutListener listener) {
+        this.listener = listener;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle() {
+        toggle(duration, interpolator);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle(final long duration, final @Nullable TimeInterpolator interpolator) {
+        if (closePosition < getCurrentPosition()) {
+            collapse(duration, interpolator);
+        } else {
+            expand(duration, interpolator);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void expand() {
+        if (isAnimating) return;
+
+        createExpandAnimator(getCurrentPosition(), layoutSize, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void expand(final long duration, final @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0) {
+            move(layoutSize, duration, interpolator);
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), layoutSize, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void collapse() {
+        if (isAnimating) return;
+
+        createExpandAnimator(getCurrentPosition(), closePosition, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void collapse(final long duration, final @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0) {
+            move(closePosition, duration, interpolator);
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), closePosition, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setDuration(final int duration) {
+        if (duration < 0) {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                    duration);
+        }
+        this.duration = duration;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setExpanded(final boolean expanded) {
+        if (inRecyclerView) recyclerExpanded = expanded;
+
+        final int currentPosition = getCurrentPosition();
+        if ((expanded && (currentPosition == layoutSize))
+                || (!expanded && currentPosition == closePosition)) return;
+
+        isExpanded = expanded;
+        setLayoutSize(expanded ? layoutSize : closePosition);
+        requestLayout();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isExpanded() {
+        return isExpanded;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setInterpolator(@NonNull final TimeInterpolator interpolator) {
+        this.interpolator = interpolator;
+    }
+
+    /**
+     * Initializes this layout.
+     */
+    public void initLayout() {
+        closePosition = 0;
+        layoutSize = 0;
+        isArranged = false;
+        isCalculatedSize = false;
+        savedState = null;
+
+        if (isVertical()) {
+            measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.EXACTLY),
+                    MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.UNSPECIFIED));
+        } else {
+            measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.UNSPECIFIED),
+                    MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.EXACTLY));
+        }
+    }
+
+    /**
+     * @param position
+     *
+     * @see #move(int, long, TimeInterpolator)
+     */
+    public void move(int position) {
+        move(position, duration, interpolator);
+    }
+
+    /**
+     * Moves to position.
+     * Sets 0 to duration if you want to move immediately.
+     *
+     * @param position
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    public void move(int position, long duration, @Nullable TimeInterpolator interpolator) {
+        if (isAnimating || 0 > position || layoutSize < position) return;
+
+        if (duration <= 0) {
+            isExpanded = position > closePosition;
+            setLayoutSize(position);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), position, duration,
+                interpolator == null ? this.interpolator : interpolator).start();
+    }
+
+    /**
+     * @param index child view index
+     *
+     * @see #moveChild(int, long, TimeInterpolator)
+     */
+    public void moveChild(int index) {
+        moveChild(index, duration, interpolator);
+    }
+
+    /**
+     * Moves to bottom(VERTICAL) or right(HORIZONTAL) of child view
+     * Sets 0 to duration if you want to move immediately.
+     *
+     * @param index        index child view index
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    public void moveChild(int index, long duration, @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        final int destination = getChildPosition(index) +
+                (isVertical() ? getPaddingBottom() : getPaddingRight());
+        if (duration <= 0) {
+            isExpanded = destination > closePosition;
+            setLayoutSize(destination);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), destination,
+                duration, interpolator == null ? this.interpolator : interpolator).start();
+    }
+
+    /**
+     * Gets the width from left of layout if orientation is horizontal.
+     * Gets the height from top of layout if orientation is vertical.
+     *
+     * @param index index of child view
+     *
+     * @return position from top or left
+     */
+    public int getChildPosition(final int index) {
+        if (0 > index || childSizeList.size() <= index) {
+            throw new IllegalArgumentException("There aren't the view having this index.");
+        }
+        return childSizeList.get(index);
+    }
+
+    /**
+     * Gets the width from left of layout if orientation is horizontal.
+     * Gets the height from top of layout if orientation is vertical.
+     *
+     * @return
+     *
+     * @see #closePosition
+     */
+    public int getClosePosition() {
+        return closePosition;
+    }
+
+    /**
+     * Sets the close position directly.
+     *
+     * @param position
+     *
+     * @see #closePosition
+     * @see #setClosePositionIndex(int)
+     */
+    public void setClosePosition(final int position) {
+        this.closePosition = position;
+    }
+
+    /**
+     * Gets the current position.
+     *
+     * @return
+     */
+    public int getCurrentPosition() {
+        return isVertical() ? getMeasuredHeight() : getMeasuredWidth();
+    }
+
+    /**
+     * Sets close position using index of child view.
+     *
+     * @param childIndex
+     *
+     * @see #closePosition
+     * @see #setClosePosition(int)
+     */
+    public void setClosePositionIndex(final int childIndex) {
+        this.closePosition = getChildPosition(childIndex);
+    }
+
+    /**
+     * Set true if expandable layout is used in recycler view.
+     *
+     * @param inRecyclerView
+     */
+    public void setInRecyclerView(final boolean inRecyclerView) {
+        this.inRecyclerView = inRecyclerView;
+    }
+
+    private boolean isVertical() {
+        return getOrientation() == LinearLayout.VERTICAL;
+    }
+
+    private void setLayoutSize(int size) {
+        if (isVertical()) {
+            getLayoutParams().height = size;
+        } else {
+            getLayoutParams().width = size;
+        }
+    }
+
+    /**
+     * Creates value animator.
+     * Expand the layout if {@param to} is bigger than {@param from}.
+     * Collapse the layout if {@param from} is bigger than {@param to}.
+     *
+     * @param from
+     * @param to
+     * @param duration
+     * @param interpolator
+     *
+     * @return
+     */
+    private ValueAnimator createExpandAnimator(
+            final int from, final int to, final long duration, final TimeInterpolator interpolator) {
+        final ValueAnimator valueAnimator = ValueAnimator.ofInt(from, to);
+        valueAnimator.setDuration(duration);
+        valueAnimator.setInterpolator(interpolator);
+        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(final ValueAnimator animator) {
+                if (isVertical()) {
+                    getLayoutParams().height = (int) animator.getAnimatedValue();
+                } else {
+                    getLayoutParams().width = (int) animator.getAnimatedValue();
+                }
+                requestLayout();
+            }
+        });
+        valueAnimator.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animator) {
+                isAnimating = true;
+                if (listener == null) return;
+
+                listener.onAnimationStart();
+                if (layoutSize == to) {
+                    listener.onPreOpen();
+                    return;
+                }
+                if (closePosition == to) {
+                    listener.onPreClose();
+                }
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animator) {
+                isAnimating = false;
+                isExpanded = to > closePosition;
+
+                if (listener == null) return;
+
+                listener.onAnimationEnd();
+                if (to == layoutSize) {
+                    listener.onOpened();
+                    return;
+                }
+                if (to == closePosition) {
+                    listener.onClosed();
+                }
+            }
+        });
+        return valueAnimator;
+    }
+
+    /**
+     * Notify listeners
+     */
+    private void notifyListeners() {
+        if (listener == null) return;
+
+        listener.onAnimationStart();
+        if (isExpanded) {
+            listener.onPreOpen();
+        } else {
+            listener.onPreClose();
+        }
+        mGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(mGlobalLayoutListener);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(mGlobalLayoutListener);
+                }
+
+                listener.onAnimationEnd();
+                if (isExpanded) {
+                    listener.onOpened();
+                } else {
+                    listener.onClosed();
+                }
+            }
+        };
+        getViewTreeObserver().addOnGlobalLayoutListener(mGlobalLayoutListener);
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableRelativeLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableRelativeLayout.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableRelativeLayout.java
new file mode 100644
--- /dev/null	(date 1726419717965)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableRelativeLayout.java	(date 1726419717965)
@@ -0,0 +1,556 @@
+package com.github.aakira.expandablelayout;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.TimeInterpolator;
+import android.animation.ValueAnimator;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.os.Build;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.view.animation.LinearInterpolator;
+import android.widget.RelativeLayout;
+
+import com.qboxus.binder.R;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+public class ExpandableRelativeLayout extends RelativeLayout implements ExpandableLayout {
+
+    private int duration;
+    private TimeInterpolator interpolator = new LinearInterpolator();
+    private int orientation;
+    /**
+     * Default state of expanse
+     *
+     * @see #defaultChildIndex
+     * @see #defaultPosition
+     */
+    private boolean defaultExpanded;
+    /**
+     * You cannot define {@link #defaultExpanded}, {@link #defaultChildIndex}
+     * and {@link #defaultPosition} at the same time.
+     * {@link #defaultPosition} has priority over {@link #defaultExpanded}
+     * and {@link #defaultChildIndex} if you set them at the same time.
+     * <p>
+     * <p>
+     * Priority
+     * {@link #defaultPosition} > {@link #defaultChildIndex} > {@link #defaultExpanded}
+     */
+    private int defaultChildIndex;
+    private int defaultPosition;
+    /**
+     * The close position is width from left of layout if orientation is horizontal.
+     * The close position is height from top of layout if orientation is vertical.
+     */
+    private int closePosition = 0;
+
+    private ExpandableLayoutListener listener;
+    private ExpandableSavedState savedState;
+    private boolean isExpanded;
+    private int layoutSize = 0;
+    private boolean isArranged = false;
+    private boolean isCalculatedSize = false;
+    private boolean isAnimating = false;
+    /**
+     * view size of children
+     **/
+    private List<Integer> childSizeList = new ArrayList<>();
+    /**
+     * view position top or left of children
+     **/
+    private List<Integer> childPositionList = new ArrayList<>();
+    private ViewTreeObserver.OnGlobalLayoutListener mGlobalLayoutListener;
+
+    public ExpandableRelativeLayout(final Context context) {
+        this(context, null);
+    }
+
+    public ExpandableRelativeLayout(final Context context, final AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ExpandableRelativeLayout(final Context context, final AttributeSet attrs,
+                                    final int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init(context, attrs, defStyleAttr);
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public ExpandableRelativeLayout(final Context context, final AttributeSet attrs,
+                                    final int defStyleAttr, final int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+        init(context, attrs, defStyleAttr);
+    }
+
+    private void init(final Context context, final AttributeSet attrs, final int defStyleAttr) {
+        final TypedArray a = context.obtainStyledAttributes(
+                attrs, R.styleable.expandableLayout, defStyleAttr, 0);
+        duration = a.getInteger(R.styleable.expandableLayout_ael_duration, DEFAULT_DURATION);
+        defaultExpanded = a.getBoolean(R.styleable.expandableLayout_ael_expanded, DEFAULT_EXPANDED);
+        orientation = a.getInteger(R.styleable.expandableLayout_ael_orientation, VERTICAL);
+        defaultChildIndex = a.getInteger(R.styleable.expandableLayout_ael_defaultChildIndex,
+                Integer.MAX_VALUE);
+        defaultPosition = a.getDimensionPixelSize(R.styleable.expandableLayout_ael_defaultPosition,
+                Integer.MIN_VALUE);
+        final int interpolatorType = a.getInteger(R.styleable.expandableLayout_ael_interpolator,
+                Utils.LINEAR_INTERPOLATOR);
+        a.recycle();
+        interpolator = Utils.createInterpolator(interpolatorType);
+        isExpanded = defaultExpanded;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        if (isCalculatedSize) return;
+
+        final int measureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+        if (isVertical()) {
+            int measuredHeight = getMeasuredHeight();
+
+            super.onMeasure(widthMeasureSpec, measureSpec);
+            layoutSize = getMeasuredHeight();
+
+            setMeasuredDimension(getMeasuredWidth(), measuredHeight);
+        } else {
+            int measuredWidth = getMeasuredWidth();
+
+            super.onMeasure(measureSpec, heightMeasureSpec);
+            layoutSize = getMeasuredWidth();
+
+            setMeasuredDimension(measuredWidth, getMeasuredHeight());
+        }
+
+        // calculate a size of children
+        childSizeList.clear();
+        View view;
+        LayoutParams params;
+        for (int i = 0; i < getChildCount(); i++) {
+            view = getChildAt(i);
+            params = (LayoutParams) view.getLayoutParams();
+
+            childSizeList.add(isVertical()
+                    ? view.getMeasuredHeight() + params.topMargin + params.bottomMargin
+                    : view.getMeasuredWidth() + params.leftMargin + params.rightMargin);
+        }
+        isCalculatedSize = true;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        super.onLayout(changed, l, t, r, b);
+
+        if (isArranged) return;
+
+        childPositionList.clear();
+        // calculate a top position of children
+        for (int i = 0; i < getChildCount(); i++) {
+            childPositionList.add((int) (isVertical() ? getChildAt(i).getY() : getChildAt(i).getX()));
+        }
+
+        // adjust default position if a user set a value.
+        if (!defaultExpanded) {
+            setLayoutSize(closePosition);
+        }
+        final int childNumbers = childSizeList.size();
+        if (childNumbers > defaultChildIndex && childNumbers > 0) {
+            moveChild(defaultChildIndex, 0, null);
+        }
+        if (defaultPosition > 0 && layoutSize >= defaultPosition && layoutSize > 0) {
+            move(defaultPosition, 0, null);
+        }
+        isArranged = true;
+
+        if (savedState == null) return;
+        setLayoutSize(savedState.getSize());
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        final Parcelable parcelable = super.onSaveInstanceState();
+        final ExpandableSavedState ss = new ExpandableSavedState(parcelable);
+        ss.setSize(getCurrentPosition());
+        return ss;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(final Parcelable state) {
+        if (!(state instanceof ExpandableSavedState)) {
+            super.onRestoreInstanceState(state);
+            return;
+        }
+
+        final ExpandableSavedState ss = (ExpandableSavedState) state;
+        super.onRestoreInstanceState(ss.getSuperState());
+        savedState = ss;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setListener(@NonNull ExpandableLayoutListener listener) {
+        this.listener = listener;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle() {
+        toggle(duration, interpolator);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle(final long duration, final @Nullable TimeInterpolator interpolator) {
+        if (closePosition < getCurrentPosition()) {
+            collapse(duration, interpolator);
+        } else {
+            expand(duration, interpolator);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void expand() {
+        if (isAnimating) return;
+
+        createExpandAnimator(getCurrentPosition(), layoutSize, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void expand(final long duration, final @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0) {
+            move(layoutSize, duration, interpolator);
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), layoutSize, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void collapse() {
+        if (isAnimating) return;
+
+        createExpandAnimator(getCurrentPosition(), closePosition, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void collapse(final long duration, final @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        if (duration <= 0) {
+            move(closePosition, duration, interpolator);
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), closePosition, duration, interpolator).start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setDuration(final int duration) {
+        if (duration < 0) {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " +
+                    duration);
+        }
+        this.duration = duration;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setExpanded(boolean expanded) {
+        final int currentPosition = getCurrentPosition();
+        if ((expanded && (currentPosition == layoutSize))
+                || (!expanded && currentPosition == closePosition)) return;
+
+        isExpanded = expanded;
+        setLayoutSize(expanded ? layoutSize : closePosition);
+        requestLayout();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isExpanded() {
+        return isExpanded;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setInterpolator(@NonNull final TimeInterpolator interpolator) {
+        this.interpolator = interpolator;
+    }
+
+    /**
+     * @param position
+     *
+     * @see #move(int, long, TimeInterpolator)
+     */
+    public void move(int position) {
+        move(position, duration, interpolator);
+    }
+
+    /**
+     * Moves to position.
+     * Sets 0 to duration if you want to move immediately.
+     *
+     * @param position
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    public void move(int position, long duration, @Nullable TimeInterpolator interpolator) {
+        if (isAnimating || 0 > position || layoutSize < position) return;
+
+        if (duration <= 0) {
+            isExpanded = position > closePosition;
+            setLayoutSize(position);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), position, duration,
+                interpolator == null ? this.interpolator : interpolator).start();
+    }
+
+    /**
+     * @param index child view index
+     *
+     * @see #moveChild(int, long, TimeInterpolator)
+     */
+    public void moveChild(int index) {
+        moveChild(index, duration, interpolator);
+    }
+
+    /**
+     * Moves to bottom(VERTICAL) or right(HORIZONTAL) of child view
+     * Sets 0 to duration if you want to move immediately.
+     *
+     * @param index        index child view index
+     * @param duration
+     * @param interpolator use the default interpolator if the argument is null.
+     */
+    public void moveChild(int index, long duration, @Nullable TimeInterpolator interpolator) {
+        if (isAnimating) return;
+
+        final int destination = getChildPosition(index) +
+                (isVertical() ? getPaddingBottom() : getPaddingRight());
+        if (duration <= 0) {
+            isExpanded = destination > closePosition;
+            setLayoutSize(destination);
+            requestLayout();
+            notifyListeners();
+            return;
+        }
+        createExpandAnimator(getCurrentPosition(), destination,
+                duration, interpolator == null ? this.interpolator : interpolator).start();
+    }
+
+    /**
+     * Sets orientation of expanse animation.
+     *
+     * @param orientation Set 0 if orientation is horizontal, 1 if orientation is vertical
+     */
+    public void setOrientation(@Orientation final int orientation) {
+        this.orientation = orientation;
+    }
+
+    /**
+     * Gets the width from left of layout if orientation is horizontal.
+     * Gets the height from top of layout if orientation is vertical.
+     *
+     * @param index index of child view
+     *
+     * @return position from top or left
+     */
+    public int getChildPosition(final int index) {
+        if (0 > index || childSizeList.size() <= index) {
+            throw new IllegalArgumentException("There aren't the view having this index.");
+        }
+        return childPositionList.get(index) + childSizeList.get(index);
+    }
+
+    /**
+     * Gets the width from left of layout if orientation is horizontal.
+     * Gets the height from top of layout if orientation is vertical.
+     *
+     * @return
+     *
+     * @see #closePosition
+     */
+    public int getClosePosition() {
+        return closePosition;
+    }
+
+    /**
+     * Sets the close position directly.
+     *
+     * @param position
+     *
+     * @see #closePosition
+     * @see #setClosePositionIndex(int)
+     */
+    public void setClosePosition(final int position) {
+        this.closePosition = position;
+    }
+
+    /**
+     * Gets the current position.
+     *
+     * @return
+     */
+    public int getCurrentPosition() {
+        return isVertical() ? getMeasuredHeight() : getMeasuredWidth();
+    }
+
+    /**
+     * Sets close position using index of child view.
+     *
+     * @param childIndex
+     *
+     * @see #closePosition
+     * @see #setClosePosition(int)
+     */
+    public void setClosePositionIndex(final int childIndex) {
+        this.closePosition = getChildPosition(childIndex);
+    }
+
+    private boolean isVertical() {
+        return orientation == VERTICAL;
+    }
+
+    private void setLayoutSize(int size) {
+        if (isVertical()) {
+            getLayoutParams().height = size;
+        } else {
+            getLayoutParams().width = size;
+        }
+    }
+
+    /**
+     * Creates value animator.
+     * Expand the layout if {@param to} is bigger than {@param from}.
+     * Collapse the layout if {@param from} is bigger than {@param to}.
+     *
+     * @param from
+     * @param to
+     * @param duration
+     * @param interpolator
+     *
+     * @return
+     */
+    private ValueAnimator createExpandAnimator(
+            final int from, final int to, final long duration, final TimeInterpolator interpolator) {
+        final ValueAnimator valueAnimator = ValueAnimator.ofInt(from, to);
+        valueAnimator.setDuration(duration);
+        valueAnimator.setInterpolator(interpolator);
+        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(final ValueAnimator animator) {
+                if (isVertical()) {
+                    getLayoutParams().height = (int) animator.getAnimatedValue();
+                } else {
+                    getLayoutParams().width = (int) animator.getAnimatedValue();
+                }
+                requestLayout();
+            }
+        });
+        valueAnimator.addListener(new AnimatorListenerAdapter() {
+            @Override
+            public void onAnimationStart(Animator animator) {
+                isAnimating = true;
+                if (listener == null) return;
+
+                listener.onAnimationStart();
+                if (layoutSize == to) {
+                    listener.onPreOpen();
+                    return;
+                }
+                if (closePosition == to) {
+                    listener.onPreClose();
+                }
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animator) {
+                isAnimating = false;
+                isExpanded = to > closePosition;
+
+                if (listener == null) return;
+
+                listener.onAnimationEnd();
+                if (to == layoutSize) {
+                    listener.onOpened();
+                    return;
+                }
+                if (to == closePosition) {
+                    listener.onClosed();
+                }
+            }
+        });
+        return valueAnimator;
+    }
+
+    /**
+     * Notify listeners
+     */
+    private void notifyListeners() {
+        if (listener == null) return;
+
+        listener.onAnimationStart();
+        if (isExpanded) {
+            listener.onPreOpen();
+        } else {
+            listener.onPreClose();
+        }
+        mGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(mGlobalLayoutListener);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(mGlobalLayoutListener);
+                }
+
+                listener.onAnimationEnd();
+                if (isExpanded) {
+                    listener.onOpened();
+                } else {
+                    listener.onClosed();
+                }
+            }
+        };
+        getViewTreeObserver().addOnGlobalLayoutListener(mGlobalLayoutListener);
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListener.java b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListener.java
new file mode 100644
--- /dev/null	(date 1473722736000)
+++ b/app/src/main/java/com/github/aakira/expandablelayout/ExpandableLayoutListener.java	(date 1473722736000)
@@ -0,0 +1,35 @@
+package com.github.aakira.expandablelayout;
+
+public interface ExpandableLayoutListener {
+    /**
+     * Notifies the start of the animation.
+     * Sync from android.animation.Animator.AnimatorListener.onAnimationStart(Animator animation)
+     */
+    void onAnimationStart();
+
+    /**
+     * Notifies the end of the animation.
+     * Sync from android.animation.Animator.AnimatorListener.onAnimationEnd(Animator animation)
+     */
+    void onAnimationEnd();
+
+    /**
+     * Notifies the layout is going to open.
+     */
+    void onPreOpen();
+
+    /**
+     * Notifies the layout is going to equal close size.
+     */
+    void onPreClose();
+
+    /**
+     * Notifies the layout opened.
+     */
+    void onOpened();
+
+    /**
+     * Notifies the layout size equal closed size.
+     */
+    void onClosed();
+}
\ No newline at end of file
Index: app/src/main/java/com/appyvet/materialrangebar/IRangeBarFormatter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/appyvet/materialrangebar/IRangeBarFormatter.java b/app/src/main/java/com/appyvet/materialrangebar/IRangeBarFormatter.java
new file mode 100644
--- /dev/null	(date 1586853518000)
+++ b/app/src/main/java/com/appyvet/materialrangebar/IRangeBarFormatter.java	(date 1586853518000)
@@ -0,0 +1,10 @@
+package com.appyvet.materialrangebar;
+
+/**
+ * Created by franciscomorais on 24/06/15.
+ */
+public interface IRangeBarFormatter {
+
+    String format(String value);
+
+}
Index: app/src/main/java/com/appyvet/materialrangebar/RangeBar.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/appyvet/materialrangebar/RangeBar.java b/app/src/main/java/com/appyvet/materialrangebar/RangeBar.java
new file mode 100644
--- /dev/null	(date 1726419013043)
+++ b/app/src/main/java/com/appyvet/materialrangebar/RangeBar.java	(date 1726419013043)
@@ -0,0 +1,2005 @@
+/*
+ * Copyright 2013, Edmodo, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in compliance with the License.
+ * You may obtain a copy of the License in the LICENSE file, or at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.appyvet.materialrangebar;
+/*
+ * Copyright 2015, Appyvet, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in compliance with the License.
+ * You may obtain a copy of the License in the LICENSE file, or at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+
+import com.qboxus.binder.R;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+/**
+ * The MaterialRangeBar is a single or double-sided version of a {@link android.widget.SeekBar}
+ * with discrete values. Whereas the thumb for the SeekBar can be dragged to any
+ * position in the bar, the RangeBar only allows its thumbs to be dragged to
+ * discrete positions (denoted by tick marks) in the bar. When released, a
+ * RangeBar thumb will snap to the nearest tick mark.
+ * This version is forked from edmodo range bar
+ * https://github.com/edmodo/range-bar.git
+ * Clients of the RangeBar can attach a
+ * {@link OnRangeBarChangeListener} to be notified when the pins
+ * have
+ * been moved.
+ */
+public class RangeBar extends View {
+
+    // Member Variables ////////////////////////////////////////////////////////
+
+    private static final String TAG = "RangeBar";
+
+    // Default values for variables
+    private static final float DEFAULT_TICK_START = 0;
+
+    private static final float DEFAULT_TICK_END = 5;
+
+    private static final float DEFAULT_TICK_INTERVAL = 1;
+
+    private static final float DEFAULT_MIN_DISTANCE = -1;
+
+    private static final float DEFAULT_TICK_HEIGHT_DP = 1;
+
+    private static final float DEFAULT_PIN_PADDING_DP = 16;
+
+    public static final float DEFAULT_MIN_PIN_FONT_SP = 8;
+
+    public static final float DEFAULT_MAX_PIN_FONT_SP = 24;
+
+    private static final float DEFAULT_BAR_WEIGHT_DP = 2;
+
+    private static final float DEFAULT_CIRCLE_BOUNDARY_SIZE_DP = 0;
+
+    private static final int DEFAULT_BAR_COLOR = Color.LTGRAY;
+
+    private static final int DEFAULT_TEXT_COLOR = Color.WHITE;
+
+    private static final int DEFAULT_TICK_COLOR = Color.BLACK;
+
+    private static final int DEFAULT_TICK_LABEL_COLOR = Color.LTGRAY;
+
+    private static final int DEFAULT_TICK_LABEL_SELECTED_COLOR = Color.BLACK;
+
+    private static final String DEFAULT_TICK_LABEL = "";
+
+    public static final float DEFAULT_TICK_LABEL_FONT_SP = 4;
+
+    // Corresponds to material indigo 500.
+    private static final int DEFAULT_PIN_COLOR = 0xff3f51b5;
+
+    private static final float DEFAULT_CONNECTING_LINE_WEIGHT_DP = 4;
+
+    // Corresponds to material indigo 500.
+    private static final int DEFAULT_CONNECTING_LINE_COLOR = 0xff3f51b5;
+
+    private static final float DEFAULT_EXPANDED_PIN_RADIUS_DP = 12;
+
+    private static final float DEFAULT_CIRCLE_SIZE_DP = 5;
+
+    private static final float DEFAULT_BAR_PADDING_BOTTOM_DP = 24;
+
+    // Instance variables for all of the customizable attributes
+
+    private float mTickHeight = DEFAULT_TICK_HEIGHT_DP;
+
+    private float mTickStart = DEFAULT_TICK_START;
+
+    private float mTickEnd = DEFAULT_TICK_END;
+
+    private float mTickInterval = DEFAULT_TICK_INTERVAL;
+
+    private int mMinIndexDistance = 0;
+
+    private float mDesiredMinDistance = -1f;
+
+    private float mBarWeight = DEFAULT_BAR_WEIGHT_DP;
+
+    private boolean mIsBarRounded = false;
+
+    private int mBarColor = DEFAULT_BAR_COLOR;
+
+    private int mPinColor = DEFAULT_PIN_COLOR;
+
+    private int mTextColor = DEFAULT_TEXT_COLOR;
+
+    private float mConnectingLineWeight = DEFAULT_CONNECTING_LINE_WEIGHT_DP;
+
+    private ArrayList<Integer> mConnectingLineColors = new ArrayList<>();
+
+    private float mThumbRadiusDP = DEFAULT_EXPANDED_PIN_RADIUS_DP;
+
+    private int mTickDefaultColor = DEFAULT_TICK_COLOR;
+
+    private ArrayList<Integer> mTickColors = new ArrayList<>();
+
+    private int mTickLabelColor = DEFAULT_TICK_LABEL_COLOR;
+
+    private int mTickLabelSelectedColor = DEFAULT_TICK_LABEL_SELECTED_COLOR;
+
+    private int mActiveTickLabelColor;
+
+    private int mActiveTickLabelSelectedColor;
+
+    private float mTickLabelSize = DEFAULT_TICK_LABEL_FONT_SP;
+
+    private CharSequence[] mTickBottomLabels;
+
+    private CharSequence[] mTickTopLabels;
+
+    private String mTickDefaultLabel = DEFAULT_TICK_LABEL;
+
+    private float mExpandedPinRadius = DEFAULT_EXPANDED_PIN_RADIUS_DP;
+
+    private int mThumbColor = DEFAULT_CONNECTING_LINE_COLOR;
+
+    private int mThumbColorLeft;
+
+    private int mThumbColorRight;
+
+    private int mThumbBoundaryColor = DEFAULT_CONNECTING_LINE_COLOR;
+
+    private float mThumbBoundarySize = DEFAULT_CIRCLE_BOUNDARY_SIZE_DP;
+
+    private float mThumbSize = DEFAULT_CIRCLE_SIZE_DP;
+
+    private float mMinPinFont = DEFAULT_MIN_PIN_FONT_SP;
+
+    private float mMaxPinFont = DEFAULT_MAX_PIN_FONT_SP;
+
+    // setTickCount only resets indices before a thumb has been pressed or a
+    // setThumbIndices() is called, to correspond with intended usage
+    private boolean mFirstSetTickCount = true;
+
+    private final DisplayMetrics mDisplayMetrices = getResources().getDisplayMetrics();
+
+    private int mDefaultWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 250, mDisplayMetrices);
+
+    private int mDefaultHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 75, mDisplayMetrices);
+
+    private int mTickCount = (int) ((mTickEnd - mTickStart) / mTickInterval) + 1;
+
+    private PinView mLeftThumb;
+
+    private PinView mRightThumb;
+
+    private Bar mBar;
+
+    private ConnectingLine mConnectingLine;
+
+    private OnRangeBarChangeListener mListener;
+
+    private OnRangeBarTextListener mPinTextListener;
+
+    private HashMap<Float, String> mTickMap;
+
+    private int mLeftIndex;
+
+    private int mRightIndex;
+
+    private boolean mIsRangeBar = true;
+
+    private float mPinPadding = DEFAULT_PIN_PADDING_DP;
+
+    private float mBarPaddingBottom = DEFAULT_BAR_PADDING_BOTTOM_DP;
+
+    private int mActiveConnectingLineColor;
+
+    private ArrayList<Integer> mActiveConnectingLineColors = new ArrayList<>();
+
+    private int mActiveBarColor;
+
+    private int mActiveTickDefaultColor;
+
+    private ArrayList<Integer> mActiveTickColors = new ArrayList<>();
+
+    private int mActiveCircleColor;
+
+    private int mActiveCircleColorLeft;
+
+    private int mActiveCircleColorRight;
+
+    private int mActiveCircleBoundaryColor;
+
+    //Used for ignoring vertical moves
+    private int mDiffX;
+
+    private int mDiffY;
+
+    private float mLastX;
+
+    private float mLastY;
+
+    private IRangeBarFormatter mFormatter;
+
+    private boolean drawTicks = true;
+
+    private boolean mArePinsTemporary = true;
+
+    private boolean mOnlyOnDrag = false;
+
+    private boolean mDragging = false;
+
+    private boolean mIsInScrollingContainer = false;
+
+    private PinTextFormatter mPinTextFormatter = new PinTextFormatter() {
+        @Override
+        public String getText(String value) {
+            if (value.length() > 4) {
+                return value.substring(0, 4);
+            } else {
+                return value;
+            }
+        }
+    };
+    private float mLeftBoundX;
+    private float mRightBoundX;
+
+    // Constructors ////////////////////////////////////////////////////////////
+
+    public RangeBar(Context context) {
+        super(context);
+    }
+
+    public RangeBar(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        rangeBarInit(context, attrs);
+    }
+
+    public RangeBar(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        rangeBarInit(context, attrs);
+    }
+
+    // View Methods ////////////////////////////////////////////////////////////
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+
+        Bundle bundle = new Bundle();
+
+        bundle.putParcelable("instanceState", super.onSaveInstanceState());
+
+        bundle.putInt("TICK_COUNT", mTickCount);
+        bundle.putFloat("TICK_START", mTickStart);
+        bundle.putFloat("TICK_END", mTickEnd);
+        bundle.putFloat("TICK_INTERVAL", mTickInterval);
+        bundle.putInt("TICK_COLOR", mTickDefaultColor);
+        bundle.putIntegerArrayList("TICK_COLORS", mTickColors);
+        bundle.putInt("TICK_LABEL_COLOR", mTickLabelColor);
+        bundle.putInt("TICK_LABEL_SELECTED_COLOR", mTickLabelSelectedColor);
+        bundle.putCharSequenceArray("TICK_TOP_LABELS", mTickTopLabels);
+        bundle.putCharSequenceArray("TICK_BOTTOM_LABELS", mTickBottomLabels);
+        bundle.putString("TICK_DEFAULT_LABEL", mTickDefaultLabel);
+
+        bundle.putFloat("TICK_HEIGHT_DP", mTickHeight);
+        bundle.putFloat("BAR_WEIGHT", mBarWeight);
+        bundle.putBoolean("BAR_ROUNDED", mIsBarRounded);
+        bundle.putInt("BAR_COLOR", mBarColor);
+        bundle.putFloat("CONNECTING_LINE_WEIGHT", mConnectingLineWeight);
+        bundle.putIntegerArrayList("CONNECTING_LINE_COLOR", mConnectingLineColors);
+
+        bundle.putFloat("CIRCLE_SIZE", mThumbSize);
+        bundle.putInt("CIRCLE_COLOR", mThumbColor);
+        bundle.putInt("CIRCLE_COLOR_LEFT", mThumbColorLeft);
+        bundle.putInt("CIRCLE_COLOR_RIGHT", mThumbColorRight);
+        bundle.putInt("CIRCLE_BOUNDARY_COLOR", mThumbBoundaryColor);
+        bundle.putFloat("CIRCLE_BOUNDARY_WIDTH", mThumbBoundarySize);
+        bundle.putFloat("THUMB_RADIUS_DP", mThumbRadiusDP);
+        bundle.putFloat("EXPANDED_PIN_RADIUS_DP", mExpandedPinRadius);
+        bundle.putFloat("PIN_PADDING", mPinPadding);
+        bundle.putFloat("BAR_PADDING_BOTTOM", mBarPaddingBottom);
+        bundle.putBoolean("IS_RANGE_BAR", mIsRangeBar);
+        bundle.putBoolean("IS_ONLY_ON_DRAG", mOnlyOnDrag);
+        bundle.putBoolean("ARE_PINS_TEMPORARY", mArePinsTemporary);
+        bundle.putInt("LEFT_INDEX", mLeftIndex);
+        bundle.putInt("RIGHT_INDEX", mRightIndex);
+        bundle.putInt("MIN_INDEX_DISTANCE", mMinIndexDistance);
+
+        bundle.putBoolean("FIRST_SET_TICK_COUNT", mFirstSetTickCount);
+
+        bundle.putFloat("MIN_PIN_FONT", mMinPinFont);
+        bundle.putFloat("MAX_PIN_FONT", mMaxPinFont);
+
+        return bundle;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+
+        if (state instanceof Bundle) {
+
+            Bundle bundle = (Bundle) state;
+
+            mTickCount = bundle.getInt("TICK_COUNT");
+            mTickStart = bundle.getFloat("TICK_START");
+            mTickEnd = bundle.getFloat("TICK_END");
+            mTickInterval = bundle.getFloat("TICK_INTERVAL");
+            mTickDefaultColor = bundle.getInt("TICK_COLOR");
+            mTickColors = bundle.getIntegerArrayList("TICK_COLORS");
+            mTickLabelColor = bundle.getInt("TICK_LABEL_COLOR");
+            mTickLabelSelectedColor = bundle.getInt("TICK_LABEL_SELECTED_COLOR");
+            mTickTopLabels = bundle.getCharSequenceArray("TICK_TOP_LABELS");
+            mTickBottomLabels = bundle.getCharSequenceArray("TICK_BOTTOM_LABELS");
+            mTickDefaultLabel = bundle.getString("TICK_DEFAULT_LABEL");
+            mTickHeight = bundle.getFloat("TICK_HEIGHT_DP");
+            mBarWeight = bundle.getFloat("BAR_WEIGHT");
+            mIsBarRounded = bundle.getBoolean("BAR_ROUNDED", false);
+            mBarColor = bundle.getInt("BAR_COLOR");
+            mThumbSize = bundle.getFloat("CIRCLE_SIZE");
+            mThumbColor = bundle.getInt("CIRCLE_COLOR");
+            mThumbColorLeft = bundle.getInt("CIRCLE_COLOR_LEFT");
+            mThumbColorRight = bundle.getInt("CIRCLE_COLOR_RIGHT");
+            mThumbBoundaryColor = bundle.getInt("CIRCLE_BOUNDARY_COLOR");
+            mThumbBoundarySize = bundle.getFloat("CIRCLE_BOUNDARY_WIDTH");
+            mConnectingLineWeight = bundle.getFloat("CONNECTING_LINE_WEIGHT");
+            mConnectingLineColors = bundle.getIntegerArrayList("CONNECTING_LINE_COLOR");
+
+            mThumbRadiusDP = bundle.getFloat("THUMB_RADIUS_DP");
+            mExpandedPinRadius = bundle.getFloat("EXPANDED_PIN_RADIUS_DP");
+            mPinPadding = bundle.getFloat("PIN_PADDING");
+            mBarPaddingBottom = bundle.getFloat("BAR_PADDING_BOTTOM");
+            mIsRangeBar = bundle.getBoolean("IS_RANGE_BAR");
+            mOnlyOnDrag = bundle.getBoolean("IS_ONLY_ON_DRAG");
+            mArePinsTemporary = bundle.getBoolean("ARE_PINS_TEMPORARY");
+
+            mLeftIndex = bundle.getInt("LEFT_INDEX");
+            mRightIndex = bundle.getInt("RIGHT_INDEX");
+            mFirstSetTickCount = bundle.getBoolean("FIRST_SET_TICK_COUNT");
+            mMinIndexDistance = bundle.getInt("MIN_INDEX_DISTANCE");
+
+            mMinPinFont = bundle.getFloat("MIN_PIN_FONT");
+            mMaxPinFont = bundle.getFloat("MAX_PIN_FONT");
+
+            setRangePinsByIndices(mLeftIndex, mRightIndex);
+            super.onRestoreInstanceState(bundle.getParcelable("instanceState"));
+
+        } else {
+            super.onRestoreInstanceState(state);
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+        int width;
+        int height;
+
+        // Get measureSpec mode and size values.
+        final int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);
+        final int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);
+        final int measureWidth = MeasureSpec.getSize(widthMeasureSpec);
+        final int measureHeight = MeasureSpec.getSize(heightMeasureSpec);
+
+        // The RangeBar width should be as large as possible.
+        if (measureWidthMode == MeasureSpec.AT_MOST) {
+            width = measureWidth;
+        } else if (measureWidthMode == MeasureSpec.EXACTLY) {
+            width = measureWidth;
+        } else {
+            width = mDefaultWidth;
+        }
+
+        // The RangeBar height should be as small as possible.
+        if (measureHeightMode == MeasureSpec.AT_MOST) {
+            height = Math.min(mDefaultHeight, measureHeight);
+        } else if (measureHeightMode == MeasureSpec.EXACTLY) {
+            height = measureHeight;
+        } else {
+            height = mDefaultHeight;
+        }
+
+        setMeasuredDimension(width, height);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        final Context ctx = getContext();
+
+        // This is the initial point at which we know the size of the View.
+
+        // Create the two thumb objects and position line in view
+        float density = mDisplayMetrices.density;
+        float expandedPinRadius = mExpandedPinRadius / density;
+
+        final float yPos = h - mBarPaddingBottom;
+        if (mIsRangeBar) {
+            mLeftThumb = new PinView(ctx);
+            mLeftThumb.setFormatter(mFormatter);
+            mLeftThumb.init(ctx, yPos, expandedPinRadius, mPinColor, mTextColor, mThumbSize,
+                    mThumbColorLeft, mThumbBoundaryColor, mThumbBoundarySize, mMinPinFont, mMaxPinFont, mArePinsTemporary);
+        }
+        mRightThumb = new PinView(ctx);
+        mRightThumb.setFormatter(mFormatter);
+        mRightThumb.init(ctx, yPos, expandedPinRadius, mPinColor, mTextColor, mThumbSize,
+                mThumbColorRight, mThumbBoundaryColor, mThumbBoundarySize, mMinPinFont, mMaxPinFont, mArePinsTemporary);
+
+        // Create the underlying bar.
+        final float marginLeft = Math.max(mExpandedPinRadius, mThumbSize);
+
+        final float barLength = w - (2 * marginLeft);
+
+        mBar = new Bar(ctx, marginLeft, yPos, barLength, mTickCount, mTickHeight, mTickDefaultColor, mTickColors,
+                mBarWeight, mBarColor, mIsBarRounded, mTickLabelColor, mTickLabelSelectedColor,
+                mTickTopLabels, mTickBottomLabels, mTickDefaultLabel, mTickLabelSize);
+
+        // Initialize thumbs to the desired indices
+        if (mIsRangeBar) {
+            updateThumbBounds();
+            mLeftThumb.setX(marginLeft + (mLeftIndex / (float) (mTickCount - 1)) * barLength);
+            mLeftThumb.setXValue(getPinValue(mLeftIndex));
+        }
+        mRightThumb.setX(marginLeft + (mRightIndex / (float) (mTickCount - 1)) * barLength);
+        mRightThumb.setXValue(getPinValue(mRightIndex));
+
+        // Set the thumb indices.
+        final int newLeftIndex = mIsRangeBar ? mBar.getNearestTickIndex(mLeftThumb) : 0;
+        final int newRightIndex = mBar.getNearestTickIndex(mRightThumb);
+
+        // Call the listener.
+        if (newLeftIndex != mLeftIndex || newRightIndex != mRightIndex) {
+            if (mListener != null) {
+                mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                        getPinValue(mLeftIndex),
+                        getPinValue(mRightIndex));
+            }
+        }
+
+        // Create the line connecting the two thumbs.
+        mConnectingLine = new ConnectingLine(yPos, mConnectingLineWeight,
+                mConnectingLineColors);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        // Cache this value since it only changes if the ViewParent changes
+        mIsInScrollingContainer = isInScrollingContainer();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+
+        super.onDraw(canvas);
+
+        mBar.draw(canvas);
+        if (mIsRangeBar) {
+            mConnectingLine.draw(canvas, mLeftThumb, mRightThumb);
+            if (drawTicks) {
+                mBar.drawTicks(canvas, mExpandedPinRadius, mRightThumb, mLeftThumb);
+            }
+            mLeftThumb.draw(canvas);
+        } else {
+            mConnectingLine.draw(canvas, getMarginLeft(), mRightThumb);
+            if (drawTicks) {
+                mBar.drawTicks(canvas, mExpandedPinRadius, mRightThumb);
+            }
+        }
+        mRightThumb.draw(canvas);
+
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+
+        // If this View is not enabled, don't allow for touch interactions.
+        if (!isEnabled()) {
+            return false;
+        }
+
+        updateThumbBounds();
+
+        switch (event.getAction()) {
+
+            case MotionEvent.ACTION_DOWN:
+                mDiffX = 0;
+                mDiffY = 0;
+                mLastX = event.getX();
+                mLastY = event.getY();
+                // We don't want to change to tick value yet if we're inside a scrolling container.
+                // In this case, the user may be trying to scroll the parent.
+                if (!mIsInScrollingContainer) {
+                    onActionDown(event.getX(), event.getY());
+                }
+                return true;
+
+            case MotionEvent.ACTION_UP:
+                // Just release the dragging if we were previously dragging
+                // or if it was a click (last touch event coordinates are the same)
+                if (mDragging || (event.getX() == mLastX && event.getY() == mLastY)) {
+                    this.getParent().requestDisallowInterceptTouchEvent(false);
+                    onActionUp(event.getX(), event.getY());
+                }
+                return true;
+
+            case MotionEvent.ACTION_CANCEL:
+                if (mDragging || (event.getX() == mLastX && event.getY() == mLastY)) {
+                    this.getParent().requestDisallowInterceptTouchEvent(false);
+                    onActionUp(event.getX(), event.getY());
+                }
+                return true;
+
+            case MotionEvent.ACTION_MOVE:
+                final float curX = event.getX();
+                final float curY = event.getY();
+                mDiffX += Math.abs(curX - mLastX);
+                mDiffY += Math.abs(curY - mLastY);
+                mLastX = curX;
+                mLastY = curY;
+
+                if (!mDragging) {
+                    if (mDiffX > mDiffY) {
+                        onActionDown(event.getX(), event.getY());
+                        return true;
+                    } else {
+                        return false;
+                    }
+                } else {
+                    onActionMove(event.getX());
+                    this.getParent().requestDisallowInterceptTouchEvent(true);
+                    if (mDiffX < mDiffY) {
+                        //vertical touch
+                        // Don't let scrolling parents get this touch event
+                        if (!mIsInScrollingContainer) {
+                            getParent().requestDisallowInterceptTouchEvent(false);
+                        }
+                        return false;
+                    } else {
+                        //horizontal touch (do nothing as it is needed for RangeBar)
+                    }
+                }
+                return true;
+
+            default:
+                return false;
+        }
+    }
+
+    // Public Methods //////////////////////////////////////////////////////////
+
+
+    /**
+     * Sets if the pins works only when drag it.
+     *
+     * @param onlyOnDrag boolean specifying if the onlyOnDrag is enabled
+     */
+    public void setOnlyOnDrag(boolean onlyOnDrag) {
+        mOnlyOnDrag = onlyOnDrag;
+    }
+
+    /**
+     * Sets a listener to receive notifications of changes to the RangeBar. This
+     * will overwrite any existing set listeners.
+     *
+     * @param listener the RangeBar notification listener; null to remove any
+     *                 existing listener
+     */
+    public void setOnRangeBarChangeListener(OnRangeBarChangeListener listener) {
+        mListener = listener;
+    }
+
+    /**
+     * Sets a listener to modify the text
+     *
+     * @param mPinTextListener the RangeBar pin text notification listener; null to remove any
+     *                         existing listener
+     */
+    public void setPinTextListener(OnRangeBarTextListener mPinTextListener) {
+        this.mPinTextListener = mPinTextListener;
+    }
+
+
+    public void setFormatter(IRangeBarFormatter formatter) {
+        if (mLeftThumb != null) {
+            mLeftThumb.setFormatter(formatter);
+        }
+
+        if (mRightThumb != null) {
+            mRightThumb.setFormatter(formatter);
+        }
+
+        mFormatter = formatter;
+    }
+
+    public void setDrawTicks(boolean drawTicks) {
+        this.drawTicks = drawTicks;
+    }
+
+    /**
+     * Sets the start tick in the RangeBar.
+     *
+     * @param tickStart Integer specifying the number of ticks.
+     */
+    public void setTickStart(float tickStart) {
+        int tickCount = (int) ((mTickEnd - tickStart) / mTickInterval) + 1;
+        if (isValidTickCount(tickCount)) {
+            mTickCount = tickCount;
+            mTickStart = tickStart;
+
+            // Prevents resetting the indices when creating new activity, but
+            // allows it on the first setting.
+            if (mFirstSetTickCount) {
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex),
+                            getPinValue(mRightIndex));
+                }
+            }
+            if (indexOutOfRange(mLeftIndex, mRightIndex)) {
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex),
+                            getPinValue(mRightIndex));
+                }
+            }
+
+            createBar();
+            createPins();
+        } else {
+            Log.e(TAG, "tickCount less than 2; invalid tickCount.");
+            throw new IllegalArgumentException("tickCount less than 2; invalid tickCount.");
+        }
+    }
+
+    /**
+     * Sets the start tick in the RangeBar.
+     *
+     * @param tickInterval Integer specifying the number of ticks.
+     */
+    public void setTickInterval(float tickInterval) {
+        int tickCount = (int) ((mTickEnd - mTickStart) / tickInterval) + 1;
+        if (isValidTickCount(tickCount)) {
+            mTickCount = tickCount;
+            mTickInterval = tickInterval;
+
+            // Prevents resetting the indices when creating new activity, but
+            // allows it on the first setting.
+            if (mFirstSetTickCount) {
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex), getPinValue(mRightIndex));
+                }
+            }
+            if (indexOutOfRange(mLeftIndex, mRightIndex)) {
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex), getPinValue(mRightIndex));
+                }
+            }
+
+            createBar();
+            createPins();
+        } else {
+            Log.e(TAG, "tickCount less than 2; invalid tickCount.");
+            throw new IllegalArgumentException("tickCount less than 2; invalid tickCount.");
+        }
+    }
+
+    /**
+     * Sets the end tick in the RangeBar.
+     *
+     * @param tickEnd Integer specifying the number of ticks.
+     */
+    public void setTickEnd(float tickEnd) {
+        int tickCount = (int) ((tickEnd - mTickStart) / mTickInterval) + 1;
+        if (isValidTickCount(tickCount)) {
+            mTickCount = tickCount;
+            mTickEnd = tickEnd;
+
+            // Prevents resetting the indices when creating new activity, but
+            // allows it on the first setting.
+            if (mFirstSetTickCount) {
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex), getPinValue(mRightIndex));
+                }
+            }
+            if (indexOutOfRange(mLeftIndex, mRightIndex)) {
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex), getPinValue(mRightIndex));
+                }
+            }
+
+            createBar();
+            createPins();
+        } else {
+            Log.e(TAG, "tickCount less than 2; invalid tickCount.");
+            throw new IllegalArgumentException("tickCount less than 2; invalid tickCount.");
+        }
+    }
+
+    /**
+     * Sets the height of the ticks in the range bar.
+     *
+     * @param tickHeight Float specifying the height of each tick mark in dp.
+     */
+    public void setTickHeight(float tickHeight) {
+
+        mTickHeight = tickHeight;
+        createBar();
+    }
+
+    /**
+     * Set the weight of the bar line and the tick lines in the range bar.
+     *
+     * @param barWeight Float specifying the weight of the bar and tick lines in
+     *                  DP.
+     */
+    public void setBarWeight(float barWeight) {
+
+        mBarWeight = barWeight;
+        createBar();
+    }
+
+    public boolean isBarRounded() {
+        return mIsBarRounded;
+    }
+
+    /**
+     * set the bar with rounded corners
+     *
+     * @param isBarRounded flag
+     */
+    public void setBarRounded(boolean isBarRounded) {
+        this.mIsBarRounded = isBarRounded;
+        createBar();
+    }
+
+    /**
+     * Set the color of the bar line and the tick lines in the range bar.
+     *
+     * @param barColor Integer specifying the color of the bar line.
+     */
+    public void setBarColor(int barColor) {
+        mBarColor = barColor;
+        createBar();
+    }
+
+    /**
+     * Set the color of the pins.
+     *
+     * @param pinColor Integer specifying the color of the pin.
+     */
+    public void setPinColor(int pinColor) {
+        mPinColor = pinColor;
+        createPins();
+    }
+
+    /**
+     * Set the color of the text within the pin.
+     *
+     * @param textColor Integer specifying the color of the text in the pin.
+     */
+    public void setPinTextColor(int textColor) {
+        mTextColor = textColor;
+        createPins();
+    }
+
+    /**
+     * Set if the view is a range bar or a seek bar.
+     *
+     * @param isRangeBar Boolean - true sets it to rangebar, false to seekbar.
+     */
+    public void setRangeBarEnabled(boolean isRangeBar) {
+        mIsRangeBar = isRangeBar;
+        invalidate();
+    }
+
+
+    /**
+     * Set if the pins should dissapear after released
+     *
+     * @param arePinsTemporary Boolean - true if pins shoudl dissapear after released, false to
+     *                         stay
+     *                         drawn
+     */
+    public void setTemporaryPins(boolean arePinsTemporary) {
+        mArePinsTemporary = arePinsTemporary;
+        invalidate();
+    }
+
+    /**
+     * Set the default color of the ticks.
+     *
+     * @param tickDefaultColor Integer specifying the color of the ticks.
+     */
+
+    public void setTickDefaultColor(int tickDefaultColor) {
+        this.mTickDefaultColor = tickDefaultColor;
+        setTickColors(tickDefaultColor);
+        createBar();
+    }
+
+    /**
+     * Set the colors of the ticks.
+     *
+     * @param tickColors List of Integers specifying the color of the ticks.
+     */
+    public void setTickColors(ArrayList<Integer> tickColors) {
+        this.mTickColors = new ArrayList<>(tickColors);
+        createBar();
+    }
+
+    /**
+     * Set the color of the ticks.
+     *
+     * @param color Integer specifying the color of the ticks.
+     */
+    public void setTickColors(int color) {
+        for (int i = 0; i < mTickColors.size(); i++) {
+            mTickColors.set(i, color);
+        }
+
+        createBar();
+    }
+
+    public void setTickLabelColor(int tickLabelColor) {
+        mTickLabelColor = tickLabelColor;
+        createBar();
+    }
+
+    public void setTickLabelSelectedColor(int tickLabelSelectedColor) {
+        mTickLabelSelectedColor = tickLabelSelectedColor;
+        createBar();
+    }
+
+    public void setTickTopLabels(CharSequence[] tickLabels) {
+        mTickTopLabels = tickLabels;
+        createBar();
+    }
+
+    public void setTickBottomLabels(CharSequence[] tickLabels) {
+        mTickBottomLabels = tickLabels;
+        createBar();
+    }
+
+    /**
+     * Set the color of the Thumb.
+     *
+     * @param thumbColor Integer specifying the color of the ticks.
+     */
+    public void setThumbColor(int thumbColor) {
+        mThumbColor = thumbColor;
+        setLeftThumbColor(thumbColor);
+        setRightThumbColor(thumbColor);
+        createPins();
+    }
+
+    /**
+     * Set the color of the Thumb Boundary.
+     *
+     * @param thumbBoundaryColor Integer specifying the boundary color of the ticks.
+     */
+    public void setThumbBoundaryColor(int thumbBoundaryColor) {
+        mThumbBoundaryColor = thumbBoundaryColor;
+        createPins();
+    }
+
+    /**
+     * Set the size of the Thumb Boundary.
+     *
+     * @param thumbBoundarySize Integer specifying the boundary size of ticks.
+     *                          Value should be in DP
+     */
+    public void setThumbBoundarySize(int thumbBoundarySize) {
+        mThumbBoundarySize = thumbBoundarySize;
+        createPins();
+    }
+
+
+    /**
+     * Set the size of the thumb.
+     *
+     * @param thumbSize Integer specifying the size of ticks.
+     *                  Value should be in DP
+     */
+    public void setThumbSize(int thumbSize) {
+        mThumbSize = thumbSize;
+        createPins();
+    }
+
+
+    /**
+     * Set the weight of the connecting line between the thumbs.
+     *
+     * @param connectingLineWeight Float specifying the weight of the connecting
+     *                             line. Value should be in DP
+     */
+    public void setConnectingLineWeight(float connectingLineWeight) {
+
+        mConnectingLineWeight = connectingLineWeight;
+        createConnectingLine();
+    }
+
+    /**
+     * Set the color of the connecting line between the thumbs.
+     *
+     * @param connectingLineColor Integer specifying the color of the connecting
+     *                            line.
+     */
+    public void setConnectingLineColor(int connectingLineColor) {
+
+        mConnectingLineColors.clear();
+        mConnectingLineColors.add(connectingLineColor);
+        createConnectingLine();
+    }
+
+    public void setConnectingLineColors(ArrayList<Integer> connectingLineColors) {
+        mConnectingLineColors = new ArrayList<>(connectingLineColors);
+        createConnectingLine();
+    }
+
+    /**
+     * If this is set, the thumb images will be replaced with a circle of the
+     * specified radius. Default width = 12dp.
+     *
+     * @param pinRadius Float specifying the radius of the thumbs to be drawn. Value should be in DP
+     */
+    public void setPinRadius(float pinRadius) {
+        mExpandedPinRadius = pinRadius;
+        createPins();
+    }
+
+    /**
+     * Sets left thumb circle color
+     *
+     * @param colorLeft
+     */
+    public void setLeftThumbColor(int colorLeft) {
+        this.mThumbColorLeft = colorLeft;
+        createPins();
+    }
+
+    /**
+     * Sets Right thumb circle color
+     *
+     * @param colorRight
+     */
+    public void setRightThumbColor(int colorRight) {
+        this.mThumbColorRight = colorRight;
+        createPins();
+    }
+
+    /**
+     * Gets left thumb color
+     *
+     * @return
+     */
+    public int getLeftThumbColor() {
+        return mThumbColorLeft;
+    }
+
+    /**
+     * Gets right thumb color
+     *
+     * @return
+     */
+    public int getRightThumbColor() {
+        return mThumbColorRight;
+    }
+
+    /**
+     * Gets the start tick.
+     *
+     * @return the start tick.
+     */
+    public float getTickStart() {
+        return mTickStart;
+    }
+
+    /**
+     * Gets the end tick.
+     *
+     * @return the end tick.
+     */
+    public float getTickEnd() {
+        return mTickEnd;
+    }
+
+    /**
+     * Gets the tick count.
+     *
+     * @return the tick count
+     */
+    public int getTickCount() {
+        return mTickCount;
+    }
+
+    /**
+     * Gets the tick top labels.
+     *
+     * @return the tick top labels
+     */
+    public CharSequence[] getTickTopLabels() {
+        return mTickTopLabels;
+    }
+
+    /**
+     * Gets the tick bottom labels.
+     *
+     * @return the tick bottom labels
+     */
+    public CharSequence[] getTickBottomLabels() {
+        return mTickBottomLabels;
+    }
+
+    /**
+     * Gets the tick colors.
+     *
+     * @return List of colors
+     */
+    public ArrayList<Integer> getTickColors() {
+
+        return mTickColors;
+    }
+
+
+    /**
+     * @param index
+     * @return specified color
+     */
+    public int getTickColor(int index) {
+
+        return mTickColors.get(index).intValue();
+    }
+
+    /**
+     * Sets the location of the pins according by the supplied index.
+     * Numbered from 0 to mTickCount - 1 from the left.
+     *
+     * @param leftPinIndex  Integer specifying the index of the left pin
+     * @param rightPinIndex Integer specifying the index of the right pin
+     */
+    public void setRangePinsByIndices(int leftPinIndex, int rightPinIndex) {
+        if (indexOutOfRange(leftPinIndex, rightPinIndex)) {
+            Log.e(TAG,
+                    "Pin index left " + leftPinIndex + ", or right " + rightPinIndex
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + mTickStart + ") and less than the maximum value ("
+                            + mTickEnd + ")");
+            throw new IllegalArgumentException(
+                    "Pin index left " + leftPinIndex + ", or right " + rightPinIndex
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + mTickStart + ") and less than the maximum value ("
+                            + mTickEnd + ")");
+        } else {
+
+            if (mFirstSetTickCount) {
+                mFirstSetTickCount = false;
+            }
+            mLeftIndex = leftPinIndex;
+            mRightIndex = rightPinIndex;
+            createPins();
+
+            if (mListener != null) {
+                mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                        getPinValue(mLeftIndex), getPinValue(mRightIndex));
+            }
+        }
+
+        invalidate();
+        requestLayout();
+    }
+
+    /**
+     * Sets the location of pin according by the supplied index.
+     * Numbered from 0 to mTickCount - 1 from the left.
+     *
+     * @param pinIndex Integer specifying the index of the seek pin
+     */
+    public void setSeekPinByIndex(int pinIndex) {
+        if (pinIndex < 0 || pinIndex > mTickCount) {
+            Log.e(TAG,
+                    "Pin index " + pinIndex
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + 0 + ") and less than the maximum value ("
+                            + mTickCount + ")");
+            throw new IllegalArgumentException(
+                    "Pin index " + pinIndex
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + 0 + ") and less than the maximum value ("
+                            + mTickCount + ")");
+
+        } else {
+
+            if (mFirstSetTickCount) {
+                mFirstSetTickCount = false;
+            }
+            mRightIndex = pinIndex;
+            createPins();
+
+            if (mListener != null) {
+                mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                        getPinValue(mLeftIndex), getPinValue(mRightIndex));
+            }
+        }
+        invalidate();
+        requestLayout();
+    }
+
+    /**
+     * Sets the location of pins according by the supplied values.
+     *
+     * @param leftPinValue  Float specifying the index of the left pin
+     * @param rightPinValue Float specifying the index of the right pin
+     */
+    public void setRangePinsByValue(float leftPinValue, float rightPinValue) {
+        if (valueOutOfRange(leftPinValue, rightPinValue)) {
+            Log.e(TAG,
+                    "Pin value left " + leftPinValue + ", or right " + rightPinValue
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + mTickStart + ") and less than the maximum value ("
+                            + mTickEnd + ")");
+            throw new IllegalArgumentException(
+                    "Pin value left " + leftPinValue + ", or right " + rightPinValue
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + mTickStart + ") and less than the maximum value ("
+                            + mTickEnd + ")");
+        } else {
+            if (mFirstSetTickCount) {
+                mFirstSetTickCount = false;
+            }
+
+            mLeftIndex = (int) ((leftPinValue - mTickStart) / mTickInterval);
+            mRightIndex = (int) ((rightPinValue - mTickStart) / mTickInterval);
+            createPins();
+
+            if (mListener != null) {
+                mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                        getPinValue(mLeftIndex), getPinValue(mRightIndex));
+            }
+        }
+
+        if (mListener != null)
+            mListener.onTouchEnded(this);
+
+        invalidate();
+        requestLayout();
+    }
+
+    /**
+     * Sets the location of pin according by the supplied value.
+     *
+     * @param pinValue Float specifying the value of the pin
+     */
+    public void setSeekPinByValue(float pinValue) {
+        if (pinValue > mTickEnd || pinValue < mTickStart) {
+            Log.e(TAG,
+                    "Pin value " + pinValue
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + mTickStart + ") and less than the maximum value ("
+                            + mTickEnd + ")");
+            throw new IllegalArgumentException(
+                    "Pin value " + pinValue
+                            + " is out of bounds. Check that it is greater than the minimum ("
+                            + mTickStart + ") and less than the maximum value ("
+                            + mTickEnd + ")");
+
+        } else {
+            if (mFirstSetTickCount) {
+                mFirstSetTickCount = false;
+            }
+            mRightIndex = (int) ((pinValue - mTickStart) / mTickInterval);
+            createPins();
+
+            if (mListener != null) {
+                mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                        getPinValue(mLeftIndex), getPinValue(mRightIndex));
+            }
+        }
+        invalidate();
+        requestLayout();
+    }
+
+    /**
+     * Gets the type of the bar.
+     *
+     * @return true if rangebar, false if seekbar.
+     */
+    public boolean isRangeBar() {
+        return mIsRangeBar;
+    }
+
+    /**
+     * Gets the value of the left pin.
+     *
+     * @return the string value of the left pin.
+     */
+    public String getLeftPinValue() {
+        return getPinValue(mLeftIndex);
+    }
+
+    /**
+     * Gets the value of the right pin.
+     *
+     * @return the string value of the right pin.
+     */
+    public String getRightPinValue() {
+        return getPinValue(mRightIndex);
+    }
+
+    /**
+     * Gets the index of the left-most pin.
+     *
+     * @return the 0-based index of the left pin
+     */
+    public int getLeftIndex() {
+        return mLeftIndex;
+    }
+
+    /**
+     * Gets the index of the right-most pin.
+     *
+     * @return the 0-based index of the right pin
+     */
+    public int getRightIndex() {
+        return mRightIndex;
+    }
+
+    /**
+     * Gets the tick interval.
+     *
+     * @return the tick interval
+     */
+    public double getTickInterval() {
+        return mTickInterval;
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        if (!enabled) {
+            mBarColor = DEFAULT_BAR_COLOR;
+            setConnectingLineColor(DEFAULT_BAR_COLOR);
+            mThumbColor = DEFAULT_BAR_COLOR;
+            mThumbColorLeft = DEFAULT_BAR_COLOR;
+            mThumbColorRight = DEFAULT_BAR_COLOR;
+            mThumbBoundaryColor = DEFAULT_BAR_COLOR;
+            mTickDefaultColor = DEFAULT_BAR_COLOR;
+            setTickColors(DEFAULT_BAR_COLOR);
+            mTickLabelColor = DEFAULT_BAR_COLOR;
+            mTickLabelSelectedColor = DEFAULT_BAR_COLOR;
+        } else {
+            mBarColor = mActiveBarColor;
+            setConnectingLineColor(mActiveConnectingLineColor);
+            setConnectingLineColors(mActiveConnectingLineColors);
+            mThumbColor = mActiveCircleColor;
+            mThumbColorLeft = mActiveCircleColorLeft;
+            mThumbColorRight = mActiveCircleColorRight;
+            mThumbBoundaryColor = mActiveCircleBoundaryColor;
+            mTickDefaultColor = mActiveTickDefaultColor;
+            setTickColors(mActiveTickColors);
+            mTickLabelColor = mActiveTickLabelColor;
+            mTickLabelSelectedColor = mActiveTickLabelSelectedColor;
+        }
+
+        super.setEnabled(enabled);
+        createBar();
+        createPins();
+        createConnectingLine();
+    }
+
+
+    public void setPinTextFormatter(PinTextFormatter pinTextFormatter) {
+        this.mPinTextFormatter = pinTextFormatter;
+    }
+
+    // Private Methods /////////////////////////////////////////////////////////
+
+    /**
+     * Does all the functions of the constructor for RangeBar. Called by both
+     * RangeBar constructors in lieu of copying the code for each constructor.
+     *
+     * @param context Context from the constructor.
+     * @param attrs   AttributeSet from the constructor.
+     */
+    private void rangeBarInit(Context context, AttributeSet attrs) {
+        //TODO tick value map
+        if (mTickMap == null) {
+            mTickMap = new HashMap<Float, String>();
+        }
+        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.RangeBar, 0, 0);
+
+        try {
+
+            // Sets the values of the user-defined attributes based on the XML
+            // attributes.
+            final float tickStart = ta
+                    .getFloat(R.styleable.RangeBar_mrb_tickStart, DEFAULT_TICK_START);
+            final float tickEnd = ta
+                    .getFloat(R.styleable.RangeBar_mrb_tickEnd, DEFAULT_TICK_END);
+            final float tickInterval = ta
+                    .getFloat(R.styleable.RangeBar_mrb_tickInterval, DEFAULT_TICK_INTERVAL);
+            final float minDistance = ta
+                    .getFloat(R.styleable.RangeBar_mrb_minThumbDistance, DEFAULT_MIN_DISTANCE);
+            int tickCount = (int) ((tickEnd - tickStart) / tickInterval) + 1;
+            if (isValidTickCount(tickCount)) {
+
+                // Similar functions performed above in setTickCount; make sure
+                // you know how they interact
+                mTickCount = tickCount;
+                mTickStart = tickStart;
+                mTickEnd = tickEnd;
+                mTickInterval = tickInterval;
+                mLeftIndex = 0;
+                mRightIndex = mTickCount - 1;
+                mDesiredMinDistance = minDistance;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex),
+                            getPinValue(mRightIndex));
+                }
+
+            } else {
+
+                Log.e(TAG, "tickCount less than 2; invalid tickCount. XML input ignored.");
+            }
+
+            mTickHeight = ta.getDimension(R.styleable.RangeBar_mrb_tickHeight,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_TICK_HEIGHT_DP,
+                            mDisplayMetrices)
+            );
+            mBarWeight = ta.getDimension(R.styleable.RangeBar_mrb_barWeight,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_BAR_WEIGHT_DP,
+                            mDisplayMetrices)
+            );
+            mThumbSize = ta.getDimension(R.styleable.RangeBar_mrb_thumbSize,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_CIRCLE_SIZE_DP,
+                            mDisplayMetrices)
+            );
+            mThumbBoundarySize = ta.getDimension(R.styleable.RangeBar_mrb_thumbBoundarySize,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_CIRCLE_BOUNDARY_SIZE_DP,
+                            mDisplayMetrices)
+            );
+            mConnectingLineWeight = ta.getDimension(R.styleable.RangeBar_mrb_connectingLineWeight,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_CONNECTING_LINE_WEIGHT_DP,
+                            mDisplayMetrices)
+            );
+            mExpandedPinRadius = ta.getDimension(R.styleable.RangeBar_mrb_pinRadius,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_EXPANDED_PIN_RADIUS_DP,
+                            mDisplayMetrices)
+            );
+            mPinPadding = ta.getDimension(R.styleable.RangeBar_mrb_pinPadding,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_PIN_PADDING_DP,
+                            mDisplayMetrices)
+            );
+            mBarPaddingBottom = ta.getDimension(R.styleable.RangeBar_mrb_rangeBarPaddingBottom,
+                    TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_BAR_PADDING_BOTTOM_DP,
+                            mDisplayMetrices)
+            );
+
+            mBarColor = ta.getColor(R.styleable.RangeBar_mrb_rangeBarColor, DEFAULT_BAR_COLOR);
+            mTextColor = ta.getColor(R.styleable.RangeBar_mrb_pinTextColor, DEFAULT_TEXT_COLOR);
+            mPinColor = ta.getColor(R.styleable.RangeBar_mrb_pinColor, DEFAULT_PIN_COLOR);
+            mActiveBarColor = mBarColor;
+
+
+            mThumbColor = ta.getColor(R.styleable.RangeBar_mrb_thumbColor,
+                    DEFAULT_CONNECTING_LINE_COLOR);
+
+            mThumbColorLeft = ta.getColor(R.styleable.RangeBar_mrb_leftThumbColor,
+                    mThumbColor);
+            mThumbColorRight = ta.getColor(R.styleable.RangeBar_mrb_rightThumbColor,
+                    mThumbColor);
+            mThumbBoundaryColor = ta.getColor(R.styleable.RangeBar_mrb_thumbBoundaryColor,
+                    DEFAULT_CONNECTING_LINE_COLOR);
+
+            mActiveCircleColor = mThumbColor;
+            mActiveCircleColorLeft = mThumbColorLeft;
+            mActiveCircleColorRight = mThumbColorRight;
+            mActiveCircleBoundaryColor = mThumbBoundaryColor;
+            mTickDefaultColor = ta.getColor(R.styleable.RangeBar_mrb_tickDefaultColor, DEFAULT_TICK_COLOR);
+            mActiveTickDefaultColor = mTickDefaultColor;
+            mTickColors = getColors(ta.getTextArray(R.styleable.RangeBar_mrb_tickColors), mTickDefaultColor);
+            mActiveTickColors = new ArrayList<>(mTickColors);
+
+            mTickLabelColor = ta.getColor(R.styleable.RangeBar_mrb_tickLabelColor, DEFAULT_TICK_LABEL_COLOR);
+            mActiveTickLabelColor = mTickLabelColor;
+            mTickLabelSelectedColor = ta.getColor(R.styleable.RangeBar_mrb_tickLabelSelectedColor, DEFAULT_TICK_LABEL_SELECTED_COLOR);
+            mActiveTickLabelSelectedColor = mTickLabelSelectedColor;
+
+            mTickBottomLabels = ta.getTextArray(R.styleable.RangeBar_mrb_tickBottomLabels);
+            mTickTopLabels = ta.getTextArray(R.styleable.RangeBar_mrb_tickTopLabels);
+            mTickDefaultLabel = ta.getString(R.styleable.RangeBar_mrb_tickDefaultLabel);
+            mTickDefaultLabel = (mTickDefaultLabel != null) ? mTickDefaultLabel : DEFAULT_TICK_LABEL;
+
+            int mConnectingLineColor = ta.getColor(R.styleable.RangeBar_mrb_connectingLineColor,
+                    DEFAULT_CONNECTING_LINE_COLOR);
+            mActiveConnectingLineColor = mConnectingLineColor;
+
+            CharSequence[] colors = ta.getTextArray(R.styleable.RangeBar_mrb_connectingLineColors);
+            if (colors != null && colors.length > 0) {
+                for (CharSequence colorHex : colors) {
+                    String hexString = colorHex.toString();
+
+                    if (hexString.length() == 4)
+                        hexString += "000";
+
+                    mConnectingLineColors.add(Color.parseColor(hexString));
+                }
+            } else {
+                mConnectingLineColors.add(mConnectingLineColor);
+            }
+
+            mActiveConnectingLineColors = new ArrayList<>(mConnectingLineColors);
+
+            mIsRangeBar = ta.getBoolean(R.styleable.RangeBar_mrb_rangeBar, true);
+            mArePinsTemporary = ta.getBoolean(R.styleable.RangeBar_mrb_temporaryPins, true);
+            mIsBarRounded = ta.getBoolean(R.styleable.RangeBar_mrb_rangeBar_rounded, false);
+
+            float density = mDisplayMetrices.density;
+            mMinPinFont = ta.getDimension(R.styleable.RangeBar_mrb_pinMinFont,
+                    DEFAULT_MIN_PIN_FONT_SP * density);
+            mMaxPinFont = ta.getDimension(R.styleable.RangeBar_mrb_pinMaxFont,
+                    DEFAULT_MAX_PIN_FONT_SP * density);
+            mTickLabelSize = ta.getDimension(R.styleable.RangeBar_mrb_tickLabelSize,
+                    DEFAULT_TICK_LABEL_FONT_SP * density);
+
+            mIsRangeBar = ta.getBoolean(R.styleable.RangeBar_mrb_rangeBar, true);
+
+            mOnlyOnDrag = ta.getBoolean(R.styleable.RangeBar_mrb_onlyOnDrag, false);
+        } finally {
+            ta.recycle();
+        }
+    }
+
+    /**
+     * Creates a new mBar
+     */
+    private void createBar() {
+        mBar = new Bar(getContext(),
+                getMarginLeft(),
+                getYPos(),
+                getBarLength(),
+                mTickCount,
+                mTickHeight,
+                mTickDefaultColor,
+                mTickColors,
+                mBarWeight,
+                mBarColor,
+                mIsBarRounded,
+                mTickLabelColor,
+                mTickLabelSelectedColor,
+                mTickTopLabels,
+                mTickBottomLabels,
+                mTickDefaultLabel,
+                mTickLabelSize);
+        invalidate();
+    }
+
+    /**
+     * Creates a new ConnectingLine.
+     */
+    private void createConnectingLine() {
+
+        mConnectingLine = new ConnectingLine(getYPos(),
+                mConnectingLineWeight,
+                mConnectingLineColors);
+        invalidate();
+    }
+
+    /**
+     * Creates two new Pins.
+     */
+    private void createPins() {
+        Context ctx = getContext();
+        float yPos = getYPos();
+
+        float expandedPinRadius = 0.0f;
+        if (isEnabled()) {
+            expandedPinRadius = mExpandedPinRadius / mDisplayMetrices.density;
+        }
+
+        if (mIsRangeBar) {
+            mLeftThumb = new PinView(ctx);
+            mLeftThumb.init(ctx, yPos, expandedPinRadius, mPinColor, mTextColor, mThumbSize, mThumbColorLeft, mThumbBoundaryColor, mThumbBoundarySize,
+                    mMinPinFont, mMaxPinFont, mArePinsTemporary);
+        }
+        mRightThumb = new PinView(ctx);
+        mRightThumb
+                .init(ctx, yPos, expandedPinRadius, mPinColor, mTextColor, mThumbSize, mThumbColorRight, mThumbBoundaryColor, mThumbBoundarySize
+                        , mMinPinFont, mMaxPinFont, mArePinsTemporary);
+
+        float marginLeft = getMarginLeft();
+        float barLength = getBarLength();
+
+        // Initialize thumbs to the desired indices
+        if (mIsRangeBar) {
+            mLeftThumb.setX(marginLeft + (mLeftIndex / (float) (mTickCount - 1)) * barLength);
+            mLeftThumb.setXValue(getPinValue(mLeftIndex));
+        }
+        mRightThumb.setX(marginLeft + (mRightIndex / (float) (mTickCount - 1)) * barLength);
+        mRightThumb.setXValue(getPinValue(mRightIndex));
+
+        invalidate();
+    }
+
+    /**
+     * Get marginLeft in each of the public attribute methods.
+     *
+     * @return float marginLeft
+     */
+    private float getMarginLeft() {
+        return Math.max(mExpandedPinRadius, mThumbSize);
+    }
+
+    /**
+     * Get yPos in each of the public attribute methods.
+     *
+     * @return float yPos
+     */
+    private float getYPos() {
+        return (getHeight() - mBarPaddingBottom);
+    }
+
+    /**
+     * Get barLength in each of the public attribute methods.
+     *
+     * @return float barLength
+     */
+    private float getBarLength() {
+        return (getWidth() - 2 * getMarginLeft());
+    }
+
+    /**
+     * Returns if either index is outside the range of the tickCount.
+     *
+     * @param leftThumbIndex  Integer specifying the left thumb index.
+     * @param rightThumbIndex Integer specifying the right thumb index.
+     * @return boolean If the index is out of range.
+     */
+    private boolean indexOutOfRange(int leftThumbIndex, int rightThumbIndex) {
+        return (leftThumbIndex < 0 || leftThumbIndex >= mTickCount
+                || rightThumbIndex < 0
+                || rightThumbIndex >= mTickCount);
+    }
+
+    /**
+     * Returns if either value is outside the range of the tickCount.
+     *
+     * @param leftThumbValue  Float specifying the left thumb value.
+     * @param rightThumbValue Float specifying the right thumb value.
+     * @return boolean If the index is out of range.
+     */
+    private boolean valueOutOfRange(float leftThumbValue, float rightThumbValue) {
+        return (leftThumbValue < mTickStart || leftThumbValue > mTickEnd
+                || rightThumbValue < mTickStart || rightThumbValue > mTickEnd);
+    }
+
+    /**
+     * If is invalid tickCount, rejects. TickCount must be greater than 1
+     *
+     * @param tickCount Integer
+     * @return boolean: whether tickCount > 1
+     */
+    private boolean isValidTickCount(int tickCount) {
+        return (tickCount > 1);
+    }
+
+    /**
+     * Gets the distance between x and the left pin. If the left and right pins are equal, this
+     * returns 0 if x is < the pins' position. Also returns 0 if the bar is not a range bar.
+     *
+     * @param x the x-coordinate to be checked
+     * @return the distance between x and the left pin, or 0 if the pins are equal and x is to the left.
+     * Also returns 0 if the bar is not a range bar.
+     */
+    private float getLeftThumbXDistance(float x) {
+        if (isRangeBar()) {
+            float leftThumbX = mLeftThumb.getX();
+            return (leftThumbX == mRightThumb.getX() && x < leftThumbX) ? 0 : Math.abs(leftThumbX - x);
+        } else {
+            return 0;
+        }
+    }
+
+    /**
+     * Gets the distance between x and the right pin
+     *
+     * @param x the x-coordinate to be checked
+     * @return the distance between x and the right pin
+     */
+    private float getRightThumbXDistance(float x) {
+        return Math.abs(mRightThumb.getX() - x);
+    }
+
+    /**
+     * Handles a {@link MotionEvent#ACTION_DOWN} event.
+     *
+     * @param x the x-coordinate of the down action
+     * @param y the y-coordinate of the down action
+     */
+    private void onActionDown(float x, float y) {
+        if (mIsRangeBar) {
+            if (!mRightThumb.isPressed() && mLeftThumb.isInTargetZone(x, y)) {
+
+                pressPin(mLeftThumb);
+
+            } else if (!mLeftThumb.isPressed() && mRightThumb.isInTargetZone(x, y)) {
+
+                pressPin(mRightThumb);
+            }
+        } else {
+            if (mRightThumb.isInTargetZone(x, y)) {
+                pressPin(mRightThumb);
+            }
+        }
+        mDragging = true;
+
+        if (mListener != null)
+            mListener.onTouchStarted(this);
+    }
+
+    /**
+     * Handles a {@link MotionEvent#ACTION_UP} or
+     * {@link MotionEvent#ACTION_CANCEL} event.
+     *
+     * @param x the x-coordinate of the up action
+     * @param y the y-coordinate of the up action
+     */
+    private void onActionUp(float x, float y) {
+        if (mIsRangeBar && mLeftThumb.isPressed()) {
+
+            releasePin(mLeftThumb);
+
+        } else if (mRightThumb.isPressed()) {
+
+            releasePin(mRightThumb);
+
+        } else if (!mOnlyOnDrag) {
+            final float leftThumbXDistance = getLeftThumbXDistance(x);
+            final float rightThumbXDistance = getRightThumbXDistance(x);
+            final boolean moveLeftThumb = leftThumbXDistance < rightThumbXDistance;
+
+            if (moveLeftThumb && x > mLeftBoundX) {
+                x = mLeftBoundX;
+            } else if (!moveLeftThumb && x < mRightBoundX) {
+                x = mRightBoundX;
+            }
+            //move if is rangeBar and left index is lower of right one
+            //if is not range bar leftThumbXDistance is always 0
+            if (moveLeftThumb && mIsRangeBar) {
+                mLeftThumb.setX(x);
+                releasePin(mLeftThumb);
+            } else {
+                mRightThumb.setX(x);
+                releasePin(mRightThumb);
+            }
+
+            // Get the updated nearest tick marks for each thumb.
+            final int newLeftIndex = mIsRangeBar ? mBar.getNearestTickIndex(mLeftThumb) : 0;
+            final int newRightIndex = mBar.getNearestTickIndex(mRightThumb);
+            // If either of the indices have changed, update and call the listener.
+            if (newLeftIndex != mLeftIndex || newRightIndex != mRightIndex) {
+
+                mLeftIndex = newLeftIndex;
+                mRightIndex = newRightIndex;
+
+                if (mListener != null) {
+                    mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                            getPinValue(mLeftIndex),
+                            getPinValue(mRightIndex));
+                }
+            }
+        }
+        mDragging = false;
+
+        if (mListener != null)
+            mListener.onTouchEnded(this);
+    }
+
+    /**
+     * Handles a {@link MotionEvent#ACTION_MOVE} event.
+     *
+     * @param x the x-coordinate of the move event
+     */
+    private void onActionMove(float x) {
+        if (mIsRangeBar && mRightThumb.isPressed() && x < mRightBoundX) {
+            x = mRightBoundX;
+        } else if (mIsRangeBar && mLeftThumb.isPressed() && x > mLeftBoundX) {
+            x = mLeftBoundX;
+        }
+
+        // Move the pressed thumb to the new x-position.
+        if (mIsRangeBar && mLeftThumb.isPressed()) {
+            movePin(mLeftThumb, x);
+        } else if (mRightThumb.isPressed()) {
+            movePin(mRightThumb, x);
+        }
+
+        // If the thumbs have switched order, fix the references.
+        if (mIsRangeBar && mLeftThumb.getX() > mRightThumb.getX()) {
+            final PinView temp = mLeftThumb;
+            mLeftThumb = mRightThumb;
+            mRightThumb = temp;
+        }
+
+        // Get the updated nearest tick marks for each thumb.
+        int newLeftIndex = mIsRangeBar ? mBar.getNearestTickIndex(mLeftThumb) : 0;
+        int newRightIndex = mBar.getNearestTickIndex(mRightThumb);
+
+        final int componentLeft = getPaddingLeft();
+        final int componentRight = getRight() - getPaddingRight() - componentLeft;
+
+        if (x <= componentLeft) {
+            newLeftIndex = 0;
+            movePin(mLeftThumb, mBar.getLeftX());
+        } else if (x >= componentRight) {
+            newRightIndex = getTickCount() - 1;
+            movePin(mRightThumb, mBar.getRightX());
+        }
+
+        /// end added code
+        // If either of the indices have changed, update and call the listener.
+        if (newLeftIndex != mLeftIndex || newRightIndex != mRightIndex) {
+            mLeftIndex = newLeftIndex;
+            mRightIndex = newRightIndex;
+            if (mIsRangeBar) {
+                mLeftThumb.setXValue(getPinValue(mLeftIndex));
+            }
+            mRightThumb.setXValue(getPinValue(mRightIndex));
+
+            if (mListener != null) {
+                mListener.onRangeChangeListener(this, mLeftIndex, mRightIndex,
+                        getPinValue(mLeftIndex),
+                        getPinValue(mRightIndex));
+            }
+        }
+    }
+
+    /**
+     * Set the thumb to be in the pressed state and calls invalidate() to redraw
+     * the canvas to reflect the updated state.
+     *
+     * @param thumb the thumb to press
+     */
+    private void pressPin(final PinView thumb) {
+        if (mFirstSetTickCount) {
+            mFirstSetTickCount = false;
+        }
+        if (mArePinsTemporary) {
+            ValueAnimator animator = ValueAnimator.ofFloat(0, mExpandedPinRadius);
+            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+
+                @Override
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    mThumbRadiusDP = (Float) (animation.getAnimatedValue());
+                    thumb.setSize(mThumbRadiusDP, mPinPadding * animation.getAnimatedFraction());
+                    invalidate();
+                }
+            });
+            animator.start();
+        }
+
+        thumb.press();
+    }
+
+    /**
+     * Set the thumb to be in the normal/un-pressed state and calls invalidate()
+     * to redraw the canvas to reflect the updated state.
+     *
+     * @param thumb the thumb to release
+     */
+    private void releasePin(final PinView thumb) {
+
+        float nearestTickX = mBar.getNearestTickCoordinate(thumb);
+        thumb.setX(nearestTickX);
+        int tickIndex = mBar.getNearestTickIndex(thumb);
+        thumb.setXValue(getPinValue(tickIndex));
+
+        if (mArePinsTemporary) {
+            ValueAnimator animator = ValueAnimator.ofFloat(mExpandedPinRadius, 0);
+            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+
+                @Override
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    mThumbRadiusDP = (Float) (animation.getAnimatedValue());
+                    thumb.setSize(mThumbRadiusDP,
+                            mPinPadding - (mPinPadding * animation.getAnimatedFraction()));
+                    invalidate();
+                }
+            });
+            animator.start();
+        } else {
+            invalidate();
+        }
+
+        thumb.release();
+    }
+
+    /**
+     * Set the value on the thumb pin, either from map or calculated from the tick intervals
+     * Integer check to format decimals as whole numbers
+     *
+     * @param tickIndex the index to set the value for
+     */
+    private String getPinValue(int tickIndex) {
+        if (mPinTextListener != null) {
+            return mPinTextListener.getPinValue(this, tickIndex);
+        }
+        float tickValue = (tickIndex == (mTickCount - 1))
+                ? mTickEnd
+                : (tickIndex * mTickInterval) + mTickStart;
+        String xValue = mTickMap.get(tickValue);
+        if (xValue == null) {
+            if (tickValue == Math.ceil(tickValue)) {
+                xValue = String.valueOf((int) tickValue);
+            } else {
+                xValue = String.valueOf(tickValue);
+            }
+        }
+        return mPinTextFormatter.getText(xValue);
+    }
+
+    /**
+     * Loads list of colors and sets default
+     *
+     * @param colors
+     * @return ArrayList<Integer>
+     */
+    private ArrayList<Integer> getColors(CharSequence[] colors, int defaultColor) {
+        ArrayList<Integer> colorList = new ArrayList<>();
+
+        if (colors != null && colors.length > 0) {
+            for (CharSequence colorHex : colors) {
+                String hexString = colorHex.toString();
+
+                if (hexString.length() == 4)
+                    hexString += "000";
+
+                colorList.add(Color.parseColor(hexString));
+            }
+        } else {
+            colorList.add(defaultColor);
+        }
+
+        return colorList;
+    }
+
+    /**
+     * Moves the thumb to the given x-coordinate.
+     *
+     * @param thumb the thumb to move
+     * @param x     the x-coordinate to move the thumb to
+     */
+    private void movePin(PinView thumb, float x) {
+
+        // If the user has moved their finger outside the range of the bar,
+        // do not move the thumbs past the edge.
+        if (x < mBar.getLeftX() || x > mBar.getRightX()) {
+            // Do nothing.
+        } else if (thumb != null) {
+            thumb.setX(x);
+            invalidate();
+        }
+    }
+
+    /**
+     * Updates the Thumbs bounds based on the minimum distance, to their right and their left respectively.
+     */
+    private void updateThumbBounds() {
+        mMinIndexDistance = (int) Math.ceil(mDesiredMinDistance / mTickInterval);
+        if (mMinIndexDistance > mTickCount - 1) {
+            Log.e(TAG, "Desired thumb distance greater than total range.");
+            mMinIndexDistance = mTickCount - 1;
+        }
+        int maxIndexLeft = mRightIndex - mMinIndexDistance;
+        int minIndexRight = mLeftIndex + mMinIndexDistance;
+        mLeftBoundX = mBar.getTickX(Math.max(0, maxIndexLeft));
+        mRightBoundX = mBar.getTickX(Math.min(getTickCount() - 1, minIndexRight));
+    }
+
+    /**
+     * This flag is useful for tracking touch events that were meant as scroll events.
+     * Copied from hidden method of {@link View} isInScrollingContainer.
+     *
+     * @return true if any of this View parents is a scrolling View.
+     */
+    private boolean isInScrollingContainer() {
+        ViewParent p = getParent();
+        while (p instanceof ViewGroup) {
+            if (((ViewGroup) p).shouldDelayChildPressedState()) {
+                return true;
+            }
+            p = p.getParent();
+        }
+        return false;
+    }
+
+    /**
+     * Sets the minimum desired distance between Thumbs.
+     *
+     * @param distance The desired minimum distance
+     */
+    public void setMinimumThumbDistance(float distance) {
+        mDesiredMinDistance = distance;
+    }
+
+    // Inner Classes ///////////////////////////////////////////////////////////
+
+    /**
+     * A callback that notifies clients when the RangeBar has changed. The
+     * listener will only be called when either thumb's index has changed - not
+     * for every movement of the thumb.
+     */
+    public interface OnRangeBarChangeListener {
+
+        void onRangeChangeListener(RangeBar rangeBar, int leftPinIndex,
+                                   int rightPinIndex, String leftPinValue, String rightPinValue);
+
+        void onTouchStarted(RangeBar rangeBar);
+
+        void onTouchEnded(RangeBar rangeBar);
+    }
+
+    public interface PinTextFormatter {
+
+        String getText(String value);
+    }
+
+    /**
+     * @author robmunro
+     * A callback that allows getting pin text exernally
+     */
+    public interface OnRangeBarTextListener {
+
+        String getPinValue(RangeBar rangeBar, int tickIndex);
+    }
+}
Index: app/src/main/java/com/appyvet/materialrangebar/PinView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/appyvet/materialrangebar/PinView.java b/app/src/main/java/com/appyvet/materialrangebar/PinView.java
new file mode 100644
--- /dev/null	(date 1726419013036)
+++ b/app/src/main/java/com/appyvet/materialrangebar/PinView.java	(date 1726419013036)
@@ -0,0 +1,323 @@
+/*
+ * Copyright 2014, Appyvet, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in compliance with the License.
+ * You may obtain a copy of the License in the LICENSE file, or at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.appyvet.materialrangebar;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import androidx.core.content.ContextCompat;
+import androidx.core.graphics.drawable.DrawableCompat;
+import android.util.TypedValue;
+import android.view.View;
+
+import com.qboxus.binder.R;
+
+
+/**
+ * Represents a thumb in the RangeBar slider. This is the handle for the slider
+ * that is pressed and slid.
+ */
+class PinView extends View {
+
+    // Private Constants ///////////////////////////////////////////////////////
+
+    // The radius (in dp) of the touchable area around the thumb. We are basing
+    // this value off of the recommended 48dp Rhythm. See:
+    // http://developer.android.com/design/style/metrics-grids.html#48dp-rhythm
+    private static final float MINIMUM_TARGET_RADIUS_DP = 24;
+
+    // Sets the default values for radius, normal, pressed if circle is to be
+    // drawn but no value is given.
+    private static final float DEFAULT_THUMB_RADIUS_DP = 14;
+
+    // Member Variables ////////////////////////////////////////////////////////
+
+    // Radius (in pixels) of the touch area of the thumb.
+    private float mTargetRadiusPx;
+
+    // Indicates whether this thumb is currently pressed and active.
+    private boolean mIsPressed = false;
+
+    // The y-position of the thumb in the parent view. This should not change.
+    private float mY;
+
+    // The current x-position of the thumb in the parent view.
+    private float mX;
+
+    // mPaint to draw the thumbs if attributes are selected
+
+    private Paint mTextPaint;
+
+    private Drawable mPin;
+
+    private String mValue;
+
+    // Radius of the new thumb if selected
+    private int mPinRadiusPx;
+
+    private float mPinPadding;
+
+    private float mTextYPadding;
+
+    private Rect mBounds = new Rect();
+
+    private Resources mRes;
+
+    private float mDensity;
+
+    private Paint mCirclePaint;
+
+    private Paint mCircleBoundaryPaint;
+
+    private float mCircleRadiusPx;
+
+    private float mCircleBoundaryRadiusPx;
+
+    private IRangeBarFormatter formatter;
+
+    private float mMinPinFont = RangeBar.DEFAULT_MIN_PIN_FONT_SP;
+
+    private float mMaxPinFont = RangeBar.DEFAULT_MAX_PIN_FONT_SP;
+
+    private boolean mPinsAreTemporary;
+
+    private boolean mHasBeenPressed = false;
+
+    private int pinColor;
+
+    // Constructors ////////////////////////////////////////////////////////////
+
+    public PinView(Context context) {
+        super(context);
+    }
+
+    // Initialization //////////////////////////////////////////////////////////
+
+    public void setFormatter(IRangeBarFormatter mFormatter) {
+        this.formatter = mFormatter;
+    }
+
+    /**
+     * The view is created empty with a default constructor. Use init to set all the initial
+     * variables for the pin
+     *
+     * @param ctx                 Context
+     * @param y                   The y coordinate to raw the pin (i.e. the bar location)
+     * @param pinRadiusDP         the initial size of the pin
+     * @param pinColor            the color of the pin
+     * @param textColor           the color of the value text in the pin
+     * @param circleRadius        the radius of the selector circle
+     * @param circleColor         the color of the selector circle
+     * @param circleBoundaryColor The color of the selector circle boundary
+     * @param circleBoundarySize  The size of the selector circle boundary line
+     * @param minFont             the minimum font size for the pin text
+     * @param maxFont             the maximum font size for the pin text
+     * @param pinsAreTemporary    whether to show the pin initially or just the circle
+     */
+    public void init(Context ctx, float y, float pinRadiusDP, int pinColor, int textColor,
+                     float circleRadius, int circleColor, int circleBoundaryColor, float circleBoundarySize, float minFont, float maxFont, boolean pinsAreTemporary) {
+
+        mRes = ctx.getResources();
+        mPin = ContextCompat.getDrawable(ctx, R.drawable.rotate);
+
+        mDensity = getResources().getDisplayMetrics().density;
+        mMinPinFont = minFont / mDensity;
+        mMaxPinFont = maxFont / mDensity;
+        mPinsAreTemporary = pinsAreTemporary;
+
+        mPinPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 15,
+                mRes.getDisplayMetrics());
+        mCircleRadiusPx = circleRadius;
+        mTextYPadding = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 3.5f,
+                mRes.getDisplayMetrics());
+        // If one of the attributes are set, but the others aren't, set the
+        // attributes to default
+        if (pinRadiusDP == -1) {
+            mPinRadiusPx = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_THUMB_RADIUS_DP,
+                    mRes.getDisplayMetrics());
+        } else {
+            mPinRadiusPx = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, pinRadiusDP,
+                    mRes.getDisplayMetrics());
+        }
+        //Set text size in px from dp
+        int textSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 15,
+                mRes.getDisplayMetrics());
+
+        // Creates the paint and sets the Paint values
+        mTextPaint = new Paint();
+        mTextPaint.setColor(textColor);
+        mTextPaint.setAntiAlias(true);
+        mTextPaint.setTextSize(textSize);
+        // Creates the paint and sets the Paint values
+        mCirclePaint = new Paint();
+        mCirclePaint.setColor(circleColor);
+        mCirclePaint.setAntiAlias(true);
+
+        if (circleBoundarySize != 0) {
+            mCircleBoundaryPaint = new Paint();
+            mCircleBoundaryPaint.setStyle(Paint.Style.STROKE);
+            mCircleBoundaryPaint.setColor(circleBoundaryColor);
+            mCircleBoundaryPaint.setStrokeWidth(circleBoundarySize);
+            mCircleBoundaryPaint.setAntiAlias(true);
+
+            mCircleBoundaryRadiusPx = mCircleRadiusPx - mCircleBoundaryPaint.getStrokeWidth() / 2;
+        }
+
+        this.pinColor = pinColor;
+
+        // Sets the minimum touchable area, but allows it to expand based on
+        // image size
+        int targetRadius = (int) Math.max(MINIMUM_TARGET_RADIUS_DP, mPinRadiusPx);
+
+        mTargetRadiusPx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, targetRadius,
+                mRes.getDisplayMetrics());
+        mY = y;
+    }
+
+    /**
+     * Set the x value of the pin
+     *
+     * @param x set x value of the pin
+     */
+    @Override
+    public void setX(float x) {
+        mX = x;
+    }
+
+
+    /**
+     * Get the x value of the pin
+     *
+     * @return x float value of the pin
+     */
+    @Override
+    public float getX() {
+        return mX;
+    }
+
+
+    /**
+     * Set the value of the pin
+     *
+     * @param x String value of the pin
+     */
+    public void setXValue(String x) {
+        mValue = x;
+    }
+
+    /**
+     * Determine if the pin is pressed
+     *
+     * @return true if is in pressed state
+     * false otherwise
+     */
+    @Override
+    public boolean isPressed() {
+        return mIsPressed;
+    }
+
+    /**
+     * Sets the state of the pin to pressed
+     */
+    public void press() {
+        mIsPressed = true;
+        mHasBeenPressed = true;
+    }
+
+    /**
+     * Set size of the pin and padding for use when animating pin enlargement on press
+     *
+     * @param size    the size of the pin radius
+     * @param padding the size of the padding
+     */
+    public void setSize(float size, float padding) {
+        mPinPadding = (int) padding;
+        mPinRadiusPx = (int) size;
+        invalidate();
+    }
+
+    /**
+     * Release the pin, sets pressed state to false
+     */
+    public void release() {
+        mIsPressed = false;
+    }
+
+    /**
+     * Determines if the input coordinate is close enough to this thumb to
+     * consider it a press.
+     *
+     * @param x the x-coordinate of the user touch
+     * @param y the y-coordinate of the user touch
+     * @return true if the coordinates are within this thumb's target area;
+     * false otherwise
+     */
+    public boolean isInTargetZone(float x, float y) {
+        return (Math.abs(x - mX) <= mTargetRadiusPx
+                && Math.abs(y - mY + mPinPadding) <= mTargetRadiusPx);
+    }
+
+    //Draw the circle regardless of pressed state. If pin size is >0 then also draw the pin and text
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.drawCircle(mX, mY, mCircleRadiusPx, mCirclePaint);
+
+        //Draw the circle boundary only if mCircleBoundaryPaint was initialized
+        if (mCircleBoundaryPaint != null)
+            canvas.drawCircle(mX, mY, mCircleBoundaryRadiusPx, mCircleBoundaryPaint);
+
+        //Draw pin if pressed
+        if (mPinRadiusPx > 0 && (mHasBeenPressed || !mPinsAreTemporary)) {
+            mBounds.set((int) mX - mPinRadiusPx,
+                    (int) mY - (mPinRadiusPx * 2) - (int) mPinPadding,
+                    (int) mX + mPinRadiusPx, (int) mY - (int) mPinPadding);
+            mPin.setBounds(mBounds);
+            String text = mValue;
+
+            if (this.formatter != null) {
+                text = formatter.format(text);
+            }
+
+            calibrateTextSize(mTextPaint, text, mBounds.width());
+            mTextPaint.getTextBounds(text, 0, text.length(), mBounds);
+            mTextPaint.setTextAlign(Paint.Align.CENTER);
+            DrawableCompat.setTint(mPin, pinColor);
+            mPin.draw(canvas);
+            canvas.drawText(text,
+                    mX, mY - mPinRadiusPx - mPinPadding + mTextYPadding,
+                    mTextPaint);
+        }
+        super.draw(canvas);
+    }
+
+    // Private Methods /////////////////////////////////////////////////////////////////
+
+    //Set text size based on available pin width.
+    private void calibrateTextSize(Paint paint, String text, float boxWidth) {
+        paint.setTextSize(10);
+
+        float textSize = paint.measureText(text);
+        float estimatedFontSize = boxWidth * 8 / textSize / mDensity;
+
+        if (estimatedFontSize < mMinPinFont) {
+            estimatedFontSize = mMinPinFont;
+        } else if (estimatedFontSize > mMaxPinFont) {
+            estimatedFontSize = mMaxPinFont;
+        }
+        paint.setTextSize(estimatedFontSize * mDensity);
+    }
+}
Index: app/src/main/java/com/appyvet/materialrangebar/MeasureSpecMode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/appyvet/materialrangebar/MeasureSpecMode.java b/app/src/main/java/com/appyvet/materialrangebar/MeasureSpecMode.java
new file mode 100644
--- /dev/null	(date 1726418939125)
+++ b/app/src/main/java/com/appyvet/materialrangebar/MeasureSpecMode.java	(date 1726418939125)
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2013, Edmodo, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in compliance with the License.
+ * You may obtain a copy of the License in the LICENSE file, or at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.appyvet.materialrangebar;
+
+import android.view.View;
+
+/**
+ * Helper enum class for transforming a measureSpec mode integer value into a
+ * human-readable String. The human-readable String is simply the name of the
+ * enum value.
+ */
+public enum MeasureSpecMode {
+
+    AT_MOST(View.MeasureSpec.AT_MOST),
+    EXACTLY(View.MeasureSpec.EXACTLY),
+    UNSPECIFIED(View.MeasureSpec.UNSPECIFIED);
+
+    // Member Variables ////////////////////////////////////////////////////////
+
+    private final int mModeValue;
+
+    // Constructor /////////////////////////////////////////////////////////////
+
+    private MeasureSpecMode(int modeValue) {
+        mModeValue = modeValue;
+    }
+
+    // Public Methods //////////////////////////////////////////////////////////
+
+    /**
+     * Gets the int value associated with this mode.
+     *
+     * @return the int value associated with this mode
+     */
+    public int getModeValue() {
+        return mModeValue;
+    }
+
+    /**
+     * Gets the MeasureSpecMode value that corresponds with the given
+     * measureSpec int value.
+     *
+     * @param measureSpec the measure specification passed by the platform to
+     *
+     * @return the MeasureSpecMode that matches with that measure spec
+     */
+    public static MeasureSpecMode getMode(int measureSpec) {
+
+        final int modeValue = View.MeasureSpec.getMode(measureSpec);
+
+        for (MeasureSpecMode mode : MeasureSpecMode.values()) {
+            if (mode.getModeValue() == modeValue) {
+                return mode;
+            }
+        }
+        return null;
+    }
+}
Index: app/src/main/java/com/appyvet/materialrangebar/ConnectingLine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/appyvet/materialrangebar/ConnectingLine.java b/app/src/main/java/com/appyvet/materialrangebar/ConnectingLine.java
new file mode 100644
--- /dev/null	(date 1586853518000)
+++ b/app/src/main/java/com/appyvet/materialrangebar/ConnectingLine.java	(date 1586853518000)
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2013, Edmodo, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in compliance with the License.
+ * You may obtain a copy of the License in the LICENSE file, or at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.appyvet.materialrangebar;
+
+import android.graphics.Canvas;
+import android.graphics.LinearGradient;
+import android.graphics.Paint;
+import android.graphics.Shader;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Class representing the blue connecting line between the two thumbs.
+ */
+public class ConnectingLine {
+
+    // Member Variables ////////////////////////////////////////////////////////
+
+    private final int[] colors;
+    private final float[] positions;
+    private final Paint paint = new Paint();
+
+    private final float mY;
+
+    // Constructor /////////////////////////////////////////////////////////////
+
+    /**
+     * Constructor for connecting line
+     *
+     * @param y                    the y co-ordinate for the line
+     * @param connectingLineWeight the weight of the line
+     * @param connectingLineColors the color of the line
+     */
+    public ConnectingLine(float y, float connectingLineWeight,
+                          ArrayList<Integer> connectingLineColors) {
+
+        //Need two colors
+        if (connectingLineColors.size() == 1) {
+            connectingLineColors.add(connectingLineColors.get(0));
+        }
+
+        colors = new int[connectingLineColors.size()];
+        positions = new float[connectingLineColors.size()];
+        for (int index = 0; index < connectingLineColors.size(); index++) {
+            colors[index] = connectingLineColors.get(index);
+
+            positions[index] = (float) index / (connectingLineColors.size() - 1);
+        }
+
+        paint.setStrokeWidth(connectingLineWeight);
+        paint.setStrokeCap(Paint.Cap.ROUND);
+        paint.setAntiAlias(true);
+
+        mY = y;
+    }
+
+    private LinearGradient getLinearGradient(float startX, float endX, float height) {
+
+        return new LinearGradient(startX, height, endX, height,
+                colors,
+                positions,
+                Shader.TileMode.REPEAT);
+    }
+
+
+    /**
+     * Draw the connecting line between the two thumbs in rangebar.
+     *
+     * @param canvas     the Canvas to draw to
+     * @param leftThumb  the left thumb
+     * @param rightThumb the right thumb
+     */
+    public void draw(Canvas canvas, PinView leftThumb, PinView rightThumb) {
+        paint.setShader(getLinearGradient(0, canvas.getWidth(), mY));
+
+        canvas.drawLine(leftThumb.getX(), mY, rightThumb.getX(), mY, paint);
+
+    }
+
+    /**
+     * Draw the connecting line between for single slider.
+     *
+     * @param canvas     the Canvas to draw to
+     * @param rightThumb the right thumb
+     * @param leftMargin the left margin
+     */
+    public void draw(Canvas canvas, float leftMargin, PinView rightThumb) {
+        paint.setShader(getLinearGradient(0, canvas.getWidth(), mY));
+
+        canvas.drawLine(leftMargin, mY, rightThumb.getX(), mY, paint);
+    }
+}
Index: app/src/main/res/drawable/rotate.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/rotate.xml b/app/src/main/res/drawable/rotate.xml
new file mode 100644
--- /dev/null	(date 1586853518000)
+++ b/app/src/main/res/drawable/rotate.xml	(date 1586853518000)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<rotate xmlns:android="http://schemas.android.com/apk/res/android"
+    android:drawable="@drawable/roundrect"
+    android:drawablePadding="20dp"
+    android:fromDegrees="45"
+    android:toDegrees="45"
+    android:visible="true" />
\ No newline at end of file
Index: app/src/main/res/drawable/roundrect.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/roundrect.xml b/app/src/main/res/drawable/roundrect.xml
new file mode 100644
--- /dev/null	(date 1586853518000)
+++ b/app/src/main/res/drawable/roundrect.xml	(date 1586853518000)
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:fromDegrees="45"
+    android:padding="30dp"
+    android:shape="rectangle"
+    android:toDegrees="45">
+    <solid android:color="#000000" />
+    <corners
+        android:bottomLeftRadius="50dp"
+        android:bottomRightRadius="0dp"
+        android:radius="2dp"
+        android:topLeftRadius="50dp"
+        android:topRightRadius="50dp" />
+</shape>
\ No newline at end of file
Index: app/src/main/res/drawable/pv_invisible_image.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/drawable/pv_invisible_image.xml b/app/src/main/res/drawable/pv_invisible_image.xml
new file mode 100644
--- /dev/null	(date 1613633776000)
+++ b/app/src/main/res/drawable/pv_invisible_image.xml	(date 1613633776000)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+    <size
+        android:width="0dp"
+        android:height="0dp" />
+</shape>
\ No newline at end of file
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
--- a/app/src/main/res/values/strings.xml	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/app/src/main/res/values/strings.xml	(date 1726418337082)
@@ -1,5 +1,17 @@
 <resources xmlns:tools="http://schemas.android.com/tools">
 
+    <string name="crop_image_activity_title"></string>
+    <string name="crop_image_menu_rotate_left">Rotate counter clockwise</string>
+    <string name="crop_image_menu_rotate_right">Rotate</string>
+    <string name="crop_image_menu_crop">Crop</string>
+    <string name="crop_image_menu_flip">Flip</string>
+    <string name="crop_image_menu_flip_horizontally">Flip horizontally</string>
+    <string name="crop_image_menu_flip_vertically">Flip vertically</string>
+
+    <string name="pick_image_intent_chooser_title">Select source</string>
+
+    <string name="crop_image_activity_no_permissions">Cancelling, required permissions are not granted</string>
+
     <attr name="overlaySurface" format="boolean" />
     <string name="app_name" translatable="false">Binder</string>
 
Index: app/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/colors.xml b/app/src/main/res/values/colors.xml
--- a/app/src/main/res/values/colors.xml	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/app/src/main/res/values/colors.xml	(date 1726417042837)
@@ -6,6 +6,7 @@
     <color name="app_color">#fa6565</color>
     <color name="app_color_one">#FF7356</color>
     <color name="app_color_two">#F72D79</color>
+    <color name="colorAccent">#FF9800</color>
 
     <color name="white">#fff</color>
     <color name="black">#2F2F2F</color>
@@ -14,6 +15,7 @@
     <color name="gainsboro">#DCDCDC</color>
     <color name="darkgray">#93959A</color>
     <color name="dimgray">#696969</color>
+    <color name="gray">#696969</color>
     <color name="transparent">#00ffffff</color>
     <color name="transparentBlack">#3C3C3C</color>
     <color name="green">#04b110</color>
Index: app/src/main/res/values/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/dimens.xml b/app/src/main/res/values/dimens.xml
--- a/app/src/main/res/values/dimens.xml	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/app/src/main/res/values/dimens.xml	(date 1726416654150)
@@ -1,2 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
-<resources></resources>
\ No newline at end of file
+<resources>
+    <dimen name="pv_pin_view_item_size">48dp</dimen>
+    <dimen name="pv_pin_view_item_radius">5dp</dimen>
+    <dimen name="pv_pin_view_item_spacing">5dp</dimen>
+    <dimen name="pv_pin_view_item_line_width">2dp</dimen>
+    <dimen name="pv_pin_view_cursor_width">2dp</dimen>
+</resources>
\ No newline at end of file
Index: app/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/styles.xml b/app/src/main/res/values/styles.xml
--- a/app/src/main/res/values/styles.xml	(revision 70abcd075995c773991e6e38420e69705f86c9bf)
+++ b/app/src/main/res/values/styles.xml	(date 1726416702914)
@@ -1,5 +1,17 @@
 <resources xmlns:tools="http://schemas.android.com/tools">
 
+    <style name="PinWidget" />
+
+    <style name="PinWidget.PinView" parent="Widget.AppCompat.EditText">
+        <item name="android:background">@null</item>
+        <item name="android:minHeight">0dp</item>
+        <item name="android:maxLines">1</item>
+        <item name="android:textCursorDrawable">@drawable/pv_invisible_image</item>
+        <item name="android:textSelectHandle">@drawable/pv_invisible_image</item>
+        <item name="android:textSelectHandleLeft">@drawable/pv_invisible_image</item>
+        <item name="android:textSelectHandleRight">@drawable/pv_invisible_image</item>
+    </style>
+
     <style name="noactionbar_whiteStatus" parent="Theme.MaterialComponents.NoActionBar">
         <item name="colorPrimary">@color/white</item>
         <item name="colorPrimaryDark">@color/black</item>
diff --git a/app/src/main/res/drawable-hdpi/crop_image_menu_rotate_right.png b/app/src/main/res/drawable-hdpi/crop_image_menu_rotate_right.png
new file mode 100644
index 0000000000000000000000000000000000000000..2311d1a08722eaafba6fdca9f4a0e7669880dc7a
GIT binary patch
literal 617
zc$@)g0+#)WP)<h;3K|Lk000e1NJLTq001@s001@!1ONa4CQPDM0006oNkl<ZcmeI!
z%}YI19LMp~RZEK^qA<io(xy#Pw29hS3oW6*!XRlC2|=#<AMT=PQ)oq0LW|mn1g(1d
zsXZv#1BPX_>mO*56olryf?y5|OgP`pLWukREQiaBJ9mbA(x5tbxJ~+ROQM_cOPDLb
z1h{f6z?EYGt{e++<yf4HV^f~>j$<NR92>G^S1!PXv4{Kw#JD(itv6lV$I3Cc`dYIS
zN1E}YiE?bbar@3~m^ETXv+s>drPx^GTYYJ|<<aLmH%sN%+j9DPQVaHto22F}c`=I3
z%UNlEsU5gc(%h5&Qn^2Z4f|PLUuwm6-Ox(Gx321rJ*Dmoy;kfq*SCCbN8LhqY#(s$
zPN@aE;yS5i(<;DLSL}9m8&V7Qkugd8HUX8%ZrF;t+13|*RQlIFtZum*_8#Cj!%}b~
zeg~{~!wvzTNa9<y{m)jrVZQ=ilM2@XI|cOrN7yCY#zVlTQhe5856HWK6C+{j>gc2Y
zoVvL%Hm~lPZrGH%%`o;ppfb@7OZEVjyF%36D*5;BiY=+zGZer+SNCY-&+}N_3ju7=
z8Tcx8ESQt?e1LnxnREBXu;dLnFBuMSeJP5K+Lv?S9;toqb6}zLka~+B<nVz<T+=*T
zdd!F5G;?t*b9<Wo;njTgb$<exE5eddYnpB6YulQ=T!7_0;OIi^$b(W5me=#REmbR4
z*|Df6m150JdfHoFkxv`eE$1U!94p@d8(;(Ma<RVwp2Kfg{Se0800000NkvXXu0mjf
DyPz%(

diff --git a/app/src/main/res/drawable-hdpi/crop_image_menu_rotate_left.png b/app/src/main/res/drawable-hdpi/crop_image_menu_rotate_left.png
new file mode 100644
index 0000000000000000000000000000000000000000..e4e26f8c0ec0386544969c3a7ef152baf773daa4
GIT binary patch
literal 634
zc$@)x0)_pFP)<h;3K|Lk000e1NJLTq001@s001@!1ONa4CQPDM0006(Nkl<ZcmeI#
zy=zlZ7=ZC>($=7eh+6zY6DL6sMFgi(sb4tw-2^um5$oXOzaT|~R;e^a5QI7iqB!Vc
zq0v@Tj33l%3vPARMJbA=y^kQAgC{w$=k2-NLGrv)?-_nj4sY%an$<>@Z3MCjSlncp
zp)(mQ#|-#l0?HQ?P|099K7kJ=rxL)n8Wc=(hx2R^V{%Ft@tguFF(#*UQ|ylq8)e}J
z$;5+g<Ri6(e8X&lb}vlNdZsb!q?JQFATs`)YvZ|%?Sx>t`a3Cu?iCq1)<?eX*&5zi
zuz)nZpc|56`+zFlb<bB(F)=-t&~Z?Lr3eA2a=PwpCFKSiq!-l`X?LuEYQ%E7f^jRB
zW&+h2ckBfKFvoW5`Ep9u-MCBN%$KfM4%NMe*Jl||t&8{}s;nD!5!Js|P=<Aur-xDX
zxM6nzfUmR=2&a`<0ASb+D^mJ1{X)pxqHk?j+*1Sqz9fNN0RVpfci0dB@L6_2t}hBJ
z0RV5@uwjp@-zL5KJ*W<du_LH1xM5jT_r=&FRGVEd$QS@H&khl_TQA~q_pRTJYE(d_
zsi4YBemo}u_{9kUb`4cXO7dFJK}4040_rm8x}+~WS2^Vjwa^E;n|`ly1uE=qc)Ewz
zpexhngB6$q;0edb)ck-R<uQNvp49|m%%pTbDC(0zzGF6KQgUnnvy!<5brJn6_5ZNw
z;=_X2Bpq>mGNs7#jL3@3Gs1C}#QmAOiF4d$K>vM%TbyNs{4+O+X<|*Ri6t<<0Y}<v
UbcQeJ761SM07*qoM6N<$f=iJeD*ylh

diff --git a/app/src/main/res/drawable-xxxhdpi/crop_image_menu_flip.png b/app/src/main/res/drawable-xxxhdpi/crop_image_menu_flip.png
new file mode 100644
index 0000000000000000000000000000000000000000..4200cb86992ebb9a57da74735668d5f43e0d74f4
GIT binary patch
literal 508
zc%17D@N?(olHy`uVBq!ia0vp^6F``Q1xWh(YZ)^zFdp`FaSW+oe0$gM)T00q_mA5r
z7#8}PHNA8EF~hOYG)(E8!Xv+&qr5Xrx<2}(u2iT@RGVJ>Z|#yFrQ1KM8XFtG7JBdX
zzpnFtB8SQZ2PRH9A*!>&BJgwS-3F^a|IW24XCM2^+<W7~rz{PJ^-<rZ)H3;IFtBm6
zTrhag{i0o+M~>q`xx9n$JOLJtw4IG^CITEQmYv|<(iq^d;WTH+g*N6a&CiUw3Niv~
zJ~4(WHuC*!@KbC&_p{;E1c&W44*8!VL_HK5S%eV8io@Sog;2#X6n%>5WkPi{=aY?E
z1O!wj9AAYhaN(}~-~W5M&%4#!GgJwf%AX-ClrfV(!$+F$h2unijg9>5TU4L2Xk|Jv
z#{Qftu3^Z}YNGm-&Fc>*^B3n=%o>J^<!mlY)m*8+z~x|H*#-yxZ9N{fjC;d2JvuP+
xc0xnmoRtwl6ZXyNPvk~*>rwVo77&lziT`=@$DFD!VxahC@O1TaS?83{1OVfYwv7M)

diff --git a/app/src/main/res/drawable-xxxhdpi/crop_image_menu_rotate_right.png b/app/src/main/res/drawable-xxxhdpi/crop_image_menu_rotate_right.png
new file mode 100644
index 0000000000000000000000000000000000000000..33ce670926056d7533f222d324cee9c8efcdaea8
GIT binary patch
literal 1570
zc$@(u2Hp9IP)<h;3K|Lk000e1NJLTq0058x0058(1ONa4O;0K_000H)Nkl<ZcmeI(
z>2Fol9*6N?Pe(wkrM66ZnG8tO0OAk{!4R<oN<@r9N~<Bnh?=P3h339I7>NTRK#3uY
z31QNPfC*qQAp`|e0U7SSObRqmkujG<5PEt#Jih1)->h|Z&))m2wRc_5_YZ)45*B-}
zbB+Yb<#M@PE*D88suQ9xJct~SCy@j4CUQV}A_wG2<bb@19FU&K0eKQRAa5cEq$hGf
zK8PHUhR6Zwh#Zif$N>c*azK!DK#?V~3sb^V%wZvzCyF-Ey}ZP7j?+dqCI1OP<;-Ib
zY5bM!$v}Bju~koFpU5Uq0dqM?I3;@;P=Yx$5oXDr1T>lBgkQ2}09CMoT$PMJ&@8T#
z%aU;hDq$tL?i!VG1scLpa@`e1Bk=^9z;$xnB}T^e44O#`+0@A|Ss&#W8G*zTsE&5J
z+jZ75lQIM$o0=Gk#1rUsI_OSqY-I`w{dI>v&ha1;PoNiR$Gbax&LGWwkauSogv1kQ
z0xfveMm+-%#k$u?1|abS8paL0YUHs1H;V9IDv@{s_2M|0OYuGlBmmG+%8@KLki2LB
zts`?yj1PDxeV8&N%MGWQ52FC|3YptW84?Jnky0efji4DwGu}2(fBsLV8Yn^n0Ue;P
zPac5N6x#)AAX95dAc27P(Z>hRZ~Watn?O}$s==Gb185Ju1M)zc(YAmJIEB7F6d{3t
zc2g3V2jDwfK=aVoL_Z`D&<-D`$3qGpfT=csin)ZYyNp8u0d1!+G#>cb2GHB+dk+Z&
z)IdSVf1_&CKnc#F>i~IyfHslu^P|b{(e;CApc&|DWfT$sXgvwU=N=}FuJLApcA{%3
zlI?svIq9|pU8_w34WJ!$e{g>QpcR2%FUz@wy4&<I2Q(jD3lQHx^+*W&3|+P6fPU1T
zKmC0JEk;7wK<zp7jVYi??cMW6#Mj_cB(!Zo-CcT_0h*1jiHNU#jD)x<bWJk@v<7v*
zlZQlL39h1Ukr|*fs9TOiWUEm3lL??wI#Kt0WPoO&E=5u9fhM7@oqHk!)Q?Wojm<sK
zJE%K~L}({bSC@OBrKnpGDWDCgTabI8?WmiN#Bt#R9YWm;4ybEQsC(1_b?qkV20Ngx
zrBHXD1L|4_>Ixl@19Jbw+#&7$n|BY2kq6r5UNtgriF;Y~cinL;Qb4CrS8MaatZxi1
z%*NQfa;=KNm207iOZ(HP`!X^>t5Mfz;*i$=@s~+Nf+wGAsQbbUPz|~!MFMClx~7@|
zs-OdPn<D}A73%I#Vg^XqkGeDit@8{fjk;}!DWDI~^@(+$Md+$A2h^W-)ZM1iDo+J}
zqV5*G%>fBJ&{c00s2*Lb5R*XF=xSxOHJ(RkL)SR7Knc#GtI^W)P#*iywa@$)$=?Eq
z)YZqk=$mF9sF-GSrFg;u&~PrI?x39?v%HDEi<Da+8m1wdVh1Rn6X@GZaYTr|wfBR%
z=g8DH@*_Z$Vx&DFVKbRpZ;9xF{*u)+Pz5*0)OJd&5}lyPE|4&b%<Z>wTo2^}(8^fE
zHjuE2%r*0jC8GIA6o5)NLgvzZ6!K|Q$iMlQ=PR{D14tOcRlGXF<Dv0P;D5k*FQVuG
z2~Tquui9D310fv1o9F~ELnMT?8MNVDie(Hzd~OtLNCSW=A|brh&`x*iU?<fSWO>fL
z%5FLVz$B3n=3b+X?sk)nyiA4n9W!t6HMdb@f=CE=)44--HL(TJY%3SgWQs@#drxwi
zY!l5inIy{12QP<=1HpL)#|20zqTV>rGKwM#q&bZ)8w0w+^yr>J`t@TiojC{UWF2Kl
zw1M=S$l;s<9bsZT9u)P<V>Z9$1n4Za<RS3^(l4J{j)e;JAL=MD`Yl%jdzOu~1O`g6
zg~^Di31(Ny9Cp#-3n;}d=2D87oM2<Usb&!eNp%aTm4hs127M6o6Kt-KG1QPmG+RI&
zV<|%HP3ZY^Kn}<OIUon*fE<vU19CtP$N@PZ2jqYpkedT?Kn}<OIUon*fE<w9U+kTE
Uv83F@0{{R307*qoM6N<$f?}Y*qyPW_

diff --git a/app/src/main/res/drawable-xxxhdpi/crop_image_menu_rotate_left.png b/app/src/main/res/drawable-xxxhdpi/crop_image_menu_rotate_left.png
new file mode 100644
index 0000000000000000000000000000000000000000..1eb686127baefb68d3453e1717cd6eb10702856a
GIT binary patch
literal 1577
zc${^Wdo<Gx7{_;GjWp(xTO&=$8zG4yb4ez&raMza$x3CWxo<UuvT1rFSwGj7vg1Uz
z-_n(B)y%5NB}-}|(nXV^^zJ>K_s{o_=lPuPInVQ)=RD^*&r?W>SZ|<bsRw~T42U5?
zWG%V>+B}5Thi`OT1%c>%CI<O$W<Vzf#*4Rf+ep5A@}kk=#7{<h>l)0=Lh=##t&xA5
zG?Xv`jq1tznHXO~yCU1xNpk2={cS=KK9+p<`+oD-1WX0*#+Tr84JD@-%LA6b%aF@N
z$Ps@8wQATa^TM@nm!{@^!V4Divj?8EnO^7``T8SkND|Qgi!DfA%m7+_u+sLoEX^Od
zM<K9M*&q1_Azg1-^R;N{xeu>k_;C4>|Df}h)gep3sjT6*MqJAP)|s&C4|ic2-M(&l
z^1H|(GpR49V!t=X3z^cjXVjDCkUC$@mngb?*2#Rid$558786*h7pFR0lZIB8OBAL_
zU#$d1gHk%xLB7j2*1ShbM_O>ZdVuQar9G5td@hSEO0;XaK50yeC$BP|To`hb7wkqf
z%y6wZWfA=lBa>;f3`bTWLY?H>*V?1XH@N+!&4HfpggIQBTX9i`hFbb=C0D_T+ySjm
zv${;&-FRlx4}ILg<3}r4WGgwk9DICF0O=3}xJBDbU=Y+1GeyMAf=w6$VB7w9m(xRz
zp4Okk!2a)*H=Xqe(>(T-6B(9w9rmi*>JAlA0kRwtPgGWAvzTnm+<Gvlo)ZNO|D-HA
zYHJ}pc?b?g9q}j?;?EMMPcxZ8H=36ja!I?tN4kp_Db_$(g`s_m=7l&6Q8iV-Jp%=9
zGevexz@}(xy>hQP#McMRC5zo_;?fW>Ot2zfSZwkVc`pCXzS5K1+LvjAbn-XGTZ}@$
zJ3&`>E`AAvcJy(C&)Yx1e3?Rz{P<Hb_g+8<4@h{$YPqw*EVV5UvHkohD3iT<v_IBZ
zfNT<oBD(I~xHAriObu^T+6!8dn)#qvUJAY$PqmG81!J0#8lACzK~O-S_YU|}Eu5Zt
z5PF8{_rMI->IBDK&SrzSwh2ghaL*|BLLl$Tw|U^+Ug*v|aB19$S)&ohu@`;NB!Vgl
zXBSlr@;sQKL?AgJo++*t@+Jr1TWXz&JK~w(^Fpv71?`Te8-%da=F_`|v5BZLk6^t-
z-?6Q1c-ikvBf3o{plqlSzJk|#Skw3Ul9J$?rbWomCK%lb>u@bjY46KLPVREeE&b;A
z_35wTH#una&#im3Ro3Yx9v4-1rwhC-mjiDFl@~IBQo#l?)`E{str3ccOQ{F7{fK;0
zOiO@|ZBj^6pbFKls|Zz6ie!GX(SfR+-UOavDiOyN15|Jk;MU*C8Nd&uX@}Je$7Pj(
z9y9on_ZwmKOv5Mw?denl4X7W@c!ec-ISEAmd69g_bDMhnZ88ZD_NF!+*3+y7=QzCx
z%RFJ)$29S(lL%1UuY(zTdaa<`m=9Y3jGMT=Bt$CK462L@8g4nqtV<-QbacI5UusxH
zS?F*TjZ@Z)-8SZj=J*dj7seFKINJHBdW-Mqz7aA%RzLJb=Y6oHpha2swD*1tUHp%U
z#wC<Wqq78+=S11XvZ}gqN7G~$yA;QyMKETXIht-eA&Y(1`it^#p{A)&nj0SLqc(p)
zH7Up%POm_`zkJctk`Slf4~rllXSW(z-&ZE++TPz+j0B4Dx=Wx(y{$sx8Y_%K%v&V9
z#;Pf3OrN#PvEQZVz9;T{-!QTJk#j==BikX~PBe;;*_W5FSL^$nOD0JUG`b8XbiNK0
z(pu;)rl><^>F!m5zuP-J<h&iZpFJ_}qQBN*I^CKIXSrDr%OK<J$QiyP&W~Bd=y4-0
ze6l>C23a@AaE^i}J&R7aGr(!yz`>LS%8s2Gwoi4Reez#0Y?A0#Ylzbx0rM75o-trk
zQK-(i9`S20&3!X)T!t%AFX86YUaDQ~Lej6i<bR-ZZdOX`B~rH%oU+8c>o%sQ(O1fr
zZ5JPPA2cCZP2KK9gc{8nM+=$NVI!tNEqSsy&%6^NR1Q`OPq#&@Sw7nBBmBRbnf|nL
YG%<Ngm=IN<eE|^Sx`-fQ!0u!J06pm0l>h($

diff --git a/app/src/main/res/drawable-xxhdpi/crop_image_menu_rotate_right.png b/app/src/main/res/drawable-xxhdpi/crop_image_menu_rotate_right.png
new file mode 100644
index 0000000000000000000000000000000000000000..796114cc4a028793ed39cb0b2a49175b45e0101c
GIT binary patch
literal 1165
zc$@)^1akX{P)<h;3K|Lk000e1NJLTq003+N003+V1ONa4C2yZb000D3Nkl<ZcmeI(
z?Q2(M9LMqRrklwSD<w4YCaXD(j4Zp;n#(6XkZ=^qYD;J81~J33D3H9KWRF&KLs3xC
zK(sPLB69dZ5`0pv8y!K6?2e(?Z<|QrZhpV>?x|hpY&+N4b)B6ZuJ`9Jc*#7w4m+3l
zrg}afi;?svxSvAh6$UD=Fi?4gfyyfkR9<1A@(Kf$R~V?g!a(H}1}d*GP<e%c$}0@i
z)P$9D3k|%)DKMvH6E>d~4$)7X)YO2@pn)$bVv@=_tcqvoB}po~uxae1K=M>JVYQrQ
zqN%LGDtVOv8|}>!teWq!Ra<soYw5>M0j)?@U`-4&b^$-|E=L)!5>Fsmfi)8_R>#@F
zJOn|F%X%Ei3hYrzjMfluQ4{N|2vDQ}$qH;8BaBuDi((&wVT6Z~tiW!dkLY@+GdkT5
zu@T7%Y$n}AcaT|#0c?;BNQ~XZr<A*gy+%|4&l<juU1B{FV|Q`^c-}Q^Edk+*G$BT?
ze_3b1f+22p39F=sZ~<EoBiKLG8nFOQQsxe}i>RJMj9?d8gT&aX%UA%7u3%TuN4Nus
z5$pnY$7Bug|9+>^4eUk2^-yI5>t_`bYu^yA)dj4QbLa)sA_lMmw;?fiKLL8bP;MW#
znQ-qT2C(z2Kn(UF;U2UPJAvLMt}}q0WjSKB1q`D1xoz0Bl+b$}i4E&zDPp|0(Hmio
zUD#9T1>6)H_6Ij6d_ND+YqksPM6VNxxh-6eB;0ZI4%viF<05)nkrcKay*|q9!B(PI
zWKJruc?9S!vj=NMuM0_Or_p=N9<1H`iD+%_ptsK+><D_zslo0=X{)yfJB3~?lD(P3
z{zPw4K41grU6~KqFnSeunEz4q4-fyiPw)$RYd(HKx1;w)K8{o^=zW)uLvYk<%iKwO
zZK-klqPZ;<SPOaun=hKeQS^?b0{aTRj}e=&HuM6jowJq_ZnIt3d`jrON%~L3VXiiZ
znf_1=vd}4OAw%dLL2SdC2-o2hwx4ht?87QKOSlJ|vFZrdL%DsJu!nGGnB@reE#bB!
zE?~1M5bhI4u$A<O{t+wOz=WMd^+HOt2E-Mtf}a6WJB8eS8SRAI&mr!k<ofG1jWz(l
zAT@4bLOapzaZ1~bxQ1Q9k3@Hv*-mJ8aF8<hFkvwTqWhKgNW#_A&8?IDSzjF^jMhg9
z{(8BbF90amqY26O2t`I~g!fos@PFt4B>=lLA?X?^F;*vOV*xV8mhd!PXxX9($+w9?
z#_K0OV0FaDDIJ_a%Pvir$X4@rqB{@@09?|9iERmAJAlEl$%Y9PyiCa|EZ`MpWaHA#
zJ#<-vb+aZ**R0Cf!MO>;&eO*9>|KnT$&>t+7}m>fs<L~PaXR&U#;_5rNGF@9m<pFq
z=hDo6{u&q7&tbN4%~ZQCTt+nyv6qbz2i|=&vWzms)r1_(!<^5<Jj}y9%)>m)!#vEx
fJj}y9%)|Zziy-WXhtC%200000NkvXXu0mjfSN$KD

diff --git a/app/src/main/res/drawable-xxhdpi/crop_image_menu_rotate_left.png b/app/src/main/res/drawable-xxhdpi/crop_image_menu_rotate_left.png
new file mode 100644
index 0000000000000000000000000000000000000000..5ae4f53e0255f2509cba52805a46bb5f21f23605
GIT binary patch
literal 1181
zc$@*91Y-M%P)<h;3K|Lk000e1NJLTq003+N003+V1ONa4C2yZb000DJNkl<ZcmeI(
zZD>|y9LMqhc5ls|ge+$g#hsF@gl!pZ)Ry!_fiE(qnZ-c2bhFGX2+D}MyQ3GDy@<jj
z0*R~_8)cTkda_<QXgy8BdQsv7W_!w6WNy39zP<5H|8s8cbFJ$-J3E~3@9o}v;Oy*z
zvrE#_(vlZh#Px*emm`-%SPqg1%Rv%hIY=VxIY<;tu@V4NtfascD=9F=N+K)|NrdGg
ziLg8*5tfGpzzkS$fET!r#gxxH*z<&Gm@d{+9c!3o88pFO?x8Z)FwHXPD4RJi&M?g~
zX^@A=#1p1j=6z37^f31<0FSLy#tZfsw(4VHoM6JkOk$^Dn&Si$Iz!NUc!M8G{@fW>
z#|b91;SrQRQq8B6uS)#3wZ;i1v{EPyJG-md!8pY#uqsY4VKoyF`VgFD7sZ<3<~YHG
zm5dvm?r-N;f*T?m1uVk{T!)0%a>fi`!fd(;uAf=%Vb1_3L(-OUrUXoH3&Cx34XbAY
zfImXg?%=c$OlYHkKaXaYuyXnU&eE13A$BW&8^MHjg8G>Xcd!QljA={x%LpbsNl+VI
z!OrD4Oo?_Qr;K1i7ybsB?FP0PfBTV8Yv802>;ewqZ;K091xL|&+<=7K5=IPQ!fp6F
zPNjX=O8mWv7_62d1DNnO{#xzBK1Fw$`H0aL^Sc2o%NV*ZZNo0bL-z_|yc&KB4HLGb
z^O$EBwgH{Tl?dj$iesT+HB6%0XczV&x=)ZPZUJkNkoz3n$2MUZ{zSJ1!TmbWjZ$t8
zR*%l(;z(d~@zB-TgSDgk28n3>=sN7dwxN49GT3%>FWG~wAg9(C8EhT8-3G82?-q3Z
z$$(|i9Z3dk4!V(Kz|KK8mcr6UF@1Tsf88hX5A^%VI8wci?nQgBHgw-c20MUmy**eR
zI*&^tVO8UytF;Hqa0*>pB(P3&Cn>iF6ZW9{EE3ok==LHuVV&qES?HW~4gMaq3!6s)
z-D}QaJJ1!VwhI$_(EY<@PFV{WN4F2L4Qs*QPN%SU@pr#{Scb#sCTVuYx)XoLsI(6g
zHsP<=5o<Pw@%IGc0yc|d{I_B1oUqE+jlTgdbORICM#2)FhTs>yD_9x5004|o@AkBz
zI!J{(m{7~OV^#+q1b;hq2@{@j$SNa8a9a`AuyVS&)(Pt(_7L26RGGu<?RtJ<IWom9
z;|ReGa5-W+o2*d)KBC6_D<@qPYn+=9^Vwzr6nMwrVXbE;1&TF63o?DM21e2K@o0&!
z)K~Bby%Y}$+>1;ftdUWQ^$TyY6j5tpCkH9jX<Cq}&LYd;|4DO{Zh%H)I$`_30c<~6
zWO`v$yv(FkSb;nh@wfug#E;fsU(*n$OFI>8V(@>%POy%$_+7I)pT{{qW!ND$P!->c
zah0s1hk_AojQ6;U%uKkWIhS_287c`o!7kP?XQthQE@Kg^$p;*a@8(%nun2KCA#qD#
vDJ+GhuoRZUQdkO0VJR$yrLYv1!W`^hu2AEoBTAo?00000NkvXXu0mjfp*bNJ

diff --git a/app/src/main/res/drawable-xxhdpi/crop_image_menu_flip.png b/app/src/main/res/drawable-xxhdpi/crop_image_menu_flip.png
new file mode 100644
index 0000000000000000000000000000000000000000..3629e38d1dc73f6bd80c3551fa16a9135a3dcbc8
GIT binary patch
literal 417
zc%17D@N?(olHy`uVBq!ia0vp^IUvlz0wh)Q=esd5FlKnVIEGX(zP)33N~%zx?c>`L
z?Ld9u2od{>k2}mKtaUx2{M2C4wABK^b}zqcD{Yoi|FkFnxBHJ!V=?Qa|K*Z-j9-PN
zi>%K(_&WNs-(Ua4LoJ-bYCaJsCz(pW+FvHtU~6_{`I^W8JASig2YTIu+Y|ct@7$FB
zh37^Kw}X_#ftjnca}MQuus2(Wir<*Qy`<$}XQE75!xn=Zu8FGKuWV?m<Js17#bCzq
zgx6m-gz{`#ICp-&?1lUHeV8{K(3+C4^b`}&wiyPAhnSpgG<7~$L#)5S&XW<Y1#!z6
z#<yOoU?nX-`J=!zXR*WXAWn!zzKn8Lu)=R2=STibyrX3MMw?B0=dw1_FG(AkYO`)k
zQ{s{?^y9WR>Nw1$^-eQ!|Bs7bJDiSc%D%ag=9<9jTxOD)z#GkW-a6z``ngwc+r7eS
sE`HwP^PLM~{!jnfXX_0TIe)XS)?*JokpK4?Fz6XPUHx3vIVCg!0B7W_KmY&$

diff --git a/app/src/main/res/drawable-xhdpi/crop_image_menu_rotate_left.png b/app/src/main/res/drawable-xhdpi/crop_image_menu_rotate_left.png
new file mode 100644
index 0000000000000000000000000000000000000000..bdfcbca828b68fd778f7d7e6e89ba3c04578d249
GIT binary patch
literal 798
zc$@(q1L6FMP)<h;3K|Lk000e1NJLTq002k;002k`1ONa4|Kxkj0008zNkl<ZcmeI%
z%}W$v9KiAQH3~9A#Udg+WG^UGP#F;g9oiD3LsID>Fp+FQyA*Y^A}RzeEb`(-L4*zx
zl!a7ar1ts`NI`W83Q64+cGI12m*~f^&W`&$&)7ioeU7t-4?8c<GtY#A{_AKXq&q^G
z8*ShZkZ^nix&r<I3CAZO;rIe{75oGejxRvM@dZdY(h%*Op!i>auHl@;Ya*=H2bthV
zF*;al5TwD8qFf};YfuB3^^T3+f>!X1%!*Ru?I~N%Qx@(t-FzjrB+cGl)XR7T;P4#U
z#{fy}Su}Zj+vhV#YI3}S=P9J4CP3>6I~>X5fy<M+nK%;6uvr(B%?NQ0I~>iS-(~99
z#SbKSPp%#)0+5!}>oS*Zv6Hy011jPt{2_%M|HB@a$#o}jq$s88pqof>${c=`MYqdr
z--HBrR6#45K^jU+?{Zmw3?s!TR0B05%~9@hwRNNgZDk(myc%c>sV^-?PO$UQexxxK
zP$?GD?nN%yoR956vRIQj=oHdNLi&TxNVS=RZX<OW0o_CD%p5d~RA&TKhxEi9<o(!=
zG~owO5z?d|K>0|C0F*i?_S-4jfi$6a+t(Wb)$85%ok(|$fbQ!(7*8U7G6MR7RI59=
zR%vtg>Q1g9#*zB8K?6vmYU`nMDGN09QArZ1MGaKI4ANr_P8KhaqO4L~<hLWmSf>n%
zfc*|r1r;;(m$P4)Q$+%4ni8EC#TEc&H8>SaBEbdSSLs*GazNu|w{zZ*qr2I#A%#;(
z_98FkR(>JD6y@f(V`@n7*8MGnZM?)@l4|q&L)9bzfFZ&Te}5JS8N|Y#MT7Ybt0Tk#
z={vogwf&-z9=?&<9B0gL>4k;kxCOIt(;V_*({mFaltAN@d9^K^%OzqNfu?9B*V~Qr
zQaXt(3N+0PN|xr+LLm`Gu^d73jL=BIQh%N*;W)RjuL2%&onsXG;WN3$2tWZS00p1`
c6o53wZ-Cqgpa}7w>;M1&07*qoM6N<$f}b#H$p8QV

diff --git a/app/src/main/res/drawable-hdpi/crop_image_menu_flip.png b/app/src/main/res/drawable-hdpi/crop_image_menu_flip.png
new file mode 100644
index 0000000000000000000000000000000000000000..133395df364ccbc3a7e6356252a911d3adbb604b
GIT binary patch
literal 262
zc$@(S0r~!kP)<h;3K|Lk000e1NJLTq001@s001@!1ONa4CQPDM0002ZNkl<ZSi|ku
z(Fubv5P;$60y;-Ta0ByPbeE3kBI+da_a$winkaY%3wL=7!4H$WhdX05e9$oX)m)D`
z-r*FBeJ;b&;(k^c!YEf~3TpBrRL8_txFEK@Gt=)=3y5H_(8Vus0x=9GvM^>r6oV>^
zwVy-JQwj3jDNd!eSn4abduH{DS7Jy0Ua@;&DHBACT8mmSEo#NIs1?(qzAu)vWva!S
zK^w+$W>IX6w7JI6i#G6&RHKP;m+~`%>h#dXMlVnYWofaL!_B{m7s({l@QL1$Hvj+t
M07*qoM6N<$f&|cTX8-^I

diff --git a/app/src/main/res/drawable-xhdpi/crop_image_menu_flip.png b/app/src/main/res/drawable-xhdpi/crop_image_menu_flip.png
new file mode 100644
index 0000000000000000000000000000000000000000..79910ffe0c869d2f4d2795b47ef54af881a12cb7
GIT binary patch
literal 259
zc%17D@N?(olHy`uVBq!ia0vp^9w5xY0wn)GsXhawPI<aGhGg7(d()P$*?_0*p-(}3
z(J_v7C;MF<YI$_LeSKjm_u9bh?rrbQ(@sv-*w((p<)3~Phk`@Hnb{(zvbJWZi(Pp4
zYnfy3Ddjm{;kIX^7gVQ(e!E?H@F$1ItdJWHkz9<PTY0avHC9Pya5AseOMMgft$~5@
zlN|%lh!@Tc42Gu}7?Y+kGO={nv2X}%<`G!%o+&r|ca+2-hq=60S{gU;hGg+E_8#Nk
zGbJRmh`o20Oy!NGSzn`K9adYVet!F7JLh)>rZ2?`LbIhK+*@W#6`pSe`ijBR)z4*}
HQ$iB}?Eq(9

diff --git a/app/src/main/res/drawable-xhdpi/crop_image_menu_rotate_right.png b/app/src/main/res/drawable-xhdpi/crop_image_menu_rotate_right.png
new file mode 100644
index 0000000000000000000000000000000000000000..6d73012561e6e9418f2d630d8193a4fd87f61049
GIT binary patch
literal 787
zc$@(f1MK{XP)<h;3K|Lk000e1NJLTq002k;002k`1ONa4|Kxkj0008oNkl<ZXa()T
z&1)2Q9LMob9=0M_YEr?V1uvm$D0)zQBBu(r=~kibp?YZr8&XLxdhno^L5&Yo1f!)7
zP<pVBP!B@2bW0&5msa#YsHI*6E3%qIGU{&L5*PdZ?e46}%<N<q+}BHLdj8<4u>hVL
z2{Sx34oW;V3ZC-R7%-k10WMGJqnxL-QOQ#}Si<{!%4Mo~nqPD>$e&D8o2U6g7pIwI
zcAk<)h67A6SDuo^t6U?T50o5sFiAMSu~122FGZ@|;B!7C*d-PyDGX4l$Pe`D34&bY
z1to<YOjGW6dh|c4{Y*wlVKw8prs!80D*Z&e0<n!1iiZr>aNT0PDp2lQ+7yUBe8y;1
z92~-Ri<PQ^>l<1Xh_~>W@rk0Ni%HBB>l6U<6)g%x7N3$lor;Qcxb`RzPkly<0@00+
zIj(5v<UZ!IYM|tdo`D?Z9xo~i_F)RFR1M5HrDtLl1<Zh=;0orvY66aFR(y{cRd_7N
zwNW*3SaZM@OpzrDi(Q!OsssMTyr-}j#tf?t_yTiMVUfe^R2{Gzb4g)w9kWL1Bai7&
z`gn-RD1AJ{WRyPgm=2|nzcFi-K602{ssnaoeo<HqW6r7$_!4tMVX+hQkLrLMn0FNx
z%W!Q{O!Q)kysYr}3-g^~;z!JgqF^7Uz-q-n4@FGBqM(CGOinS7!`x+&qTwvA0YyYN
z4=_g+6<thVd^RW|-o~fo4jqb)gSc+fqloCkXU4~hgLbasy3Hm<#2ZX8LW|;I72~*k
z1~n(N@tVr8l~)uW+bL3Rgf*H4o4JZlR!N|rY06D=f!AqK0NQwyUn%j)DhUiwpxRBo
z<|8@S%X$98<&#ws$TC47ISAs@rzFtL6#~dXkTF&$8ML#XdsL8vN_hrpRgzfBNyc%=
zfh*4toth84L_ebxctQ?J9`OfzSfu&IV%}khi*j&*BW!1}nwpxLnwp+lj{)PiHx@^F
RRt*3E002ovPDHLkV1mQ+U(Wyl

